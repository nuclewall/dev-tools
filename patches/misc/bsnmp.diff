diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/gensnmpdef/gensnmpdef.c BSNMP_NEW/src/contrib/bsnmp/gensnmpdef/gensnmpdef.c
--- BSNMP_CVS/src/contrib/bsnmp/gensnmpdef/gensnmpdef.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/gensnmpdef/gensnmpdef.c	Tue Sep 13 11:21:29 2005
@@ -371,6 +371,11 @@ main(int argc, char *argv[])
 	long u;
 	char *end;
 
+        if ( argc <= 1 ){
+		fprintf(stderr, usgtxt);
+		exit(0);
+	}
+	 
 	smiInit(NULL);
 
 	while ((opt = getopt(argc, argv, "c:h")) != -1)
@@ -396,6 +401,11 @@ main(int argc, char *argv[])
 	argc -= optind;
 	argv += optind;
 
+        if( argc == 0 ){
+		fprintf(stderr,"No MIB specified\n");
+		exit(0);
+	}
+	
 	flags = smiGetFlags();
 	flags |= SMI_FLAG_ERRORS;
 	smiSetFlags(flags);
@@ -424,6 +434,10 @@ main(int argc, char *argv[])
 				break;
 		}
 	}
-	level = close_node(last->oidlen - 1, level - 1);
+	if( last != NULL ){
+		level = close_node(last->oidlen - 1, level - 1);
+	}
+	
+	free(mods);	
 	return (0);
 }
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/gensnmptree/gensnmptree.c BSNMP_NEW/src/contrib/bsnmp/gensnmptree/gensnmptree.c
--- BSNMP_CVS/src/contrib/bsnmp/gensnmptree/gensnmptree.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/gensnmptree/gensnmptree.c	Tue Sep 13 11:21:29 2005
@@ -898,6 +898,8 @@ main(int argc, char *argv[])
 	int opt;
 	struct node *root;
 	char fname[MAXPATHLEN + 1];
+	char include_fname[MAXPATHLEN + 128 +1];
+	int idx;
 	int tok;
 
 	while ((opt = getopt(argc, argv, "help:t")) != EOF)
@@ -955,13 +957,24 @@ main(int argc, char *argv[])
 		return (0);
 	}
 	sprintf(fname, "%stree.h", file_prefix);
+	
+	/*prepare the ifndef directive*/
+	memset(include_fname,'\0',sizeof(include_fname));
+	snprintf(include_fname, MAXPATHLEN + 128, "_%sTREE_H_INCLUDED__",file_prefix);
+	for(idx = 0; idx < strlen(include_fname); idx++){
+		include_fname[idx] = toupper(include_fname[idx]);		
+	}
+			
 	if ((fp = fopen(fname, "w")) == NULL)
 		err(1, "%s: ", fname);
+	
+	fprintf(fp, "#ifndef %s\n",include_fname);
+	fprintf(fp, "#define %s\n",include_fname);		
 	gen_header(root, PREFIX_LEN, NULL);
 
 	fprintf(fp, "#define %sCTREE_SIZE %u\n", file_prefix, tree_size);
 	fprintf(fp, "extern const struct snmp_node %sctree[];\n", file_prefix);
-
+	fprintf(fp, "#endif /* %s */\n",include_fname);
 	fclose(fp);
 
 	sprintf(fname, "%stree.c", file_prefix);
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII.c BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII.c
--- BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII.c	Tue Sep 13 11:21:29 2005
@@ -34,6 +34,9 @@
 #include "mibII_oid.h"
 #include <net/if_types.h>
 
+/*just a prototype below*/
+u_int 
+mib2_getIfIndex(const char* dev_name);
 
 /*****************************/
 
@@ -54,8 +57,8 @@ static int in_update_arp;
 /* OR registrations */
 static u_int ifmib_reg;
 static u_int ipmib_reg;
-static u_int tcpmib_reg;
-static u_int udpmib_reg;
+
+
 static u_int ipForward_reg;
 
 /*****************************/
@@ -109,8 +112,6 @@ static struct newifreg_list newifreg_lis
 
 static const struct asn_oid oid_ifMIB = OIDX_ifMIB;
 static const struct asn_oid oid_ipMIB = OIDX_ipMIB;
-static const struct asn_oid oid_tcpMIB = OIDX_tcpMIB;
-static const struct asn_oid oid_udpMIB = OIDX_udpMIB;
 static const struct asn_oid oid_ipForward = OIDX_ipForward;
 static const struct asn_oid oid_linkDown = OIDX_linkDown;
 static const struct asn_oid oid_linkUp = OIDX_linkUp;
@@ -1439,11 +1440,6 @@ mibII_start(void)
 	   "The MIB module for managing IP and ICMP implementations, but "
 	   "excluding their management of IP routes.", module);
 
-	tcpmib_reg = or_register(&oid_tcpMIB,
-	   "The MIB module for managing TCP implementations.", module);
-
-	udpmib_reg = or_register(&oid_udpMIB,
-	   "The MIB module for managing UDP implementations.", module);
 
 	ipForward_reg = or_register(&oid_ipForward,
 	   "The MIB module for the display of CIDR multipath IP Routes.",
@@ -1501,8 +1497,6 @@ mibII_fini(void)
 	/* XXX free memory */
 
 	or_unregister(ipForward_reg);
-	or_unregister(udpmib_reg);
-	or_unregister(tcpmib_reg);
 	or_unregister(ipmib_reg);
 	or_unregister(ifmib_reg);
 
@@ -1564,3 +1558,19 @@ mibif_unnotify(void *arg)
 	ifp->xnotify_data = NULL;
 	ifp->xnotify_mod = NULL;
 }
+
+
+/*
+ * Get the MIB II ifIndex for the device with
+ * the name passed as argument (ie "rl0")
+ */
+u_int 
+mib2_getIfIndex(const char* dev_name){
+	struct mibindexmap *map;
+	
+	STAILQ_FOREACH(map, &mibindexmap_list, link)
+		if (strcmp(map->name, dev_name) == 0) {
+			return map->ifindex;
+		}
+	return 0;	
+}	
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_tcp.c BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_tcp.c
--- BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_tcp.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_tcp.c	Tue Sep 13 11:21:29 2005
@@ -1,357 +0,0 @@
-/*
- * Copyright (c) 2001-2003
- *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).
- *	All rights reserved.
- *
- * Author: Harti Brandt <harti@freebsd.org>
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Begemot: bsnmp/snmp_mibII/mibII_tcp.c,v 1.7 2005/05/23 09:03:42 brandt_h Exp $
- *
- * tcp
- */
-#include "mibII.h"
-#include "mibII_oid.h"
-#include <sys/socketvar.h>
-#include <netinet/in_pcb.h>
-#include <netinet/tcp.h>
-#include <netinet/tcp_var.h>
-#include <netinet/tcp_timer.h>
-#include <netinet/tcp_fsm.h>
-
-struct tcp_index {
-	struct asn_oid	index;
-	struct xtcpcb	*tp;
-};
-
-static uint64_t tcp_tick;
-static struct tcpstat tcpstat;
-static struct xinpgen *xinpgen;
-static size_t xinpgen_len;
-static u_int tcp_count;
-static u_int tcp_total;
-
-static u_int oidnum;
-static struct tcp_index *tcpoids;
-
-static int
-tcp_compare(const void *p1, const void *p2)
-{
-	const struct tcp_index *t1 = p1;
-	const struct tcp_index *t2 = p2;
-
-	return (asn_compare_oid(&t1->index, &t2->index));
-}
-
-static int
-fetch_tcp(void)
-{
-	size_t len;
-	struct xinpgen *ptr;
-	struct xtcpcb *tp;
-	struct tcp_index *oid;
-	in_addr_t inaddr;
-
-	len = sizeof(tcpstat);
-	if (sysctlbyname("net.inet.tcp.stats", &tcpstat, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.tcp.stats: %m");
-		return (-1);
-	}
-	if (len != sizeof(tcpstat)) {
-		syslog(LOG_ERR, "net.inet.tcp.stats: wrong size");
-		return (-1);
-	}
-
-	len = 0;
-	if (sysctlbyname("net.inet.tcp.pcblist", NULL, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.tcp.pcblist: %m");
-		return (-1);
-	}
-	if (len > xinpgen_len) {
-		if ((ptr = realloc(xinpgen, len)) == NULL) {
-			syslog(LOG_ERR, "%zu: %m", len);
-			return (-1);
-		}
-		xinpgen = ptr;
-		xinpgen_len = len;
-	}
-	if (sysctlbyname("net.inet.tcp.pcblist", xinpgen, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.tcp.pcblist: %m");
-		return (-1);
-	}
-
-	tcp_tick = get_ticks();
-
-	tcp_count = 0;
-	tcp_total = 0;
-	for (ptr = (struct xinpgen *)(void *)((char *)xinpgen + xinpgen->xig_len);
-	     ptr->xig_len > sizeof(struct xinpgen);
-             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
-		tp = (struct xtcpcb *)ptr;
-		if (tp->xt_inp.inp_gencnt > xinpgen->xig_gen ||
-		    (tp->xt_inp.inp_vflag & INP_IPV4) == 0)
-			continue;
-
-		tcp_total++;
-		if (tp->xt_tp.t_state == TCPS_ESTABLISHED ||
-		    tp->xt_tp.t_state == TCPS_CLOSE_WAIT)
-			tcp_count++;
-	}
-
-	if (oidnum < tcp_total) {
-		oid = realloc(tcpoids, tcp_total * sizeof(tcpoids[0]));
-		if (oid == NULL) {
-			free(tcpoids);
-			oidnum = 0;
-			return (0);
-		}
-		tcpoids = oid;
-		oidnum = tcp_total;
-	}
-
-	oid = tcpoids;
-	for (ptr = (struct xinpgen *)(void *)((char *)xinpgen + xinpgen->xig_len);
-	     ptr->xig_len > sizeof(struct xinpgen);
-             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
-		tp = (struct xtcpcb *)ptr;
-		if (tp->xt_inp.inp_gencnt > xinpgen->xig_gen ||
-		    (tp->xt_inp.inp_vflag & INP_IPV4) == 0)
-			continue;
-		oid->tp = tp;
-		oid->index.len = 10;
-		inaddr = ntohl(tp->xt_inp.inp_laddr.s_addr);
-		oid->index.subs[0] = (inaddr >> 24) & 0xff;
-		oid->index.subs[1] = (inaddr >> 16) & 0xff;
-		oid->index.subs[2] = (inaddr >>  8) & 0xff;
-		oid->index.subs[3] = (inaddr >>  0) & 0xff;
-		oid->index.subs[4] = ntohs(tp->xt_inp.inp_lport);
-		inaddr = ntohl(tp->xt_inp.inp_faddr.s_addr);
-		oid->index.subs[5] = (inaddr >> 24) & 0xff;
-		oid->index.subs[6] = (inaddr >> 16) & 0xff;
-		oid->index.subs[7] = (inaddr >>  8) & 0xff;
-		oid->index.subs[8] = (inaddr >>  0) & 0xff;
-		oid->index.subs[9] = ntohs(tp->xt_inp.inp_fport);
-		oid++;
-	}
-
-	qsort(tcpoids, tcp_total, sizeof(tcpoids[0]), tcp_compare);
-
-	return (0);
-}
-
-/*
- * Scalars
- */
-int
-op_tcp(struct snmp_context *ctx __unused, struct snmp_value *value,
-    u_int sub, u_int iidx __unused, enum snmp_op op)
-{
-	switch (op) {
-
-	  case SNMP_OP_GETNEXT:
-		abort();
-
-	  case SNMP_OP_GET:
-		break;
-
-	  case SNMP_OP_SET:
-		return (SNMP_ERR_NOT_WRITEABLE);
-
-	  case SNMP_OP_ROLLBACK:
-	  case SNMP_OP_COMMIT:
-		abort();
-	}
-
-	if (tcp_tick < this_tick)
-		if (fetch_tcp() == -1)
-			return (SNMP_ERR_GENERR);
-
-	switch (value->var.subs[sub - 1]) {
-
-	  case LEAF_tcpRtoAlgorithm:
-		value->v.integer = 4;	/* Van Jacobson */
-		break;
-
-#define hz clockinfo.hz
-
-	  case LEAF_tcpRtoMin:
-		value->v.integer = 1000 * TCPTV_MIN / hz;
-		break;
-
-	  case LEAF_tcpRtoMax:
-		value->v.integer = 1000 * TCPTV_REXMTMAX / hz;
-		break;
-#undef hz
-
-	  case LEAF_tcpMaxConn:
-		value->v.integer = -1;
-		break;
-
-	  case LEAF_tcpActiveOpens:
-		value->v.uint32 = tcpstat.tcps_connattempt;
-		break;
-
-	  case LEAF_tcpPassiveOpens:
-		value->v.uint32 = tcpstat.tcps_accepts;
-		break;
-
-	  case LEAF_tcpAttemptFails:
-		value->v.uint32 = tcpstat.tcps_conndrops;
-		break;
-
-	  case LEAF_tcpEstabResets:
-		value->v.uint32 = tcpstat.tcps_drops;
-		break;
-
-	  case LEAF_tcpCurrEstab:
-		value->v.uint32 = tcp_count;
-		break;
-
-	  case LEAF_tcpInSegs:
-		value->v.uint32 = tcpstat.tcps_rcvtotal;
-		break;
-
-	  case LEAF_tcpOutSegs:
-		value->v.uint32 = tcpstat.tcps_sndtotal -
-		    tcpstat.tcps_sndrexmitpack;
-		break;
-
-	  case LEAF_tcpRetransSegs:
-		value->v.uint32 = tcpstat.tcps_sndrexmitpack;
-		break;
-
-	  case LEAF_tcpInErrs:
-		value->v.uint32 = tcpstat.tcps_rcvbadsum +
-		    tcpstat.tcps_rcvbadoff +
-		    tcpstat.tcps_rcvshort;
-		break;
-	}
-	return (SNMP_ERR_NOERROR);
-}
-
-int
-op_tcpconn(struct snmp_context *ctx __unused, struct snmp_value *value,
-    u_int sub, u_int iidx __unused, enum snmp_op op)
-{
-	u_int i;
-
-	if (tcp_tick < this_tick)
-		if (fetch_tcp() == -1)
-			return (SNMP_ERR_GENERR);
-
-	switch (op) {
-
-	  case SNMP_OP_GETNEXT:
-		for (i = 0; i < tcp_total; i++)
-			if (index_compare(&value->var, sub, &tcpoids[i].index) < 0)
-				break;
-		if (i == tcp_total)
-			return (SNMP_ERR_NOSUCHNAME);
-		index_append(&value->var, sub, &tcpoids[i].index);
-		break;
-
-	  case SNMP_OP_GET:
-		for (i = 0; i < tcp_total; i++)
-			if (index_compare(&value->var, sub, &tcpoids[i].index) == 0)
-				break;
-		if (i == tcp_total)
-			return (SNMP_ERR_NOSUCHNAME);
-		break;
-
-	  case SNMP_OP_SET:
-		return (SNMP_ERR_NOT_WRITEABLE);
-
-	  case SNMP_OP_ROLLBACK:
-	  case SNMP_OP_COMMIT:
-	  default:
-		abort();
-	}
-
-	switch (value->var.subs[sub - 1]) {
-
-	  case LEAF_tcpConnState:
-		switch (tcpoids[i].tp->xt_tp.t_state) {
-
-		  case TCPS_CLOSED:
-			value->v.integer = 1;
-			break;
-		  case TCPS_LISTEN:
-			value->v.integer = 2;
-			break;
-		  case TCPS_SYN_SENT:
-			value->v.integer = 3;
-			break;
-		  case TCPS_SYN_RECEIVED:
-			value->v.integer = 4;
-			break;
-		  case TCPS_ESTABLISHED:
-			value->v.integer = 5;
-			break;
-		  case TCPS_CLOSE_WAIT:
-			value->v.integer = 8;
-			break;
-		  case TCPS_FIN_WAIT_1:
-			value->v.integer = 6;
-			break;
-		  case TCPS_CLOSING:
-			value->v.integer = 10;
-			break;
-		  case TCPS_LAST_ACK:
-			value->v.integer = 9;
-			break;
-		  case TCPS_FIN_WAIT_2:
-			value->v.integer = 7;
-			break;
-		  case TCPS_TIME_WAIT:
-			value->v.integer = 11;
-			break;
-		  default:
-			value->v.integer = 0;
-			break;
-		}
-		break;
-
-	  case LEAF_tcpConnLocalAddress:
-		value->v.ipaddress[0] = tcpoids[i].index.subs[0];
-		value->v.ipaddress[1] = tcpoids[i].index.subs[1];
-		value->v.ipaddress[2] = tcpoids[i].index.subs[2];
-		value->v.ipaddress[3] = tcpoids[i].index.subs[3];
-		break;
-
-	  case LEAF_tcpConnLocalPort:
-		value->v.integer = tcpoids[i].index.subs[4];
-		break;
-
-	  case LEAF_tcpConnRemAddress:
-		value->v.ipaddress[0] = tcpoids[i].index.subs[5];
-		value->v.ipaddress[1] = tcpoids[i].index.subs[6];
-		value->v.ipaddress[2] = tcpoids[i].index.subs[7];
-		value->v.ipaddress[3] = tcpoids[i].index.subs[8];
-		break;
-
-	  case LEAF_tcpConnRemPort:
-		value->v.integer = tcpoids[i].index.subs[9];
-		break;
-	}
-	return (SNMP_ERR_NOERROR);
-}
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_tree.def BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_tree.def
--- BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_tree.def	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_tree.def	Tue Sep 13 11:21:29 2005
@@ -148,41 +148,6 @@
         (25 icmpOutAddrMasks COUNTER op_icmpstat GET)
         (26 icmpOutAddrMaskReps COUNTER op_icmpstat GET)
       )
-      (6 tcp
-        (1 tcpRtoAlgorithm INTEGER op_tcp GET)
-        (2 tcpRtoMin INTEGER32 op_tcp GET)
-        (3 tcpRtoMax INTEGER32 op_tcp GET)
-        (4 tcpMaxConn INTEGER32 op_tcp GET)
-        (5 tcpActiveOpens COUNTER op_tcp GET)
-        (6 tcpPassiveOpens COUNTER op_tcp GET)
-        (7 tcpAttemptFails COUNTER op_tcp GET)
-        (8 tcpEstabResets COUNTER op_tcp GET)
-        (9 tcpCurrEstab GAUGE op_tcp GET)
-        (10 tcpInSegs COUNTER op_tcp GET)
-        (11 tcpOutSegs COUNTER op_tcp GET)
-        (12 tcpRetransSegs COUNTER op_tcp GET)
-        (13 tcpConnTable
-          (1 tcpConnEntry : IPADDRESS INTEGER IPADDRESS INTEGER op_tcpconn
-            (1 tcpConnState INTEGER GET)
-            (2 tcpConnLocalAddress IPADDRESS GET)
-            (3 tcpConnLocalPort INTEGER GET)
-            (4 tcpConnRemAddress IPADDRESS GET)
-            (5 tcpConnRemPort INTEGER GET)
-        ))
-        (14 tcpInErrs COUNTER op_tcp GET)
-        (15 tcpOutRsts COUNTER op_tcp)		# don't know
-      )
-      (7 udp
-        (1 udpInDatagrams COUNTER op_udp GET)
-        (2 udpNoPorts COUNTER op_udp GET)
-        (3 udpInErrors COUNTER op_udp GET)
-        (4 udpOutDatagrams COUNTER op_udp GET)
-        (5 udpTable
-          (1 udpEntry : IPADDRESS INTEGER op_udptable
-            (1 udpLocalAddress IPADDRESS GET)
-            (2 udpLocalPort INTEGER GET)
-        ))
-      )
       (31 ifMIB
         (1 ifMIBObjects
           (1 ifXTable
@@ -224,10 +189,6 @@
         )
       )
       (48 ipMIB
-      )
-      (49 tcpMIB
-      )
-      (50 udpMIB
       )
   ))
   (6 snmpV2
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_udp.c BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_udp.c
--- BSNMP_CVS/src/contrib/bsnmp/snmp_mibII/mibII_udp.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmp_mibII/mibII_udp.c	Tue Sep 13 11:21:29 2005
@@ -1,253 +0,0 @@
-/*
- * Copyright (c) 2001-2003
- *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).
- *	All rights reserved.
- *
- * Author: Harti Brandt <harti@freebsd.org>
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Begemot: bsnmp/snmp_mibII/mibII_udp.c,v 1.7 2005/05/23 09:03:42 brandt_h Exp $
- *
- * udp
- */
-#include "mibII.h"
-#include "mibII_oid.h"
-#include <sys/socketvar.h>
-#include <netinet/in_pcb.h>
-#include <netinet/udp.h>
-#include <netinet/ip_var.h>
-#include <netinet/udp_var.h>
-
-struct udp_index {
-	struct asn_oid	index;
-	struct xinpcb	*inp;
-};
-
-static uint64_t udp_tick;
-static struct udpstat udpstat;
-static struct xinpgen *xinpgen;
-static size_t xinpgen_len;
-static u_int udp_total;
-
-static u_int oidnum;
-static struct udp_index *udpoids;
-
-static int
-udp_compare(const void *p1, const void *p2)
-{
-	const struct udp_index *t1 = p1;
-	const struct udp_index *t2 = p2;
-
-	return (asn_compare_oid(&t1->index, &t2->index));
-}
-
-static int
-fetch_udp(void)
-{
-	size_t len;
-	struct xinpgen *ptr;
-	struct xinpcb *inp;
-	struct udp_index *oid;
-	in_addr_t inaddr;
-
-	len = sizeof(udpstat);
-	if (sysctlbyname("net.inet.udp.stats", &udpstat, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.udp.stats: %m");
-		return (-1);
-	}
-	if (len != sizeof(udpstat)) {
-		syslog(LOG_ERR, "net.inet.udp.stats: wrong size");
-		return (-1);
-	}
-
-	udp_tick = get_ticks();
-
-	len = 0;
-	if (sysctlbyname("net.inet.udp.pcblist", NULL, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.udp.pcblist: %m");
-		return (-1);
-	}
-	if (len > xinpgen_len) {
-		if ((ptr = realloc(xinpgen, len)) == NULL) {
-			syslog(LOG_ERR, "%zu: %m", len);
-			return (-1);
-		}
-		xinpgen = ptr;
-		xinpgen_len = len;
-	}
-	if (sysctlbyname("net.inet.udp.pcblist", xinpgen, &len, NULL, 0) == -1) {
-		syslog(LOG_ERR, "net.inet.udp.pcblist: %m");
-		return (-1);
-	}
-
-	udp_total = 0;
-	for (ptr = (struct xinpgen *)(void *)((char *)xinpgen + xinpgen->xig_len);
-	     ptr->xig_len > sizeof(struct xinpgen);
-             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
-		inp = (struct xinpcb *)ptr;
-		if (inp->xi_inp.inp_gencnt > xinpgen->xig_gen ||
-		    (inp->xi_inp.inp_vflag & INP_IPV4) == 0)
-			continue;
-
-		udp_total++;
-	}
-
-	if (oidnum < udp_total) {
-		oid = realloc(udpoids, udp_total * sizeof(udpoids[0]));
-		if (oid == NULL) {
-			free(udpoids);
-			oidnum = 0;
-			return (0);
-		}
-		udpoids = oid;
-		oidnum = udp_total;
-	}
-
-	oid = udpoids;
-	for (ptr = (struct xinpgen *)(void *)((char *)xinpgen + xinpgen->xig_len);
-	     ptr->xig_len > sizeof(struct xinpgen);
-             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
-		inp = (struct xinpcb *)ptr;
-		if (inp->xi_inp.inp_gencnt > xinpgen->xig_gen ||
-		    (inp->xi_inp.inp_vflag & INP_IPV4) == 0)
-			continue;
-		oid->inp = inp;
-		oid->index.len = 5;
-		inaddr = ntohl(inp->xi_inp.inp_laddr.s_addr);
-		oid->index.subs[0] = (inaddr >> 24) & 0xff;
-		oid->index.subs[1] = (inaddr >> 16) & 0xff;
-		oid->index.subs[2] = (inaddr >>  8) & 0xff;
-		oid->index.subs[3] = (inaddr >>  0) & 0xff;
-		oid->index.subs[4] = ntohs(inp->xi_inp.inp_lport);
-		oid++;
-	}
-
-	qsort(udpoids, udp_total, sizeof(udpoids[0]), udp_compare);
-
-	return (0);
-}
-
-int
-op_udp(struct snmp_context *ctx __unused, struct snmp_value *value,
-    u_int sub, u_int iidx __unused, enum snmp_op op)
-{
-	switch (op) {
-
-	  case SNMP_OP_GETNEXT:
-		abort();
-
-	  case SNMP_OP_GET:
-		break;
-
-	  case SNMP_OP_SET:
-		return (SNMP_ERR_NOT_WRITEABLE);
-
-	  case SNMP_OP_ROLLBACK:
-	  case SNMP_OP_COMMIT:
-		abort();
-	}
-
-	if (udp_tick < this_tick)
-		if (fetch_udp() == -1)
-			return (SNMP_ERR_GENERR);
-
-	switch (value->var.subs[sub - 1]) {
-
-	  case LEAF_udpInDatagrams:
-		value->v.uint32 = udpstat.udps_ipackets;
-		break;
-
-	  case LEAF_udpNoPorts:
-		value->v.uint32 = udpstat.udps_noport +
-		    udpstat.udps_noportbcast +
-		    udpstat.udps_noportmcast;
-		break;
-
-	  case LEAF_udpInErrors:
-		value->v.uint32 = udpstat.udps_hdrops +
-		    udpstat.udps_badsum +
-		    udpstat.udps_badlen +
-		    udpstat.udps_fullsock;
-		break;
-
-	  case LEAF_udpOutDatagrams:
-		value->v.uint32 = udpstat.udps_opackets;
-		break;
-	}
-	return (SNMP_ERR_NOERROR);
-}
-
-int
-op_udptable(struct snmp_context *ctx __unused, struct snmp_value *value,
-    u_int sub, u_int iidx __unused, enum snmp_op op)
-{
-	u_int i;
-
-	if (udp_tick < this_tick)
-		if (fetch_udp() == -1)
-			return (SNMP_ERR_GENERR);
-
-	switch (op) {
-
-	  case SNMP_OP_GETNEXT:
-		for (i = 0; i < udp_total; i++)
-			if (index_compare(&value->var, sub, &udpoids[i].index) < 0)
-				break;
-		if (i == udp_total)
-			return (SNMP_ERR_NOSUCHNAME);
-		index_append(&value->var, sub, &udpoids[i].index);
-		break;
-
-	  case SNMP_OP_GET:
-		for (i = 0; i < udp_total; i++)
-			if (index_compare(&value->var, sub, &udpoids[i].index) == 0)
-				break;
-		if (i == udp_total)
-			return (SNMP_ERR_NOSUCHNAME);
-		break;
-
-	  case SNMP_OP_SET:
-		return (SNMP_ERR_NOT_WRITEABLE);
-
-	  case SNMP_OP_ROLLBACK:
-	  case SNMP_OP_COMMIT:
-	  default:
-		abort();
-	}
-
-	switch (value->var.subs[sub - 1]) {
-
-	  case LEAF_udpLocalAddress:
-		value->v.ipaddress[0] = udpoids[i].index.subs[0];
-		value->v.ipaddress[1] = udpoids[i].index.subs[1];
-		value->v.ipaddress[2] = udpoids[i].index.subs[2];
-		value->v.ipaddress[3] = udpoids[i].index.subs[3];
-		break;
-
-	  case LEAF_udpLocalPort:
-		value->v.integer = udpoids[i].index.subs[4];
-		break;
-
-	}
-	return (SNMP_ERR_NOERROR);
-}
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmpd/main.c BSNMP_NEW/src/contrib/bsnmp/snmpd/main.c
--- BSNMP_CVS/src/contrib/bsnmp/snmpd/main.c	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmpd/main.c	Tue Sep 13 11:21:29 2005
@@ -1621,21 +1621,27 @@ tfunc(evContext ctx __unused, void *uap,
 #endif
 {
 	struct timer *tp = uap;
-
-	LIST_REMOVE(tp, link);
+	if (tp->periodic == 0){
+		LIST_REMOVE(tp, link);
+	}
+	
 	tp->func(tp->udata);
-	free(tp);
+	
+	if (tp->periodic == 0){
+		free(tp);
+	}
 }
 
 /*
  * Start a timer
  */
 void *
-timer_start(u_int ticks, void (*func)(void *), void *udata, struct lmodule *mod)
+timer_start(u_int ticks, u_int repeat_ticks, void (*func)(void *), void *udata, struct lmodule *mod)
 {
 	struct timer *tp;
 #ifndef USE_LIBBEGEMOT
 	struct timespec due;
+	struct timespec inter;
 #endif
 
 	if ((tp = malloc(sizeof(struct timer))) == NULL) {
@@ -1646,21 +1652,26 @@ timer_start(u_int ticks, void (*func)(vo
 #ifndef USE_LIBBEGEMOT
 	due = evAddTime(evNowTime(),
 	    evConsTime(ticks / 100, (ticks % 100) * 10000));
+	inter = evAddTime(evNowTime(),
+	    evConsTime(repeat_ticks / 100, (ticks % 100) * 10000));
+	    
 #endif
 
 	tp->udata = udata;
 	tp->owner = mod;
 	tp->func = func;
-
+	tp->periodic = (repeat_ticks == 0 ? 0 : 1); /*for clarity*/
+	
 	LIST_INSERT_HEAD(&timer_list, tp, link);
 
 #ifdef USE_LIBBEGEMOT
-	if ((tp->id = poll_start_timer(ticks * 10, 0, tfunc, tp)) < 0) {
+	if ((tp->id = poll_start_timer( (repeat_ticks == 0 ? ticks * 10 : repeat_ticks *  10), 
+					tp->periodic, tfunc, tp)) < 0) {
 		syslog(LOG_ERR, "cannot set timer: %m");
 		exit(1);
 	}
 #else
-	if (evSetTimer(evctx, tfunc, tp, due, evConsTime(0, 0), &tp->id)
+	if (evSetTimer(evctx, tfunc, tp, due, inter, &tp->id)
 	    == -1) {
 		syslog(LOG_ERR, "cannot set timer: %m");
 		exit(1);
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpd.config BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpd.config
--- BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpd.config	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpd.config	Tue Sep 13 11:21:29 2005
@@ -78,12 +78,24 @@ snmpEnableAuthenTraps = 2
 #
 # Load MIB-2 module
 #
-begemotSnmpdModulePath."mibII"	= "/usr/local/lib/snmp_mibII.so"
+begemotSnmpdModulePath."mibII"	= "/usr/lib/snmp_mibII.so"
+
+
+#
+# Load HOST-RESOURCES-MIB module
+#
+begemotSnmpdModulePath."hostres"  = "/usr/lib/snmp_hostres.so"
+
+#
+# Load TCP-MIB and UDP-MIB module (combined IPv4 & IPv6)
+#
+begemotSnmpdModulePath."ipL4"  = "/usr/lib/snmp_tcp_udp46.so"
+
 
 #
 # Netgraph module
 #
-begemotSnmpdModulePath."netgraph" = "/usr/local/lib/snmp_netgraph.so"
+begemotSnmpdModulePath."netgraph" = "/usr/lib/snmp_netgraph.so"
 
 %netgraph
 begemotNgControlNodeName = "snmpd"
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpd.h BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpd.h
--- BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpd.h	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpd.h	Tue Sep 13 11:21:29 2005
@@ -92,6 +92,8 @@ struct timer {
 	void	*udata;		/* user data */
 	evTimerID id;		/* timer id */
 	struct lmodule *owner;	/* owner of the timer */
+	int	periodic;	/* flag to track periodic timers, 0 for one shot,
+				 1 for periodic timers*/	
 	LIST_ENTRY(timer) link;
 };
 
diff -uNpPr BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpmod.h BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpmod.h
--- BSNMP_CVS/src/contrib/bsnmp/snmpd/snmpmod.h	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/contrib/bsnmp/snmpd/snmpmod.h	Tue Sep 13 11:21:29 2005
@@ -300,7 +300,7 @@ u_int reqid_type(int32_t reqid);
 /*
  * Timers.
  */
-void *timer_start(u_int, void (*)(void *), void *, struct lmodule *);
+void *timer_start(u_int, u_int ,void (*)(void *), void *, struct lmodule *);
 void timer_stop(void *);
 
 /*
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/Makefile BSNMP_NEW/src/usr.sbin/bsnmpd/modules/Makefile
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/Makefile	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/Makefile	Tue Sep 13 11:21:29 2005
@@ -7,9 +7,11 @@ _snmp_atm= snmp_atm
 .endif
 
 SUBDIR=	${_snmp_atm} \
+        snmp_hostres \
 	snmp_mibII \
 	snmp_netgraph \
-	snmp_pf
+	snmp_pf \
+	snmp_tcp_udp46 
 
 INCS=	snmpmod.h
 INCSDIR= ${INCLUDEDIR}/bsnmp
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-MIB.txt BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-MIB.txt
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-MIB.txt	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-MIB.txt	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,1629 @@
+HOST-RESOURCES-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+MODULE-IDENTITY, OBJECT-TYPE, mib-2,
+Integer32, Counter32, Gauge32, TimeTicks  FROM SNMPv2-SMI
+
+TEXTUAL-CONVENTION, DisplayString,
+TruthValue, DateAndTime, AutonomousType   FROM SNMPv2-TC
+
+MODULE-COMPLIANCE, OBJECT-GROUP           FROM SNMPv2-CONF
+
+InterfaceIndexOrZero                      FROM IF-MIB;
+
+hostResourcesMibModule MODULE-IDENTITY
+   LAST-UPDATED "200003060000Z"    -- 6 March 2000
+   ORGANIZATION "IETF Host Resources MIB Working Group"
+   CONTACT-INFO
+       "Steve Waldbusser
+       Postal: Lucent Technologies, Inc.
+               1213 Innsbruck Dr.
+               Sunnyvale, CA 94089
+               USA
+       Phone:  650-318-1251
+       Fax:    650-318-1633
+       Email:  waldbusser@lucent.com
+
+
+
+
+       In addition, the Host Resources MIB mailing list is
+       dedicated to discussion of this MIB. To join the
+       mailing list, send a request message to
+       hostmib-request@andrew.cmu.edu. The mailing list
+       address is hostmib@andrew.cmu.edu."
+
+   DESCRIPTION
+       "This MIB is for use in managing host systems. The term
+       `host' is construed to mean any computer that communicates
+       with other similar computers attached to the internet and
+       that is directly used by one or more human beings. Although
+       this MIB does not necessarily apply to devices whose primary
+       function is communications services (e.g., terminal servers,
+       routers, bridges, monitoring equipment), such relevance is
+       not explicitly precluded.  This MIB instruments attributes
+       common to all internet hosts including, for example, both
+       personal computers and systems that run variants of Unix."
+
+   REVISION "200003060000Z"        -- 6 March 2000
+   DESCRIPTION
+       "Clarifications and bug fixes based on implementation
+       experience.  This revision was also reformatted in the SMIv2
+       format. The revisions made were:
+
+       New RFC document standards:
+          Added Copyright notice, updated introduction to SNMP
+          Framework, updated references section, added reference to
+          RFC 2119, and added a meaningful Security Considerations
+          section.
+
+       New IANA considerations section for registration of new types
+
+       Conversion to new SMIv2 syntax for the following types and
+       macros:
+           Counter32, Integer32, Gauge32, MODULE-IDENTITY,
+           OBJECT-TYPE, TEXTUAL-CONVENTION, OBJECT-IDENTITY,
+           MODULE-COMPLIANCE, OBJECT-GROUP
+
+       Used new Textual Conventions:
+           TruthValue, DateAndTime, AutonomousType,
+           InterfaceIndexOrZero
+
+       Fixed typo in hrPrinterStatus.
+
+       Added missing error bits to hrPrinterDetectedErrorState and
+       clarified confusion resulting from suggested mappings to
+       hrPrinterStatus.
+
+
+
+
+       Clarified that size of objects of type
+       InternationalDisplayString is number of octets, not number
+       of encoded symbols.
+
+       Clarified the use of the following objects based on
+       implementation experience:
+           hrSystemInitialLoadDevice, hrSystemInitialLoadParameters,
+           hrMemorySize, hrStorageSize, hrStorageAllocationFailures,
+           hrDeviceErrors, hrProcessorLoad, hrNetworkIfIndex,
+           hrDiskStorageCapacity, hrSWRunStatus, hrSWRunPerfCPU,
+           and hrSWInstalledDate.
+
+       Clarified implementation technique for hrSWInstalledTable.
+
+       Used new AUGMENTS clause for hrSWRunPerfTable.
+
+       Added Internationalization Considerations section.
+
+This revision published as RFC2790."
+
+   REVISION "9910202200Z"    -- 20 October, 1999
+   DESCRIPTION
+       "The original version of this MIB, published as
+       RFC1514."
+   ::= { hrMIBAdminInfo 1 }
+
+host     OBJECT IDENTIFIER ::= { mib-2 25 }
+
+hrSystem        OBJECT IDENTIFIER ::= { host 1 }
+hrStorage       OBJECT IDENTIFIER ::= { host 2 }
+hrDevice        OBJECT IDENTIFIER ::= { host 3 }
+hrSWRun         OBJECT IDENTIFIER ::= { host 4 }
+hrSWRunPerf     OBJECT IDENTIFIER ::= { host 5 }
+hrSWInstalled   OBJECT IDENTIFIER ::= { host 6 }
+hrMIBAdminInfo  OBJECT IDENTIFIER ::= { host 7 }
+
+-- textual conventions
+
+KBytes ::= TEXTUAL-CONVENTION
+    STATUS current
+    DESCRIPTION
+        "Storage size, expressed in units of 1024 bytes."
+    SYNTAX Integer32 (0..2147483647)
+
+ProductID ::= TEXTUAL-CONVENTION
+    STATUS current
+    DESCRIPTION
+        "This textual convention is intended to identify the
+
+
+
+        manufacturer, model, and version of a specific
+        hardware or software product.  It is suggested that
+        these OBJECT IDENTIFIERs are allocated such that all
+        products from a particular manufacturer are registered
+        under a subtree distinct to that manufacturer.  In
+        addition, all versions of a product should be
+        registered under a subtree distinct to that product.
+        With this strategy, a management station may uniquely
+        determine the manufacturer and/or model of a product
+        whose productID is unknown to the management station.
+        Objects of this type may be useful for inventory
+        purposes or for automatically detecting
+        incompatibilities or version mismatches between
+        various hardware and software components on a system.
+
+        For example, the product ID for the ACME 4860 66MHz
+        clock doubled processor might be:
+        enterprises.acme.acmeProcessors.a4860DX2.MHz66
+
+        A software product might be registered as:
+        enterprises.acme.acmeOperatingSystems.acmeDOS.six(6).one(1)
+        "
+    SYNTAX OBJECT IDENTIFIER
+
+-- unknownProduct will be used for any unknown ProductID
+-- unknownProduct OBJECT IDENTIFIER ::= { 0 0 }
+
+InternationalDisplayString ::= TEXTUAL-CONVENTION
+    STATUS current
+    DESCRIPTION
+        "This data type is used to model textual information
+        in some character set.  A network management station
+        should use a local algorithm to determine which
+        character set is in use and how it should be
+        displayed.  Note that this character set may be
+        encoded with more than one octet per symbol, but will
+        most often be NVT ASCII. When a size clause is
+        specified for an object of this type, the size refers
+        to the length in octets, not the number of symbols."
+    SYNTAX OCTET STRING
+
+-- The Host Resources System Group
+
+hrSystemUptime OBJECT-TYPE
+    SYNTAX     TimeTicks
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+
+
+
+        "The amount of time since this host was last
+        initialized.  Note that this is different from
+        sysUpTime in the SNMPv2-MIB [RFC1907] because
+        sysUpTime is the uptime of the network management
+        portion of the system."
+    ::= { hrSystem 1 }
+
+hrSystemDate OBJECT-TYPE
+    SYNTAX     DateAndTime
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The host's notion of the local date and time of day."
+    ::= { hrSystem 2 }
+
+hrSystemInitialLoadDevice OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The index of the hrDeviceEntry for the device from
+        which this host is configured to load its initial
+        operating system configuration (i.e., which operating
+        system code and/or boot parameters).
+
+        Note that writing to this object just changes the
+        configuration that will be used the next time the
+        operating system is loaded and does not actually cause
+        the reload to occur."
+    ::= { hrSystem 3 }
+
+hrSystemInitialLoadParameters OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE (0..128))
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "This object contains the parameters (e.g. a pathname
+        and parameter) supplied to the load device when
+        requesting the initial operating system configuration
+        from that device.
+
+     Note that writing to this object just changes the
+     configuration that will be used the next time the
+     operating system is loaded and does not actually cause
+     the reload to occur."
+    ::= { hrSystem 4 }
+
+hrSystemNumUsers OBJECT-TYPE
+
+
+
+    SYNTAX     Gauge32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The number of user sessions for which this host is
+        storing state information.  A session is a collection
+        of processes requiring a single act of user
+        authentication and possibly subject to collective job
+        control."
+    ::= { hrSystem 5 }
+
+hrSystemProcesses OBJECT-TYPE
+    SYNTAX     Gauge32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The number of process contexts currently loaded or
+        running on this system."
+    ::= { hrSystem 6 }
+
+hrSystemMaxProcesses OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The maximum number of process contexts this system
+        can support.  If there is no fixed maximum, the value
+        should be zero.  On systems that have a fixed maximum,
+        this object can help diagnose failures that occur when
+        this maximum is reached."
+    ::= { hrSystem 7 }
+
+-- The Host Resources Storage Group
+
+-- Registration point for storage types, for use with hrStorageType.
+-- These are defined in the HOST-RESOURCES-TYPES module.
+hrStorageTypes          OBJECT IDENTIFIER ::= { hrStorage 1 }
+
+hrMemorySize OBJECT-TYPE
+    SYNTAX     KBytes
+    UNITS      "KBytes"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The amount of physical read-write main memory,
+        typically RAM, contained by the host."
+    ::= { hrStorage 2 }
+
+
+
+
+hrStorageTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrStorageEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of logical storage areas on
+        the host.
+
+        An entry shall be placed in the storage table for each
+        logical area of storage that is allocated and has
+        fixed resource limits.  The amount of storage
+        represented in an entity is the amount actually usable
+        by the requesting entity, and excludes loss due to
+        formatting or file system reference information.
+
+        These entries are associated with logical storage
+        areas, as might be seen by an application, rather than
+        physical storage entities which are typically seen by
+        an operating system.  Storage such as tapes and
+        floppies without file systems on them are typically
+        not allocated in chunks by the operating system to
+        requesting applications, and therefore shouldn't
+        appear in this table.  Examples of valid storage for
+        this table include disk partitions, file systems, ram
+        (for some architectures this is further segmented into
+        regular memory, extended memory, and so on), backing
+        store for virtual memory (`swap space').
+
+        This table is intended to be a useful diagnostic for
+        `out of memory' and `out of buffers' types of
+        failures.  In addition, it can be a useful performance
+        monitoring tool for tracking memory, disk, or buffer
+        usage."
+    ::= { hrStorage 3 }
+
+hrStorageEntry OBJECT-TYPE
+    SYNTAX     HrStorageEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one logical storage area on
+        the host.  As an example, an instance of the
+        hrStorageType object might be named hrStorageType.3"
+    INDEX { hrStorageIndex }
+    ::= { hrStorageTable 1 }
+
+HrStorageEntry ::= SEQUENCE {
+        hrStorageIndex               Integer32,
+
+
+
+        hrStorageType                AutonomousType,
+        hrStorageDescr               DisplayString,
+        hrStorageAllocationUnits     Integer32,
+        hrStorageSize                Integer32,
+        hrStorageUsed                Integer32,
+        hrStorageAllocationFailures  Counter32
+    }
+
+hrStorageIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each logical storage area
+        contained by the host."
+    ::= { hrStorageEntry 1 }
+
+hrStorageType OBJECT-TYPE
+    SYNTAX     AutonomousType
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The type of storage represented by this entry."
+    ::= { hrStorageEntry 2 }
+
+hrStorageDescr OBJECT-TYPE
+    SYNTAX     DisplayString
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A description of the type and instance of the storage
+        described by this entry."
+    ::= { hrStorageEntry 3 }
+
+hrStorageAllocationUnits OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    UNITS      "Bytes"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The size, in bytes, of the data objects allocated
+        from this pool.  If this entry is monitoring sectors,
+        blocks, buffers, or packets, for example, this number
+        will commonly be greater than one.  Otherwise this
+        number will typically be one."
+    ::= { hrStorageEntry 4 }
+
+hrStorageSize OBJECT-TYPE
+
+
+
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The size of the storage represented by this entry, in
+        units of hrStorageAllocationUnits. This object is
+        writable to allow remote configuration of the size of
+        the storage area in those cases where such an
+        operation makes sense and is possible on the
+        underlying system. For example, the amount of main
+        memory allocated to a buffer pool might be modified or
+        the amount of disk space allocated to virtual memory
+        might be modified."
+    ::= { hrStorageEntry 5 }
+
+hrStorageUsed OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The amount of the storage represented by this entry
+        that is allocated, in units of
+        hrStorageAllocationUnits."
+    ::= { hrStorageEntry 6 }
+
+hrStorageAllocationFailures OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The number of requests for storage represented by
+        this entry that could not be honored due to not enough
+        storage.  It should be noted that as this object has a
+        SYNTAX of Counter32, that it does not have a defined
+        initial value.  However, it is recommended that this
+        object be initialized to zero, even though management
+        stations must not depend on such an initialization."
+    ::= { hrStorageEntry 7 }
+
+-- The Host Resources Device Group
+--
+-- The device group is useful for identifying and diagnosing the
+-- devices on a system.  The hrDeviceTable contains common
+-- information for any type of device.  In addition, some devices
+-- have device-specific tables for more detailed information.  More
+-- such tables may be defined in the future for other device types.
+
+-- Registration point for device types, for use with hrDeviceType.
+
+
+
+-- These are defined in the HOST-RESOURCES-TYPES module.
+hrDeviceTypes             OBJECT IDENTIFIER ::= { hrDevice 1 }
+
+hrDeviceTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrDeviceEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of devices contained by the
+        host."
+    ::= { hrDevice 2 }
+
+hrDeviceEntry OBJECT-TYPE
+    SYNTAX     HrDeviceEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one device contained by the
+        host.  As an example, an instance of the hrDeviceType
+        object might be named hrDeviceType.3"
+    INDEX { hrDeviceIndex }
+    ::= { hrDeviceTable 1 }
+
+HrDeviceEntry ::= SEQUENCE {
+        hrDeviceIndex           Integer32,
+        hrDeviceType            AutonomousType,
+        hrDeviceDescr           DisplayString,
+        hrDeviceID              ProductID,
+        hrDeviceStatus          INTEGER,
+        hrDeviceErrors          Counter32
+    }
+
+hrDeviceIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each device contained by the host.
+        The value for each device must remain constant at
+        least from one re-initialization of the agent to the
+        next re-initialization."
+    ::= { hrDeviceEntry 1 }
+
+hrDeviceType OBJECT-TYPE
+    SYNTAX     AutonomousType
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+
+
+
+        "An indication of the type of device.
+
+        If this value is
+        `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry
+        exists in the hrProcessorTable which corresponds to
+        this device.
+
+        If this value is
+        `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry
+        exists in the hrNetworkTable which corresponds to this
+        device.
+
+        If this value is
+        `hrDevicePrinter { hrDeviceTypes 5 }', then an entry
+        exists in the hrPrinterTable which corresponds to this
+        device.
+
+        If this value is
+        `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an
+        entry exists in the hrDiskStorageTable which
+        corresponds to this device."
+    ::= { hrDeviceEntry 2 }
+
+hrDeviceDescr OBJECT-TYPE
+    SYNTAX     DisplayString (SIZE (0..64))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A textual description of this device, including the
+        device's manufacturer and revision, and optionally,
+        its serial number."
+    ::= { hrDeviceEntry 3 }
+
+hrDeviceID OBJECT-TYPE
+    SYNTAX     ProductID
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The product ID for this device."
+    ::= { hrDeviceEntry 4 }
+
+hrDeviceStatus OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   unknown(1),
+                   running(2),
+                   warning(3),
+                   testing(4),
+                   down(5)
+
+
+
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The current operational state of the device described
+        by this row of the table.  A value unknown(1)
+        indicates that the current state of the device is
+        unknown.  running(2) indicates that the device is up
+        and running and that no unusual error conditions are
+        known.  The warning(3) state indicates that agent has
+        been informed of an unusual error condition by the
+        operational software (e.g., a disk device driver) but
+        that the device is still 'operational'.  An example
+        would be a high number of soft errors on a disk.  A
+        value of testing(4), indicates that the device is not
+        available for use because it is in the testing state.
+        The state of down(5) is used only when the agent has
+        been informed that the device is not available for any
+        use."
+    ::= { hrDeviceEntry 5 }
+
+hrDeviceErrors OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The number of errors detected on this device.  It
+        should be noted that as this object has a SYNTAX of
+        Counter32, that it does not have a defined initial
+        value.  However, it is recommended that this object be
+        initialized to zero, even though management stations
+        must not depend on such an initialization."
+    ::= { hrDeviceEntry 6 }
+
+hrProcessorTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrProcessorEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of processors contained by the
+        host.
+
+        Note that this table is potentially sparse: a
+        (conceptual) entry exists only if the correspondent
+        value of the hrDeviceType object is
+        `hrDeviceProcessor'."
+    ::= { hrDevice 3 }
+
+
+
+
+hrProcessorEntry OBJECT-TYPE
+    SYNTAX     HrProcessorEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one processor contained by
+        the host.  The hrDeviceIndex in the index represents
+        the entry in the hrDeviceTable that corresponds to the
+        hrProcessorEntry.
+
+        As an example of how objects in this table are named,
+        an instance of the hrProcessorFrwID object might be
+        named hrProcessorFrwID.3"
+    INDEX { hrDeviceIndex }
+    ::= { hrProcessorTable 1 }
+
+HrProcessorEntry ::= SEQUENCE {
+        hrProcessorFrwID            ProductID,
+        hrProcessorLoad             Integer32
+    }
+
+hrProcessorFrwID OBJECT-TYPE
+    SYNTAX     ProductID
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The product ID of the firmware associated with the
+        processor."
+    ::= { hrProcessorEntry 1 }
+
+hrProcessorLoad OBJECT-TYPE
+    SYNTAX     Integer32 (0..100)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The average, over the last minute, of the percentage
+        of time that this processor was not idle.
+        Implementations may approximate this one minute
+        smoothing period if necessary."
+    ::= { hrProcessorEntry 2 }
+
+hrNetworkTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrNetworkEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of network devices contained
+        by the host.
+
+
+
+        Note that this table is potentially sparse: a
+        (conceptual) entry exists only if the correspondent
+        value of the hrDeviceType object is
+        `hrDeviceNetwork'."
+    ::= { hrDevice 4 }
+
+hrNetworkEntry OBJECT-TYPE
+    SYNTAX     HrNetworkEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one network device contained
+        by the host.  The hrDeviceIndex in the index
+        represents the entry in the hrDeviceTable that
+        corresponds to the hrNetworkEntry.
+
+        As an example of how objects in this table are named,
+        an instance of the hrNetworkIfIndex object might be
+        named hrNetworkIfIndex.3"
+    INDEX { hrDeviceIndex }
+    ::= { hrNetworkTable 1 }
+
+HrNetworkEntry ::= SEQUENCE {
+        hrNetworkIfIndex    InterfaceIndexOrZero
+    }
+
+hrNetworkIfIndex OBJECT-TYPE
+    SYNTAX     InterfaceIndexOrZero
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The value of ifIndex which corresponds to this
+        network device. If this device is not represented in
+        the ifTable, then this value shall be zero."
+    ::= { hrNetworkEntry 1 }
+
+hrPrinterTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrPrinterEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of printers local to the host.
+
+        Note that this table is potentially sparse: a
+        (conceptual) entry exists only if the correspondent
+        value of the hrDeviceType object is
+        `hrDevicePrinter'."
+    ::= { hrDevice 5 }
+
+
+
+hrPrinterEntry OBJECT-TYPE
+    SYNTAX     HrPrinterEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one printer local to the
+        host.  The hrDeviceIndex in the index represents the
+        entry in the hrDeviceTable that corresponds to the
+        hrPrinterEntry.
+
+        As an example of how objects in this table are named,
+        an instance of the hrPrinterStatus object might be
+        named hrPrinterStatus.3"
+    INDEX { hrDeviceIndex }
+    ::= { hrPrinterTable 1 }
+
+HrPrinterEntry ::= SEQUENCE {
+        hrPrinterStatus             INTEGER,
+        hrPrinterDetectedErrorState OCTET STRING
+    }
+
+hrPrinterStatus OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   other(1),
+                   unknown(2),
+                   idle(3),
+                   printing(4),
+                   warmup(5)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The current status of this printer device."
+    ::= { hrPrinterEntry 1 }
+
+hrPrinterDetectedErrorState OBJECT-TYPE
+    SYNTAX     OCTET STRING
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "This object represents any error conditions detected
+        by the printer.  The error conditions are encoded as
+        bits in an octet string, with the following
+        definitions:
+
+             Condition         Bit #
+
+             lowPaper              0
+
+
+
+             noPaper               1
+             lowToner              2
+             noToner               3
+             doorOpen              4
+             jammed                5
+             offline               6
+             serviceRequested      7
+             inputTrayMissing      8
+             outputTrayMissing     9
+             markerSupplyMissing  10
+             outputNearFull       11
+             outputFull           12
+             inputTrayEmpty       13
+             overduePreventMaint  14
+
+        Bits are numbered starting with the most significant
+        bit of the first byte being bit 0, the least
+        significant bit of the first byte being bit 7, the
+        most significant bit of the second byte being bit 8,
+        and so on.  A one bit encodes that the condition was
+        detected, while a zero bit encodes that the condition
+        was not detected.
+
+        This object is useful for alerting an operator to
+        specific warning or error conditions that may occur,
+        especially those requiring human intervention."
+    ::= { hrPrinterEntry 2 }
+
+hrDiskStorageTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrDiskStorageEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of long-term storage devices
+        contained by the host.  In particular, disk devices
+        accessed remotely over a network are not included
+        here.
+
+        Note that this table is potentially sparse: a
+        (conceptual) entry exists only if the correspondent
+        value of the hrDeviceType object is
+        `hrDeviceDiskStorage'."
+    ::= { hrDevice 6 }
+
+hrDiskStorageEntry OBJECT-TYPE
+    SYNTAX     HrDiskStorageEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+
+
+
+    DESCRIPTION
+        "A (conceptual) entry for one long-term storage device
+        contained by the host.  The hrDeviceIndex in the index
+        represents the entry in the hrDeviceTable that
+        corresponds to the hrDiskStorageEntry. As an example,
+        an instance of the hrDiskStorageCapacity object might
+        be named hrDiskStorageCapacity.3"
+    INDEX { hrDeviceIndex }
+    ::= { hrDiskStorageTable 1 }
+
+HrDiskStorageEntry ::= SEQUENCE {
+        hrDiskStorageAccess         INTEGER,
+        hrDiskStorageMedia          INTEGER,
+        hrDiskStorageRemoveble      TruthValue,
+        hrDiskStorageCapacity       KBytes
+    }
+
+hrDiskStorageAccess OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   readWrite(1),
+                   readOnly(2)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "An indication if this long-term storage device is
+        readable and writable or only readable.  This should
+        reflect the media type, any write-protect mechanism,
+        and any device configuration that affects the entire
+        device."
+    ::= { hrDiskStorageEntry 1 }
+
+hrDiskStorageMedia OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   other(1),
+                   unknown(2),
+                   hardDisk(3),
+                   floppyDisk(4),
+                   opticalDiskROM(5),
+                   opticalDiskWORM(6),     -- Write Once Read Many
+                   opticalDiskRW(7),
+                   ramDisk(8)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "An indication of the type of media used in this long-
+        term storage device."
+
+
+
+    ::= { hrDiskStorageEntry 2 }
+
+hrDiskStorageRemoveble OBJECT-TYPE
+    SYNTAX     TruthValue
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "Denotes whether or not the disk media may be removed
+        from the drive."
+    ::= { hrDiskStorageEntry 3 }
+
+hrDiskStorageCapacity OBJECT-TYPE
+    SYNTAX     KBytes
+    UNITS      "KBytes"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The total size for this long-term storage device. If
+        the media is removable and is currently removed, this
+        value should be zero."
+    ::= { hrDiskStorageEntry 4 }
+
+hrPartitionTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrPartitionEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of partitions for long-term
+        storage devices contained by the host.  In particular,
+        partitions accessed remotely over a network are not
+        included here."
+    ::= { hrDevice 7 }
+
+hrPartitionEntry OBJECT-TYPE
+    SYNTAX     HrPartitionEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one partition.  The
+        hrDeviceIndex in the index represents the entry in the
+        hrDeviceTable that corresponds to the
+        hrPartitionEntry.
+
+        As an example of how objects in this table are named,
+        an instance of the hrPartitionSize object might be
+        named hrPartitionSize.3.1"
+    INDEX { hrDeviceIndex, hrPartitionIndex }
+    ::= { hrPartitionTable 1 }
+
+
+
+HrPartitionEntry ::= SEQUENCE {
+        hrPartitionIndex                Integer32,
+        hrPartitionLabel                InternationalDisplayString,
+        hrPartitionID                   OCTET STRING,
+        hrPartitionSize                 KBytes,
+        hrPartitionFSIndex              Integer32
+    }
+
+hrPartitionIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each partition on this long-term
+        storage device.  The value for each long-term storage
+        device must remain constant at least from one re-
+        initialization of the agent to the next re-
+        initialization."
+    ::= { hrPartitionEntry 1 }
+
+hrPartitionLabel OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE (0..128))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A textual description of this partition."
+    ::= { hrPartitionEntry 2 }
+
+hrPartitionID OBJECT-TYPE
+    SYNTAX     OCTET STRING
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A descriptor which uniquely represents this partition
+        to the responsible operating system.  On some systems,
+        this might take on a binary representation."
+    ::= { hrPartitionEntry 3 }
+
+hrPartitionSize OBJECT-TYPE
+    SYNTAX     KBytes
+    UNITS      "KBytes"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The size of this partition."
+    ::= { hrPartitionEntry 4 }
+
+hrPartitionFSIndex OBJECT-TYPE
+
+
+
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The index of the file system mounted on this
+        partition.  If no file system is mounted on this
+        partition, then this value shall be zero.  Note that
+        multiple partitions may point to one file system,
+        denoting that that file system resides on those
+        partitions.  Multiple file systems may not reside on
+        one partition."
+    ::= { hrPartitionEntry 5 }
+
+-- The File System Table
+
+-- Registration point for popular File System types,
+-- for use with hrFSType. These are defined in the
+-- HOST-RESOURCES-TYPES module.
+hrFSTypes               OBJECT IDENTIFIER ::= { hrDevice 9 }
+
+hrFSTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrFSEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of file systems local to this
+        host or remotely mounted from a file server.  File
+        systems that are in only one user's environment on a
+        multi-user system will not be included in this table."
+    ::= { hrDevice 8 }
+
+hrFSEntry OBJECT-TYPE
+    SYNTAX     HrFSEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one file system local to
+        this host or remotely mounted from a file server.
+        File systems that are in only one user's environment
+        on a multi-user system will not be included in this
+        table.
+
+        As an example of how objects in this table are named,
+        an instance of the hrFSMountPoint object might be
+        named hrFSMountPoint.3"
+    INDEX { hrFSIndex }
+    ::= { hrFSTable 1 }
+
+
+
+
+HrFSEntry ::= SEQUENCE {
+        hrFSIndex                   Integer32,
+        hrFSMountPoint              InternationalDisplayString,
+        hrFSRemoteMountPoint        InternationalDisplayString,
+        hrFSType                    AutonomousType,
+        hrFSAccess                  INTEGER,
+        hrFSBootable                TruthValue,
+        hrFSStorageIndex            Integer32,
+        hrFSLastFullBackupDate      DateAndTime,
+        hrFSLastPartialBackupDate   DateAndTime
+    }
+
+hrFSIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each file system local to this
+        host.  The value for each file system must remain
+        constant at least from one re-initialization of the
+        agent to the next re-initialization."
+    ::= { hrFSEntry 1 }
+
+hrFSMountPoint OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE(0..128))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The path name of the root of this file system."
+    ::= { hrFSEntry 2 }
+
+hrFSRemoteMountPoint OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE(0..128))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A description of the name and/or address of the
+        server that this file system is mounted from.  This
+        may also include parameters such as the mount point on
+        the remote file system.  If this is not a remote file
+        system, this string should have a length of zero."
+    ::= { hrFSEntry 3 }
+
+hrFSType OBJECT-TYPE
+    SYNTAX     AutonomousType
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+
+
+
+        "The value of this object identifies the type of this
+        file system."
+    ::= { hrFSEntry 4 }
+
+hrFSAccess OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   readWrite(1),
+                   readOnly(2)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "An indication if this file system is logically
+        configured by the operating system to be readable and
+        writable or only readable.  This does not represent
+        any local access-control policy, except one that is
+        applied to the file system as a whole."
+    ::= { hrFSEntry 5 }
+
+hrFSBootable OBJECT-TYPE
+    SYNTAX     TruthValue
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A flag indicating whether this file system is
+        bootable."
+    ::= { hrFSEntry 6 }
+
+hrFSStorageIndex OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The index of the hrStorageEntry that represents
+        information about this file system.  If there is no
+        such information available, then this value shall be
+        zero.  The relevant storage entry will be useful in
+        tracking the percent usage of this file system and
+        diagnosing errors that may occur when it runs out of
+        space."
+    ::= { hrFSEntry 7 }
+
+hrFSLastFullBackupDate OBJECT-TYPE
+    SYNTAX     DateAndTime
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The last date at which this complete file system was
+
+
+
+        copied to another storage device for backup.  This
+        information is useful for ensuring that backups are
+        being performed regularly.
+
+        If this information is not known, then this variable
+        shall have the value corresponding to January 1, year
+        0000, 00:00:00.0, which is encoded as
+        (hex)'00 00 01 01 00 00 00 00'."
+    ::= { hrFSEntry 8 }
+
+hrFSLastPartialBackupDate OBJECT-TYPE
+    SYNTAX     DateAndTime
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The last date at which a portion of this file system
+        was copied to another storage device for backup.  This
+        information is useful for ensuring that backups are
+        being performed regularly.
+
+        If this information is not known, then this variable
+        shall have the value corresponding to January 1, year
+        0000, 00:00:00.0, which is encoded as
+        (hex)'00 00 01 01 00 00 00 00'."
+    ::= { hrFSEntry 9 }
+
+-- The Host Resources Running Software Group
+--
+-- The hrSWRunTable contains an entry for each distinct piece of
+-- software that is running or loaded into physical or virtual
+-- memory in preparation for running.  This includes the host's
+-- operating system, device drivers, and applications.
+
+hrSWOSIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The value of the hrSWRunIndex for the hrSWRunEntry
+        that represents the primary operating system running
+        on this host.  This object is useful for quickly and
+        uniquely identifying that primary operating system."
+    ::= { hrSWRun 1 }
+
+hrSWRunTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrSWRunEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+
+
+
+    DESCRIPTION
+        "The (conceptual) table of software running on the
+        host."
+    ::= { hrSWRun 2 }
+
+hrSWRunEntry OBJECT-TYPE
+    SYNTAX     HrSWRunEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for one piece of software
+        running on the host Note that because the installed
+        software table only contains information for software
+        stored locally on this host, not every piece of
+        running software will be found in the installed
+        software table.  This is true of software that was
+        loaded and run from a non-local source, such as a
+        network-mounted file system.
+
+        As an example of how objects in this table are named,
+        an instance of the hrSWRunName object might be named
+        hrSWRunName.1287"
+    INDEX { hrSWRunIndex }
+    ::= { hrSWRunTable 1 }
+
+HrSWRunEntry ::= SEQUENCE {
+        hrSWRunIndex       Integer32,
+        hrSWRunName        InternationalDisplayString,
+        hrSWRunID          ProductID,
+        hrSWRunPath        InternationalDisplayString,
+        hrSWRunParameters  InternationalDisplayString,
+        hrSWRunType        INTEGER,
+        hrSWRunStatus      INTEGER
+    }
+
+hrSWRunIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each piece of software running on
+        the host.  Wherever possible, this should be the
+        system's native, unique identification number."
+    ::= { hrSWRunEntry 1 }
+
+hrSWRunName OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE (0..64))
+    MAX-ACCESS read-only
+
+
+
+    STATUS     current
+    DESCRIPTION
+        "A textual description of this running piece of
+        software, including the manufacturer, revision,  and
+        the name by which it is commonly known.  If this
+        software was installed locally, this should be the
+        same string as used in the corresponding
+        hrSWInstalledName."
+    ::= { hrSWRunEntry 2 }
+
+hrSWRunID OBJECT-TYPE
+    SYNTAX     ProductID
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The product ID of this running piece of software."
+    ::= { hrSWRunEntry 3 }
+
+hrSWRunPath OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE(0..128))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A description of the location on long-term storage
+        (e.g. a disk drive) from which this software was
+        loaded."
+    ::= { hrSWRunEntry 4 }
+
+hrSWRunParameters OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE(0..128))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A description of the parameters supplied to this
+        software when it was initially loaded."
+    ::= { hrSWRunEntry 5 }
+
+hrSWRunType OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   unknown(1),
+                   operatingSystem(2),
+                   deviceDriver(3),
+                   application(4)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The type of this software."
+
+
+
+    ::= { hrSWRunEntry 6 }
+
+hrSWRunStatus OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   running(1),
+                   runnable(2),    -- waiting for resource
+                                   -- (i.e., CPU, memory, IO)
+                   notRunnable(3), -- loaded but waiting for event
+                   invalid(4)      -- not loaded
+               }
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+        "The status of this running piece of software.
+        Setting this value to invalid(4) shall cause this
+        software to stop running and to be unloaded. Sets to
+        other values are not valid."
+    ::= { hrSWRunEntry 7 }
+
+-- The Host Resources Running Software Performance Group
+--
+-- The hrSWRunPerfTable contains an entry corresponding to
+-- each entry in the hrSWRunTable.
+
+hrSWRunPerfTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrSWRunPerfEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of running software
+        performance metrics."
+    ::= { hrSWRunPerf 1 }
+
+hrSWRunPerfEntry OBJECT-TYPE
+    SYNTAX     HrSWRunPerfEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry containing software performance
+        metrics.  As an example, an instance of the
+        hrSWRunPerfCPU object might be named
+        hrSWRunPerfCPU.1287"
+    AUGMENTS { hrSWRunEntry }  -- This table augments information in
+                               -- the hrSWRunTable.
+    ::= { hrSWRunPerfTable 1 }
+
+HrSWRunPerfEntry ::= SEQUENCE {
+        hrSWRunPerfCPU          Integer32,
+
+
+
+        hrSWRunPerfMem          KBytes
+}
+
+hrSWRunPerfCPU OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The number of centi-seconds of the total system's CPU
+        resources consumed by this process.  Note that on a
+        multi-processor system, this value may increment by
+        more than one centi-second in one centi-second of real
+        (wall clock) time."
+    ::= { hrSWRunPerfEntry 1 }
+
+hrSWRunPerfMem OBJECT-TYPE
+    SYNTAX     KBytes
+    UNITS      "KBytes"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The total amount of real system memory allocated to
+        this process."
+    ::= { hrSWRunPerfEntry 2 }
+
+-- The Host Resources Installed Software Group
+--
+-- The hrSWInstalledTable contains an entry for each piece
+-- of software installed in long-term storage (e.g. a disk
+-- drive) locally on this host.  Note that this does not
+-- include software loadable remotely from a network
+-- server.
+--
+-- Different implementations may track software in varying
+-- ways. For example, while some implementations may track
+-- executable files as distinct pieces of software, other
+-- implementations may use other strategies such as keeping
+-- track of software "packages" (e.g., related groups of files)
+-- or keeping track of system or application "patches".
+--
+-- This table is useful for identifying and inventorying
+-- software on a host and for diagnosing incompatibility
+-- and version mismatch problems between various pieces
+-- of hardware and software.
+
+hrSWInstalledLastChange OBJECT-TYPE
+    SYNTAX     TimeTicks
+    MAX-ACCESS read-only
+
+
+
+    STATUS     current
+    DESCRIPTION
+        "The value of sysUpTime when an entry in the
+        hrSWInstalledTable was last added, renamed, or
+        deleted.  Because this table is likely to contain many
+        entries, polling of this object allows a management
+        station to determine when re-downloading of the table
+        might be useful."
+    ::= { hrSWInstalled 1 }
+
+hrSWInstalledLastUpdateTime OBJECT-TYPE
+    SYNTAX     TimeTicks
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The value of sysUpTime when the hrSWInstalledTable
+        was last completely updated.  Because caching of this
+        data will be a popular implementation strategy,
+        retrieval of this object allows a management station
+        to obtain a guarantee that no data in this table is
+        older than the indicated time."
+    ::= { hrSWInstalled 2 }
+
+hrSWInstalledTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF HrSWInstalledEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "The (conceptual) table of software installed on this
+        host."
+    ::= { hrSWInstalled 3 }
+
+hrSWInstalledEntry OBJECT-TYPE
+    SYNTAX     HrSWInstalledEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+        "A (conceptual) entry for a piece of software
+        installed on this host.
+
+        As an example of how objects in this table are named,
+        an instance of the hrSWInstalledName object might be
+        named hrSWInstalledName.96"
+    INDEX { hrSWInstalledIndex }
+    ::= { hrSWInstalledTable 1 }
+
+HrSWInstalledEntry ::= SEQUENCE {
+        hrSWInstalledIndex       Integer32,
+
+
+
+        hrSWInstalledName        InternationalDisplayString,
+        hrSWInstalledID          ProductID,
+        hrSWInstalledType        INTEGER,
+        hrSWInstalledDate        DateAndTime
+}
+
+hrSWInstalledIndex OBJECT-TYPE
+    SYNTAX     Integer32 (1..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A unique value for each piece of software installed
+        on the host.  This value shall be in the range from 1
+        to the number of pieces of software installed on the
+        host."
+    ::= { hrSWInstalledEntry 1 }
+
+hrSWInstalledName OBJECT-TYPE
+    SYNTAX     InternationalDisplayString (SIZE (0..64))
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "A textual description of this installed piece of
+        software, including the manufacturer, revision, the
+        name by which it is commonly known, and optionally,
+        its serial number."
+    ::= { hrSWInstalledEntry 2 }
+
+hrSWInstalledID OBJECT-TYPE
+    SYNTAX     ProductID
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The product ID of this installed piece of software."
+    ::= { hrSWInstalledEntry 3 }
+
+hrSWInstalledType OBJECT-TYPE
+    SYNTAX     INTEGER {
+                   unknown(1),
+                   operatingSystem(2),
+                   deviceDriver(3),
+                   application(4)
+               }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The type of this software."
+    ::= { hrSWInstalledEntry 4 }
+
+
+
+hrSWInstalledDate OBJECT-TYPE
+    SYNTAX     DateAndTime
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+        "The last-modification date of this application as it
+        would appear in a directory listing.
+
+        If this information is not known, then this variable
+        shall have the value corresponding to January 1, year
+        0000, 00:00:00.0, which is encoded as
+        (hex)'00 00 01 01 00 00 00 00'."
+    ::= { hrSWInstalledEntry 5 }
+
+-- Conformance information
+
+hrMIBCompliances OBJECT IDENTIFIER ::= { hrMIBAdminInfo 2 }
+hrMIBGroups      OBJECT IDENTIFIER ::= { hrMIBAdminInfo 3 }
+
+-- Compliance Statements
+hrMIBCompliance MODULE-COMPLIANCE
+    STATUS current
+    DESCRIPTION
+        "The requirements for conformance to the Host Resources MIB."
+    MODULE -- this module
+      MANDATORY-GROUPS { hrSystemGroup, hrStorageGroup,
+                         hrDeviceGroup }
+
+      OBJECT hrSystemDate
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      OBJECT hrSystemInitialLoadDevice
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      OBJECT hrSystemInitialLoadParameters
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      OBJECT hrStorageSize
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+
+
+
+      OBJECT hrFSLastFullBackupDate
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      OBJECT hrFSLastPartialBackupDate
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      GROUP hrSWRunGroup
+          DESCRIPTION
+              "The Running Software Group. Implementation
+              of this group is mandatory only when the
+              hrSWRunPerfGroup is implemented."
+
+      OBJECT hrSWRunStatus
+          MIN-ACCESS read-only
+          DESCRIPTION
+              "Write access is not required."
+
+      GROUP hrSWRunPerfGroup
+          DESCRIPTION
+              "The Running Software Performance Group.
+              Implementation of this group is at the discretion
+              of the implementor."
+
+      GROUP hrSWInstalledGroup
+          DESCRIPTION
+              "The Installed Software Group.
+              Implementation of this group is at the discretion
+              of the implementor."
+
+    ::= { hrMIBCompliances 1 }
+
+    hrSystemGroup OBJECT-GROUP
+        OBJECTS {
+            hrSystemUptime, hrSystemDate,
+            hrSystemInitialLoadDevice,
+            hrSystemInitialLoadParameters,
+            hrSystemNumUsers, hrSystemProcesses,
+            hrSystemMaxProcesses
+        }
+        STATUS current
+        DESCRIPTION
+            "The Host Resources System Group."
+        ::= { hrMIBGroups 1 }
+
+
+
+
+    hrStorageGroup OBJECT-GROUP
+        OBJECTS {
+            hrMemorySize, hrStorageIndex, hrStorageType,
+            hrStorageDescr, hrStorageAllocationUnits,
+            hrStorageSize, hrStorageUsed,
+            hrStorageAllocationFailures
+        }
+        STATUS current
+        DESCRIPTION
+            "The Host Resources Storage Group."
+        ::= { hrMIBGroups 2 }
+
+    hrDeviceGroup OBJECT-GROUP
+        OBJECTS {
+            hrDeviceIndex, hrDeviceType, hrDeviceDescr,
+            hrDeviceID, hrDeviceStatus, hrDeviceErrors,
+            hrProcessorFrwID, hrProcessorLoad,
+            hrNetworkIfIndex, hrPrinterStatus,
+            hrPrinterDetectedErrorState,
+            hrDiskStorageAccess, hrDiskStorageMedia,
+            hrDiskStorageRemoveble, hrDiskStorageCapacity,
+            hrPartitionIndex, hrPartitionLabel,
+            hrPartitionID, hrPartitionSize,
+            hrPartitionFSIndex, hrFSIndex, hrFSMountPoint,
+            hrFSRemoteMountPoint, hrFSType, hrFSAccess,
+            hrFSBootable, hrFSStorageIndex,
+            hrFSLastFullBackupDate,
+            hrFSLastPartialBackupDate
+        }
+        STATUS current
+        DESCRIPTION
+            "The Host Resources Device Group."
+        ::= { hrMIBGroups 3 }
+
+    hrSWRunGroup OBJECT-GROUP
+        OBJECTS {
+            hrSWOSIndex, hrSWRunIndex, hrSWRunName,
+            hrSWRunID, hrSWRunPath, hrSWRunParameters,
+            hrSWRunType, hrSWRunStatus
+        }
+        STATUS current
+        DESCRIPTION
+            "The Host Resources Running Software Group."
+        ::= { hrMIBGroups 4 }
+
+    hrSWRunPerfGroup OBJECT-GROUP
+        OBJECTS { hrSWRunPerfCPU, hrSWRunPerfMem }
+        STATUS current
+
+
+
+        DESCRIPTION
+            "The Host Resources Running Software
+            Performance Group."
+        ::= { hrMIBGroups 5 }
+
+    hrSWInstalledGroup OBJECT-GROUP
+        OBJECTS {
+            hrSWInstalledLastChange,
+            hrSWInstalledLastUpdateTime,
+            hrSWInstalledIndex, hrSWInstalledName,
+            hrSWInstalledID, hrSWInstalledType,
+            hrSWInstalledDate
+        }
+        STATUS current
+        DESCRIPTION
+            "The Host Resources Installed Software Group."
+        ::= { hrMIBGroups 6 }
+
+END
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-TYPES.txt BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-TYPES.txt
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-TYPES.txt	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/HOST-RESOURCES-TYPES.txt	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,407 @@
+HOST-RESOURCES-TYPES DEFINITIONS ::= BEGIN
+
+IMPORTS
+  MODULE-IDENTITY, OBJECT-IDENTITY        FROM SNMPv2-SMI
+  hrMIBAdminInfo, hrStorage, hrDevice     FROM HOST-RESOURCES-MIB;
+
+hostResourcesTypesModule MODULE-IDENTITY
+  LAST-UPDATED "200003060000Z"    -- 6 March, 2000
+  ORGANIZATION "IETF Host Resources MIB Working Group"
+  CONTACT-INFO
+      "Steve Waldbusser
+      Postal: Lucent Technologies, Inc.
+              1213 Innsbruck Dr.
+              Sunnyvale, CA 94089
+              USA
+      Phone: 650-318-1251
+      Fax:   650-318-1633
+      Email: waldbusser@ins.com
+
+      In addition, the Host Resources MIB mailing list is dedicated
+      to discussion of this MIB. To join the mailing list, send a
+      request message to hostmib-request@andrew.cmu.edu. The mailing
+      list address is hostmib@andrew.cmu.edu."
+  DESCRIPTION
+      "This MIB module registers type definitions for
+      storage types, device types, and file system types.
+
+
+      After the initial revision, this module will be
+      maintained by IANA."
+  REVISION "200003060000Z"    -- 6 March 2000
+  DESCRIPTION
+      "The original version of this module, published as RFC
+      2790."
+  ::= { hrMIBAdminInfo 4 }
+
+-- Registrations for some storage types, for use with hrStorageType
+hrStorageTypes          OBJECT IDENTIFIER ::= { hrStorage 1 }
+
+hrStorageOther OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used when no other defined
+        type is appropriate."
+    ::= { hrStorageTypes 1 }
+
+hrStorageRam OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for RAM."
+    ::= { hrStorageTypes 2 }
+
+hrStorageVirtualMemory OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for virtual memory,
+        temporary storage of swapped or paged memory."
+    ::= { hrStorageTypes 3 }
+
+hrStorageFixedDisk OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for non-removable
+        rigid rotating magnetic storage devices."
+    ::= { hrStorageTypes 4 }
+
+hrStorageRemovableDisk OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for removable rigid
+        rotating magnetic storage devices."
+    ::= { hrStorageTypes 5 }
+
+hrStorageFloppyDisk OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+
+
+
+        "The storage type identifier used for non-rigid rotating
+        magnetic storage devices."
+    ::= { hrStorageTypes 6 }
+
+hrStorageCompactDisc OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for read-only rotating
+        optical storage devices."
+    ::= { hrStorageTypes 7 }
+
+hrStorageRamDisk OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for a file system that
+        is stored in RAM."
+    ::= { hrStorageTypes 8 }
+
+hrStorageFlashMemory OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for flash memory."
+    ::= { hrStorageTypes 9 }
+
+hrStorageNetworkDisk OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The storage type identifier used for a
+        networked file system."
+    ::= { hrStorageTypes 10 }
+
+-- Registrations for some device types, for use with hrDeviceType
+hrDeviceTypes             OBJECT IDENTIFIER ::= { hrDevice 1 }
+
+hrDeviceOther OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used when no other defined
+        type is appropriate."
+    ::= { hrDeviceTypes 1 }
+
+hrDeviceUnknown OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used when the device type is
+        unknown."
+    ::= { hrDeviceTypes 2 }
+
+
+
+
+hrDeviceProcessor OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a CPU."
+    ::= { hrDeviceTypes 3 }
+
+hrDeviceNetwork OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a network interface."
+    ::= { hrDeviceTypes 4 }
+
+hrDevicePrinter OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a printer."
+    ::= { hrDeviceTypes 5 }
+
+hrDeviceDiskStorage OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a disk drive."
+    ::= { hrDeviceTypes 6 }
+
+hrDeviceVideo OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a video device."
+    ::= { hrDeviceTypes 10 }
+
+hrDeviceAudio OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for an audio device."
+    ::= { hrDeviceTypes 11 }
+
+hrDeviceCoprocessor OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a co-processor."
+    ::= { hrDeviceTypes 12 }
+
+hrDeviceKeyboard OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a keyboard device."
+    ::= { hrDeviceTypes 13 }
+
+
+
+
+hrDeviceModem OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a modem."
+    ::= { hrDeviceTypes 14 }
+
+hrDeviceParallelPort OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a parallel port."
+    ::= { hrDeviceTypes 15 }
+
+hrDevicePointing OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a pointing device
+        (e.g., a mouse)."
+    ::= { hrDeviceTypes 16 }
+
+hrDeviceSerialPort OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a serial port."
+    ::= { hrDeviceTypes 17 }
+
+hrDeviceTape OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a tape storage device."
+    ::= { hrDeviceTypes 18 }
+
+hrDeviceClock OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a clock device."
+    ::= { hrDeviceTypes 19 }
+
+hrDeviceVolatileMemory OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a volatile memory
+        storage device."
+    ::= { hrDeviceTypes 20 }
+
+hrDeviceNonVolatileMemory OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION
+        "The device type identifier used for a non-volatile memory
+
+
+
+        storage device."
+    ::= { hrDeviceTypes 21 }
+
+-- Registrations for some popular File System types,
+-- for use with hrFSType.
+hrFSTypes               OBJECT IDENTIFIER ::= { hrDevice 9 }
+
+hrFSOther OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used when no other
+        defined type is appropriate."
+    ::= { hrFSTypes 1 }
+
+hrFSUnknown OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used when the type of
+        file system is unknown."
+    ::= { hrFSTypes 2 }
+
+hrFSBerkeleyFFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Berkeley Fast File System."
+    ::= { hrFSTypes 3 }
+
+hrFSSys5FS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        System V File System."
+    ::= { hrFSTypes 4 }
+
+hrFSFat OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for
+        DOS's FAT file system."
+    ::= { hrFSTypes 5 }
+
+hrFSHPFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for OS/2's
+        High Performance File System."
+    ::= { hrFSTypes 6 }
+
+
+
+hrFSHFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Macintosh Hierarchical File System."
+    ::= { hrFSTypes 7 }
+
+hrFSMFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Macintosh File System."
+    ::= { hrFSTypes 8 }
+
+hrFSNTFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Windows NT File System."
+    ::= { hrFSTypes 9 }
+
+hrFSVNode OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        VNode File System."
+    ::= { hrFSTypes 10 }
+
+hrFSJournaled OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Journaled File System."
+    ::= { hrFSTypes 11 }
+
+hrFSiso9660 OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        ISO 9660 File System for CD's."
+    ::= { hrFSTypes 12 }
+
+hrFSRockRidge OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        RockRidge File System for CD's."
+    ::= { hrFSTypes 13 }
+
+
+
+hrFSNFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        NFS File System."
+    ::= { hrFSTypes 14 }
+
+hrFSNetware OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Netware File System."
+    ::= { hrFSTypes 15 }
+
+hrFSAFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Andrew File System."
+    ::= { hrFSTypes 16 }
+
+hrFSDFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        OSF DCE Distributed File System."
+    ::= { hrFSTypes 17 }
+
+hrFSAppleshare OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        AppleShare File System."
+    ::= { hrFSTypes 18 }
+
+hrFSRFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        RFS File System."
+    ::= { hrFSTypes 19 }
+
+hrFSDGCFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Data General DGCFS."
+    ::= { hrFSTypes 20 }
+
+
+
+hrFSBFS OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        SVR4 Boot File System."
+    ::= { hrFSTypes 21 }
+
+hrFSFAT32 OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Windows FAT32 File System."
+    ::= { hrFSTypes 22 }
+
+hrFSLinuxExt2 OBJECT-IDENTITY
+    STATUS  current
+    DESCRIPTION
+        "The file system type identifier used for the
+        Linux EXT2 File System."
+    ::= { hrFSTypes 23 }
+
+END
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/Makefile BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/Makefile
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/Makefile	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/Makefile	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,67 @@
+# 
+# Copyright (c) 2005 The FreeBSD Project 
+# All rights reserved.
+# Author: Victor Cruceru <soc-victor@freebsd.org>
+#
+# Redistribution of this software and documentation and use in source and
+# binary forms, with or without modification, are permitted provided that
+# the following conditions are met:
+#
+# 1. Redistributions of source code or documentation must retain the above
+#    copyright notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+CONTRIB=${.CURDIR}/../../../../contrib/bsnmp
+
+MOD=	hostres
+SRCS=	hostres_snmp.c \
+	hostres_scalars.c \
+	hostres_storage_tbl.c \
+	hostres_fs_tbl.c \
+	hostres_swrun_tbl.c\
+	hostres_swrunperf_tbl.c \
+	hostres_device_tbl.c \
+	hostres_processor_tbl.c \
+	hostres_diskstorage_tbl.c \
+	hostres_partition_tbl.c \
+	hostres_network_tbl.c \
+	hostres_swinstalled_tbl.c \
+	hostres_printer_tbl.c	
+	
+WARNS?=	3
+#Not having NDEBUG defined will enable assertions and a lot of output on stderr
+CFLAGS+=	-DNDEBUG
+XSYM=	host hrStorageOther hrStorageRam hrStorageVirtualMemory \
+	hrStorageFixedDisk hrStorageRemovableDisk hrStorageFloppyDisk \
+	hrStorageCompactDisc hrStorageRamDisk hrStorageFlashMemory \
+	hrStorageNetworkDisk hrDeviceOther hrDeviceUnknown \
+	hrDeviceProcessor hrDeviceNetwork hrDevicePrinter \
+	hrDeviceDiskStorage hrDeviceVideo hrDeviceAudio \
+	hrDeviceCoprocessor hrDeviceKeyboard hrDeviceModem \
+	hrDeviceParallelPort hrDevicePointing \
+	hrDeviceSerialPort hrDeviceTape hrDeviceClock \
+	hrDeviceVolatileMemory hrDeviceNonVolatileMemory \
+	hrFSOther hrFSUnknown hrFSBerkeleyFFS hrFSSys5FS hrFSFat\
+	hrFSHPFS hrFSHFS hrFSMFS hrFSNTFS hrFSVNode hrFSJournaled \
+	hrFSiso9660 hrFSRockRidge hrFSNFS hrFSNetware hrFSAFS hrFSDFS \
+	hrFSAppleshare hrFSRFS hrFSDGCFS hrFSBFS hrFSFAT32 hrFSLinuxExt2
+	
+DEFS=	${MOD}_tree.def
+BMIBS=	HOST-RESOURCES-MIB.txt HOST-RESOURCES-TYPES.txt
+LDADD=	-lkvm -ldevinfo -lm -ldisk
+.include <bsd.lib.mk>
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_device_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_device_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_device_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_device_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,546 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB: hrDeviceTable implementation for SNMPd.
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <syslog.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <err.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <errno.h>
+
+/*some prototypes*/
+int hr_device_collector(struct devinfo_dev *dev, void *arg); 
+
+void
+hrDeviceTblEntry_delete_v( struct hrDeviceTblEntry* entry );
+
+struct hrDeviceTblEntry *
+hrDeviceTblEntry_find_by_index(int32_t idx);
+
+/*some constant variables*/
+static 
+const struct asn_oid OIDX_hrDeviceProcessor_c = OIDX_hrDeviceProcessor;	
+
+static 
+const struct asn_oid OIDX_hrDeviceOther_c = OIDX_hrDeviceOther;
+
+static
+struct hrDeviceTblEntry* 
+hrDeviceTblEntry_create( const struct devinfo_dev *dev_p) {
+	struct 
+	hrDeviceTblEntry	*entry;
+	struct 
+	deviceNameMapEntry 	*map = NULL;
+
+	
+	assert(dev_p->dd_name != NULL);
+	assert(dev_p->dd_location != NULL);
+	if (dev_p->dd_name == NULL && dev_p->dd_location == NULL) {
+		return (NULL);
+	}
+	
+	assert((dev_p->dd_name[0] != 0) || (dev_p->dd_location[0] != 0));
+
+	if (dev_p->dd_name[0] == 0 && dev_p->dd_location[0] == 0) {
+		return (NULL);	
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrDeviceTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (strcmp((const char *)map->name_key, 
+		    	(const char *)dev_p->dd_name) == 0 && 
+		    strcmp((const char *)map->location_key, 
+		    	(const char *)dev_p->dd_location) == 0) {
+			
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrDevice_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrDeviceTable index wrap", __func__ );
+			errx(1, "hrDeviceTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrDeviceTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrDevice_index ++;
+		
+		memset(&map->name_key[0], 0, sizeof(map->name_key));
+		
+		strncpy( (char*)map->name_key, 
+			(const char *)dev_p->dd_name, 
+			sizeof(map->name_key) - 1);
+		
+		memset(&map->location_key[0], 0, sizeof(map->location_key));
+		strncpy((char*)map->location_key, 
+			dev_p->dd_location, 
+			sizeof(map->location_key) - 1);
+
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.device_name_map, map, link);
+		HR_DPRINTF((stderr, "%s at %s  added into hrDeviceMap at index=%d\n ",
+				dev_p->dd_name, 
+				dev_p->dd_location, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s at %s  exists in hrDeviceMap index=%d\n ",
+				dev_p->dd_name, 
+				dev_p->dd_location, map->hrIndex));
+
+	}
+	
+	entry->index = map->hrIndex;
+	memset(&entry->name[0], 0, sizeof(entry->name));
+	strncpy((char*)entry->name, 
+		dev_p->dd_name, 
+		sizeof(entry->name) - 1);
+		
+	memset(&entry->location[0], 0, sizeof(entry->location));
+	strncpy((char*)entry->location, 
+		dev_p->dd_location, 
+		sizeof(entry->location) - 1);
+			
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_device_tbl);
+	
+	return entry;
+	
+}
+
+
+void
+hrDeviceTblEntry_delete_v( struct hrDeviceTblEntry* entry ) {
+	struct deviceNameMapEntry  *map;
+	assert(entry != NULL);
+	
+
+		
+	TAILQ_REMOVE(&hrState_g.hr_device_tbl, entry, link);	
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (map->entry_p == entry) {
+			map->entry_p = NULL;
+			break;
+		}
+	free(entry);
+}
+
+static
+struct hrDeviceTblEntry*
+hrDeviceTblEntry_find_by_dev(const struct devinfo_dev *dev_p) {
+	struct deviceNameMapEntry  *map;
+	assert(dev_p != NULL);
+		
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (strcmp((const char*)map->name_key, 
+			(const char*)dev_p->dd_name) == 0 && 
+		    strcmp((const char*)map->location_key, 
+		    	(const char*)dev_p->dd_location) == 0) {
+			
+		    	return (map->entry_p);
+		}
+	return (NULL);
+}
+
+
+struct hrDeviceTblEntry *
+hrDeviceTblEntry_find_by_index(int32_t idx) {
+
+	struct hrDeviceTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_device_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+static
+void hrDevice_getType_v(struct devinfo_dev *dev_p, struct asn_oid *out_type_p) {
+	
+	assert(dev_p != NULL);
+	assert(out_type_p != NULL);
+	if(dev_p == NULL)
+		return;
+		
+	if (strncmp(dev_p->dd_name, "cpu", strlen("cpu")) == 0 && 
+	    strstr(dev_p->dd_location, ".CPU") != NULL) {
+		*out_type_p = OIDX_hrDeviceProcessor_c;
+		return;
+	} 	
+	
+	*out_type_p = OIDX_hrDeviceOther_c; /*FIX ME*/
+}
+
+static
+enum DeviceStatus 
+hrDevice_getStatus(struct devinfo_dev *dev) {
+	assert(dev != NULL);
+	switch (dev->dd_state) {
+		case DIS_ALIVE:			/* probe succeeded */
+		case DIS_NOTPRESENT:		/* not probed or probe failed */
+			return (DS_DOWN);
+		case DIS_ATTACHED:		/* attach method called */
+		case DIS_BUSY:			/* device is open */	
+			return (DS_RUNNING);
+		default:
+			return (DS_UNKNOWN);	
+	}
+}
+
+int
+hr_device_collector(struct devinfo_dev *dev, void *arg) {
+	struct hrDeviceTblEntry *entry =  NULL;
+	if (dev->dd_name[0] !='\0' || dev->dd_location[0] != '\0') {  
+		HR_DPRINTF((stderr, " %s: ANALYZING dev %s at %s\n ", 
+			__func__,
+			dev->dd_name,
+			dev->dd_location));
+		
+		entry = hrDeviceTblEntry_find_by_dev(dev);
+		if (entry == NULL) {
+			entry = hrDeviceTblEntry_create(dev);
+		} 
+		assert(entry != NULL);
+		if (entry != NULL) {
+			entry->flags |= HR_DEVICE_FOUND;
+			
+			hrDevice_getType_v(dev,&entry->type);
+			
+			memset(entry->descr, 0, sizeof(entry->descr));
+			if (dev->dd_name[0] != '\0') {
+				(void)snprintf((char*)entry->descr, 
+					sizeof(entry->descr) - 1,"%s: %s", 
+					dev->dd_name, dev->dd_desc);
+			} else {
+				(void)snprintf((char*)entry->descr, 
+					sizeof(entry->descr) - 1,"unknown at %s", 
+					dev->dd_location);
+			
+			}	
+			
+			entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+			
+			entry->status = (u_int)hrDevice_getStatus(dev);
+			
+			entry->errors = 0; /*FIX ME*/
+		}
+
+	} else {
+		syslog(LOG_ERR, 
+			"hrDeviceTable: SKIPPED unknown device at location %s", 
+			dev->dd_location );
+	}
+	return(devinfo_foreach_device_child(dev, hr_device_collector, arg));	
+}
+
+static
+void hrDevice_OS_get_devices_v(void) {
+
+	if (hrState_g.dev_root == NULL) {
+		syslog(LOG_ERR, "hrDeviceTable: not inited? ");
+		return;
+	}
+	if (devinfo_foreach_device_child(hrState_g.dev_root, hr_device_collector, (void *)0)) {
+		syslog(LOG_ERR, "hrDeviceTable: devinfo_foreach_device_child failed ");
+		return;
+	}
+}
+
+void init_hrDevice_tbl_v(void) {
+	refresh_hrDevice_tbl_v();
+		
+}
+
+/*
+ * Finalization routine for hrDeviceTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrDevice_tbl_v(void) {
+	struct deviceNameMapEntry  *n1, *n2;
+	devinfo_free();	
+	
+     	n1 = STAILQ_FIRST(&hrState_g.device_name_map);
+     	while (n1 != NULL) {
+             n2 = STAILQ_NEXT(n1, link);
+	     if(n1->entry_p != NULL){
+	     	TAILQ_REMOVE(&hrState_g.hr_device_tbl, n1->entry_p, link);
+             	free( n1->entry_p );
+		n1->entry_p = NULL;
+	     }
+	     free(n1);
+             n1 = n2;
+     	}
+     	STAILQ_INIT(&hrState_g.device_name_map);
+	
+}
+
+/*
+ * Refresh routine for hrDeviceTable
+ * Usable for polling the system for any changes.
+ */
+void refresh_hrDevice_tbl_v(void) {
+
+	struct hrDeviceTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if ( hrState_g.devd_sock < 0 && this_tick <= hrState_g.hr_device_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	if ( hrState_g.dev_root != NULL ) {
+		syslog(LOG_ERR,"hrDeviceTable: attempt to re-initialization of devinfo.");
+		return;
+	}
+	if (devinfo_init() != 0) {
+		syslog(LOG_ERR,"hrDeviceTable: devinfo_init failed: %m");
+		return;
+	
+	}
+	hrState_g.dev_root = devinfo_handle_to_device(DEVINFO_ROOT_DEVICE);
+	
+	if (hrState_g.dev_root == NULL) {
+		syslog(LOG_ERR,"hrDeviceTable: can't get the root device: %m. Most likely you need to upgrade libdevinfo!");
+		return;
+	}
+
+		
+	/*mark each entry as missing*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_device_tbl, link) {
+		entry->flags &= ~HR_DEVICE_FOUND;
+	}
+	
+	hrDevice_OS_get_devices_v();
+
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_device_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		/*
+		 * If HR_DEVICE_IMMUTABLE bit is set then this means that
+		 * this entry was not detected by the above hrDevice_OS_get_devices_v()
+		 * call. So we are not deleting it there.
+		 */
+		if (!(entry->flags & HR_DEVICE_FOUND) && !(entry->flags & HR_DEVICE_IMMUTABLE) )
+			hrDeviceTblEntry_delete_v(entry);
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_device_tick = this_tick;			
+			
+	hrState_g.hrDevice_tbl_age = time(NULL);	
+	
+	
+	devinfo_free();		
+	hrState_g.dev_root =  NULL;
+
+	/*
+	 *  Force a refresh for the hrDiskStorageTable
+	 */					
+	refresh_DiskStorage_tbl_v(); 
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+
+}
+
+
+int create_devd_socket(void) {
+	static const char devd_pipe_name[]="/var/run/devd.pipe";
+	int d_sock = -1;
+ 	struct sockaddr_un devd_addr;
+ 
+ 	bzero(&devd_addr, sizeof(struct sockaddr_un));
+ 
+ 	if ((d_sock = socket(PF_LOCAL, SOCK_STREAM, 0)) < 0) {
+ 		syslog(LOG_ERR,"Failed to create the socket for %s: %m", devd_pipe_name);
+ 		return (-1);
+ 	}
+ 
+ 	devd_addr.sun_family = PF_LOCAL;
+	
+ 	(void)strlcpy(devd_addr.sun_path, 
+		devd_pipe_name, 
+		sizeof(devd_addr.sun_path) - 1);
+ 
+ 	if (connect(d_sock, (struct sockaddr *)&devd_addr, 
+ 	    sizeof(struct sockaddr_un)) == -1) {
+ 		syslog(LOG_ERR,"Failed to connect the socket for %s: %m", devd_pipe_name);
+ 		if (close(d_sock) < 0 ){
+ 			syslog(LOG_ERR,"Failed to close the socket for %s: %m", devd_pipe_name);
+ 		}
+		return (-1);
+ 	}
+ 
+ 	return d_sock;
+}
+
+void devd_socket_callback(int fd , void* arg __unused) {
+	char buf[512];
+	int read_len = -1;
+	assert(fd == hrState_g.devd_sock);
+	HR_DPRINTF((stderr, "__hrDeviceTable__ %s: called\n ", __func__));
+	read_len = read(fd, buf, sizeof(buf) - 1);
+	if (read_len < 0) {
+		if(errno == EBADF){
+			hrState_g.devd_sock = -1;
+			if (hrState_g.devd_fd != NULL) {
+				fd_deselect(hrState_g.devd_fd);
+				hrState_g.devd_fd = NULL;
+			}			
+			syslog(LOG_ERR,"Closing devd_fd, revert to devinfo polling");
+		}
+		
+	} else if (read_len == 0) {
+		syslog(LOG_ERR,"zero bytes read from devd pipe....closing socket! ");
+		if (close(hrState_g.devd_sock) < 0 ){
+ 			syslog(LOG_ERR,"Failed to close the devd socket: %m");
+ 		}
+		hrState_g.devd_sock = -1;
+		if (hrState_g.devd_fd != NULL) {
+				fd_deselect(hrState_g.devd_fd);
+				hrState_g.devd_fd = NULL;
+		}			
+		syslog(LOG_ERR,"Closing devd_fd, revert to devinfo polling");
+		
+
+	} else {
+		switch(buf[0]){
+			case '+':
+			case '-':
+			case '?':
+				refresh_hrDevice_tbl_v();
+				return;
+			default:
+				syslog(LOG_ERR,"unknown message read from devd socket");
+			
+		}
+	}
+}
+
+/*
+ * This is the implementation for a generated (by a SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrDeviceTable
+ */
+int op_hrDeviceTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrDeviceTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+
+/*
+	refresh entries here?!	
+*/
+	if ( hrState_g.devd_sock < 0 && 
+	     (time(NULL) - hrState_g.hrDevice_tbl_age) > HR_DEVICE_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "__hrDeviceTable__ %s: need refresh\n ", __func__));
+		refresh_hrDevice_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_device_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrDeviceTblEntry_find_by_index(value->var.subs[sub]))
+			 == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrDeviceIndex:
+		value->v.integer = entry->index;
+		break;
+	  case LEAF_hrDeviceType:
+	  	value->v.oid = entry->type;
+	  	break;	
+	  case LEAF_hrDeviceDescr:
+	  	ret = string_get(value, entry->descr, -1);
+	  	break;	
+	  case 	LEAF_hrDeviceID:
+	  	value->v.oid = entry->id;
+	  	break;
+	  case LEAF_hrDeviceStatus:
+	  	value->v.integer = entry->status;
+	  	break;	
+	  case LEAF_hrDeviceErrors:
+	  	value->v.uint32 = entry->errors;
+		break;
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
+ 
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_diskstorage_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_diskstorage_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_diskstorage_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_diskstorage_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,878 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for the hrDiskStorageTable
+ */
+ 
+ 
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <libdisk.h>
+#include <assert.h>	
+#include <err.h>
+#include <sys/sysctl.h>
+#include <sys/ata.h>
+#include <errno.h>
+#include <sys/disk.h>
+#include <sys/mdioctl.h>
+#include <paths.h>
+
+
+/*some constant variables*/
+static 
+const struct asn_oid OIDX_hrDeviceDiskStorage_c = OIDX_hrDeviceDiskStorage;
+
+extern
+struct hrDeviceTblEntry *
+hrDeviceTblEntry_find_by_index(int32_t idx);
+
+
+extern
+void
+hrDeviceTblEntry_delete_v( struct hrDeviceTblEntry* entry );
+
+extern 
+void 
+Partition_tbl_pre_refresh_v(void);
+
+extern 
+void 
+Partition_tbl_post_refresh_v(void);
+
+void 
+handleDiskStorage(int32_t ds_index, const char* disk_dev_name);
+
+struct hrDeviceTblEntry*
+hrDeviceTblEntry_find_by_name(const char *dev_name);
+
+static
+struct hrDiskStorageTblEntry* 
+hrDiskStorageEntry_create( const struct hrDeviceTblEntry* devEntry) {
+	struct 
+	hrDiskStorageTblEntry	*entry = NULL;
+
+	assert(devEntry != NULL);
+	if (devEntry == NULL) {
+		return NULL;
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrDiskStorageTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	entry->index = devEntry->index;
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_disk_storage_tbl);
+	return entry;
+
+}
+
+static
+void
+hrDiskStorageEntry_delete_v( struct hrDiskStorageTblEntry* entry ) {
+	assert(entry != NULL);
+	if (entry == NULL) {
+		return;
+	}
+	TAILQ_REMOVE(&hrState_g.hr_disk_storage_tbl, entry, link);	
+	free(entry);
+}
+
+
+static
+struct hrDiskStorageTblEntry *
+hrDiskStorageTblEntry_find_by_index(int32_t idx) {
+
+	struct hrDiskStorageTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_disk_storage_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+static
+struct hrDeviceTblEntry* 
+hrDeviceTblEntry_create( const char* dev_name) {
+	struct 
+	hrDeviceTblEntry	*entry;
+	struct 
+	deviceNameMapEntry 	*map = NULL;
+
+	
+	assert(dev_name != NULL);
+
+	if (dev_name == NULL) {
+		return (NULL);
+	}
+	
+	if (dev_name[0] == '\0') {
+		return (NULL);	
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrDiskStorageTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (strcmp((const char*)map->name_key, dev_name) == 0) {
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrDevice_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrDeviceTable index wrap", __func__ );
+			errx(1, "hrDeviceTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrStorageTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrDevice_index ++;
+		
+		memset(&map->name_key[0], 0, sizeof(map->name_key));
+		strncpy((char*)map->name_key, dev_name, sizeof(map->name_key) - 1);
+		
+		memset(&map->location_key[0], 0, sizeof(map->location_key));
+		(void)snprintf((char *)map->location_key, 
+			sizeof(map->location_key) - 1, 
+			"%s%s", _PATH_DEV, dev_name);
+
+
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.device_name_map, map, link);
+		HR_DPRINTF((stderr, "%s at %s  added into hrDeviceMap at index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s at %s  exists in hrDeviceMap index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+
+	}
+	
+	entry->index = map->hrIndex;
+	memset(&entry->name[0], 0, sizeof(entry->name));
+	strncpy((char *)entry->name, dev_name, sizeof(entry->name) - 1);
+		
+	memset(&entry->location[0], 0, sizeof(entry->location));
+	(void)snprintf((char *)entry->location, 
+		sizeof(entry->location) - 1, 
+		"%s%s", _PATH_DEV, dev_name);
+					
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_device_tbl);
+	
+	return entry;
+	
+}
+
+ 
+
+struct hrDeviceTblEntry*
+hrDeviceTblEntry_find_by_name(const char *dev_name) {
+	struct deviceNameMapEntry  *map;
+	assert(dev_name != NULL);
+		
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (strcmp((char *)map->name_key, dev_name) == 0 ) {
+		    	return (map->entry_p);
+		}
+	return (NULL);
+}
+
+
+static 
+void hrDiskStorage_queryDisk(struct hrDiskStorageTblEntry *entry){
+	char dev_path[128] = "";
+	int fd = -1;
+	if (entry == NULL) {
+		return;
+	}
+	if( entry->dev_name[0] == '\0' ) {
+		return;
+	}
+	(void)snprintf(dev_path, sizeof(dev_path) - 1, 
+		"%s%s", _PATH_DEV, entry->dev_name);
+	entry->capacity = 0;
+	HR_DPRINTF((stderr,"OPENING device %s\n",dev_path));
+	fd = open(dev_path, O_RDONLY|O_NONBLOCK);
+	if ( fd < 0 ) {
+		HR_DPRINTF((stderr,"OPEN device %s failed: %d (%s)\n",
+			dev_path, 
+			errno, 
+			strerror(errno)));
+		goto QUERY_DONE;
+	} else {
+		off_t	mediasize = 0;
+		if (ioctl(fd, DIOCGMEDIASIZE, &mediasize) < 0) {
+			HR_DPRINTF((stderr,"DIOCGMEDIASIZE for device %s failed: %d (%s)\n",
+				dev_path, 
+				errno, 
+				strerror(errno)));
+			goto QUERY_DONE;
+		}
+		mediasize = mediasize / 1024;
+		entry->capacity = (mediasize > (off_t)INT_MAX ? INT_MAX : mediasize);
+		if (entry->media == (int32_t)DSM_HARDDISK) {
+			/*this silly libdisk crashes if a empty cdrom device
+			is oppened*/
+			handleDiskStorage(entry->index, (const char* )entry->dev_name);
+		}
+	}
+QUERY_DONE:
+	if (fd > 0) {
+		close(fd);
+	}
+	
+	
+			
+	
+}
+static 
+void 
+hrDiskStorage_OS_get_ATA_disks_v(void) {
+	struct hrDeviceTblEntry *entry = NULL;
+	struct hrDiskStorageTblEntry *disk_entry = NULL;
+
+/*
+ * Remove the pre 6 vesrion if not needed
+ */
+#if __FreeBSD_version < 600000 
+
+	struct ata_cmd iocmd;
+	int  maxunit, unit, i;
+	if ( hrState_g.ata_fd < 0 ){
+		return;
+	}
+	
+	iocmd.cmd = ATAGMAXCHANNEL;
+	if (ioctl(hrState_g.ata_fd, IOCATA, &iocmd) < 0) {
+		syslog(LOG_ERR, "ioctl(ATAGMAXCHANNEL) failed: %m");
+		goto ATA_DONE;
+	}		
+	maxunit = iocmd.u.maxchan;
+	for (unit = 0; unit < maxunit; unit++) {
+		struct ata_cmd u_iocmd;
+
+		memset(&u_iocmd, 0, sizeof(struct ata_cmd));
+		u_iocmd.channel = unit;
+		u_iocmd.device = -1;
+		u_iocmd.cmd = ATAGPARM;
+		if (ioctl(hrState_g.ata_fd, IOCATA, &u_iocmd) < 0) {
+			syslog(LOG_ERR, "ioctl(IOCATA) failed: %m");
+			continue;
+		}	
+
+		for(i=0; i<=1; i++) {
+		        if (!u_iocmd.u.param.type[i]) {
+				continue;
+			}
+			/*first check if this disk is in hrDeiveTable*/
+			entry = hrDeviceTblEntry_find_by_name(u_iocmd.u.param.name[i]);
+			if (entry == NULL) {
+				HR_DPRINTF((stderr,
+				"hrDiskStorageTable: ATA disk %s not in hrDeviceTable\n",
+				u_iocmd.u.param.name[i] ));
+				entry =  hrDeviceTblEntry_create(u_iocmd.u.param.name[i]);
+				assert(entry != NULL);
+				if (entry == NULL) {
+					continue;
+				}	
+
+				entry->type = OIDX_hrDeviceDiskStorage_c;
+				entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+				entry->status = (int32_t)DS_RUNNING;
+				entry->errors = 0; /*FIX ME*/
+				(void)snprintf((char *)entry->descr, sizeof(entry->descr) - 1, 
+					"%s: <%s, ser. %s> ",
+					u_iocmd.u.param.name[i],
+					u_iocmd.u.param.params[i].model,
+					u_iocmd.u.param.params[i].serial);
+				
+			}else{
+				HR_DPRINTF((stderr,
+				"hrDiskStorageTable; ATA disk %s already in hrDeviceTable\n",
+				u_iocmd.u.param.name[i] ));
+			}
+			entry->flags |= HR_DEVICE_IMMUTABLE;
+			entry->flags |= HR_DEVICE_FOUND;
+						
+			/*Then check hrDiskStorage table for this device*/
+			disk_entry = hrDiskStorageTblEntry_find_by_index(entry->index);
+			if (disk_entry == NULL) {
+				disk_entry = hrDiskStorageEntry_create(entry);
+				assert(disk_entry != NULL);
+				if (disk_entry == NULL) {
+					continue;
+				}
+				disk_entry->access = (int32_t)DS_READ_WRITE;
+				
+				memset(&disk_entry->dev_name[0], 0, 
+					sizeof(disk_entry->dev_name));
+					
+				strncpy((char*)disk_entry->dev_name, 
+					u_iocmd.u.param.name[i], 
+					sizeof(disk_entry->dev_name)-1);
+			
+				if (strncmp((const char*)disk_entry->dev_name, 
+					"ad", strlen("ad")) == 0) {
+					disk_entry->media = (int32_t)DSM_HARDDISK;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				} else if (strncmp((const char*)disk_entry->dev_name, 
+					"ar", strlen("ar")) == 0) {
+					disk_entry->media = (int32_t)DSM_OTHER;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				} else if (strncmp((const char*)disk_entry->dev_name, 
+					"acd", strlen("acd")) == 0) {
+					disk_entry->media = (int32_t)DSM_OPTICALDISKROM;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else if (strncmp((const char*)disk_entry->dev_name, 
+					"afd", strlen("afd")) == 0) {
+					disk_entry->media = (int32_t)DSM_FLOPPYDISK;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else if (strncmp((const char*)disk_entry->dev_name, 
+					"ast", strlen("ast")) == 0) {
+					disk_entry->media = (int32_t)DSM_OTHER;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else {
+					disk_entry->media = (int32_t)DSM_UNKNOWN;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				}
+				
+			}
+			disk_entry->flags |= HR_DISKSTORAGE_FOUND; 
+			disk_entry->flags |= HR_DISKSTORAGE_ATA;
+			
+			hrDiskStorage_queryDisk(disk_entry);
+			disk_entry->r_tick = this_tick;
+		}
+	}				
+ATA_DONE:
+	return;
+#else
+/*
+ * This the post 6 version: it is here to stay
+ */
+
+	int  maxunit, unit, i;
+	if ( hrState_g.ata_fd < 0 ){
+		return;
+	}
+	
+	
+	if (ioctl(hrState_g.ata_fd, IOCATAGMAXCHANNEL, &maxunit) < 0) {
+		syslog(LOG_ERR, "ioctl(IOCATAGMAXCHANNEL) failed: %m");
+		goto ATA_DONE;
+	}		
+
+	for (unit = 0; unit < maxunit; unit++) {
+		struct ata_ioc_devices devices;
+		memset(&devices, 0, sizeof(devices));
+		
+		devices.channel = unit;
+
+
+		if (ioctl(hrState_g.ata_fd, IOCATADEVICES, &devices) < 0) {
+			HR_DPRINTF((stderr, "ioctl(IOCATADEVICES) failed: %s\n", strerror(errno)));
+			continue;
+		}	
+
+		for(i=0; i<=1; i++) {
+		        if (*devices.name[i] == 0) {
+				continue;
+			}
+			/*first check if this disk is in hrDeiveTable*/
+			entry = hrDeviceTblEntry_find_by_name(devices.name[i]);
+			if (entry == NULL) {
+				HR_DPRINTF((stderr,
+				"hrDiskStorageTable: ATA disk %s not in hrDeviceTable\n",
+				devices.name[i] ));
+				entry =  hrDeviceTblEntry_create(devices.name[i]);
+				assert(entry != NULL);
+				if (entry == NULL) {
+					continue;
+				}	
+
+				entry->type = OIDX_hrDeviceDiskStorage_c;
+				entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+				entry->status = (int32_t)DS_RUNNING;
+				entry->errors = 0; /*FIX ME*/
+				snprintf(entry->descr, sizeof(entry->descr) - 1, 
+					"%s: <%s, ser. %s> ",
+					devices.name[i],
+					devices.params[i].model,
+					devices.params[i].serial);
+				
+			}else{
+				HR_DPRINTF((stderr,
+				"hrDiskStorageTable; ATA disk %s already in hrDeviceTable\n",
+				devices.name[i] ));
+			}
+			entry->flags |= HR_DEVICE_IMMUTABLE;
+			entry->flags |= HR_DEVICE_FOUND;
+						
+			/*Then check hrDiskStorage table for this device*/
+			disk_entry = hrDiskStorageTblEntry_find_by_index(entry->index);
+			if (disk_entry == NULL) {
+				disk_entry = hrDiskStorageEntry_create(entry);
+				assert(disk_entry != NULL);
+				if (disk_entry == NULL) {
+					continue;
+				}
+				disk_entry->access = DS_READ_WRITE;
+				memset(&disk_entry->dev_name[0], 0, 
+					sizeof(disk_entry->dev_name));
+				strncpy(disk_entry->dev_name, 
+					devices.name[i], 
+					sizeof(disk_entry->dev_name)-1);
+			
+				if (strncmp(disk_entry->dev_name, "ad", strlen("ad")) == 0) {
+					disk_entry->media = (int32_t)DSM_HARDDISK;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				} else if (strncmp(disk_entry->dev_name, "ar", strlen("ar")) == 0) {
+					disk_entry->media = (int32_t)DSM_OTHER;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				} else if (strncmp(disk_entry->dev_name, "acd", strlen("acd")) == 0) {
+					disk_entry->media = (int32_t)DSM_OPTICALDISKROM;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else if (strncmp(disk_entry->dev_name, "afd", strlen("afd")) == 0) {
+					disk_entry->media = (int32_t)DSM_FLOPPYDISK;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else if (strncmp(disk_entry->dev_name, "ast", strlen("ast")) == 0) {
+					disk_entry->media = (int32_t)DSM_OTHER;
+					disk_entry->removable = (int32_t)SNMP_TRUE;
+				} else {
+					disk_entry->media = (int32_t)DSM_UNKNOWN;
+					disk_entry->removable = (int32_t)SNMP_FALSE;
+				}
+				
+			}
+			disk_entry->flags |= HR_DISKSTORAGE_FOUND; 
+			disk_entry->flags |= HR_DISKSTORAGE_ATA;
+			
+			hrDiskStorage_queryDisk(disk_entry);
+			disk_entry->r_tick = this_tick;
+		}
+	}				
+ATA_DONE:
+	return;
+
+#endif /* __FreeBSD_version < 600000 */
+}	
+
+static 
+void 
+hrDiskStorage_OS_get_MD_disks_v(void) {
+	struct hrDeviceTblEntry *entry = NULL;
+	struct hrDiskStorageTblEntry *disk_entry = NULL;
+
+	struct md_ioctl mdio;
+	int  unit = 0;
+
+	
+	if ( hrState_g.md_fd < 0 ){
+		return;
+	}
+	memset(&mdio, 0, sizeof(mdio));
+	mdio.md_version = MDIOVERSION;
+	mdio.md_options = MD_AUTOUNIT;
+	
+	if (ioctl( hrState_g.md_fd, MDIOCLIST, &mdio) < 0) {
+		syslog(LOG_ERR, "ioctl(/dev/%s) failed: %m", MDCTL_NAME);
+		return;
+	}	
+	for (unit = 0; unit < mdio.md_pad[0] && unit < MDNPAD - 1; unit++) {
+		struct md_ioctl u_mdio;
+		char mddev[64] = "";
+		
+		(void)snprintf(mddev, sizeof(mddev) - 1, "%s%d", 
+			MD_NAME, mdio.md_pad[unit + 1]);
+
+
+		memset(&u_mdio, 0, sizeof(u_mdio));
+		u_mdio.md_version = MDIOVERSION;
+		u_mdio.md_unit = mdio.md_pad[unit + 1];
+
+		if (ioctl( hrState_g.md_fd, MDIOCQUERY, &u_mdio) < 0) {
+			syslog(LOG_ERR, "ioctl(/dev/%s, MDIOCQUERY) [%s] failed: %m", MDCTL_NAME, mddev);
+			continue;
+		}
+
+
+		/*first check if this disk is in hrDeiveTable*/
+		entry = hrDeviceTblEntry_find_by_name(mddev);
+		if (entry == NULL) {
+			HR_DPRINTF((stderr,
+			 "hrDiskStorageTable; MD %s not in hrDeviceTable\n",
+			  mddev ));
+			entry =  hrDeviceTblEntry_create(mddev);
+			assert(entry != NULL);
+			if (entry == NULL) {
+				continue;
+			}	
+
+			entry->type = OIDX_hrDeviceDiskStorage_c;
+			entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+			entry->status = (int32_t)DS_RUNNING;
+			entry->errors = 0; /*FIX ME*/
+			(void)snprintf((char*)entry->descr, sizeof(entry->descr) - 1, 
+				"%s: Memory Disk ",
+				 mddev);
+			
+		}else{
+			HR_DPRINTF((stderr,
+			"hrDiskStorageTable; MD %s already in hrDeviceTable\n",
+			mddev ));
+		}
+		entry->flags |= HR_DEVICE_IMMUTABLE;
+		entry->flags |= HR_DEVICE_FOUND;
+					
+		/*Then check hrDiskStorage table for this device*/
+		disk_entry = hrDiskStorageTblEntry_find_by_index(entry->index);
+		if (disk_entry == NULL) {
+			disk_entry = hrDiskStorageEntry_create(entry);
+			assert(disk_entry != NULL);
+			if (disk_entry == NULL) {
+				continue;
+			}
+			if ((u_mdio.md_options & MD_READONLY) == MD_READONLY) {
+				disk_entry->access = (int32_t)DS_READ_ONLY;
+			} else {
+				disk_entry->access = (int32_t)DS_READ_WRITE;
+			}
+			memset(&disk_entry->dev_name[0], 
+				0, sizeof(disk_entry->dev_name));
+			strncpy((char *)disk_entry->dev_name, 
+				mddev, sizeof(disk_entry->dev_name)-1);
+
+			disk_entry->media = (int32_t)DSM_RAMDISK;
+			disk_entry->removable = (int32_t)SNMP_FALSE;
+		
+			
+		}
+		disk_entry->flags |= HR_DISKSTORAGE_FOUND; 
+		disk_entry->flags |= HR_DISKSTORAGE_MD;
+/*
+ * Remove the pre 6 vesrion if not needed
+ */
+#if __FreeBSD_version < 600000 		
+		disk_entry->capacity = u_mdio.md_size / 2;
+#else		
+		disk_entry->capacity = u_mdio.md_mediasize / 1024;
+#endif /*__FreeBSD_version < 600000 */		
+		disk_entry->r_tick = this_tick;
+		
+	}				
+}	
+
+				
+static
+void
+hrDiskStorage_OS_get_disks_v(void) {
+	size_t disk_cnt = 0;
+	struct hrDeviceTblEntry *entry = NULL;
+	struct hrDiskStorageTblEntry *disk_entry = NULL;
+
+	size_t disk_list_len = 0;
+
+	if (sysctlbyname("kern.disks", NULL, &disk_list_len, NULL, 0) < 0) {
+		syslog(LOG_ERR, "hrDiskStorageTable:sysctl #1 kern.disks failed: %m");
+		return;
+	}
+
+	if (disk_list_len == 0)
+		return;
+
+	if (hrState_g.disk_list_len != disk_list_len + 1 || hrState_g.disk_list ==  NULL) {
+		hrState_g.disk_list_len = disk_list_len + 1;
+		hrState_g.disk_list = 
+		 (char *)reallocf(hrState_g.disk_list, hrState_g.disk_list_len);
+	}
+	if (hrState_g.disk_list == NULL) {
+		syslog(LOG_ERR, "hrDiskStorageTable: reallocf failed: %m");	
+		hrState_g.disk_list_len = 0;
+		return;
+	}
+	
+	memset(hrState_g.disk_list, 0, hrState_g.disk_list_len);
+
+	if (sysctlbyname("kern.disks", hrState_g.disk_list, &disk_list_len, NULL, 0) < 0  
+	    ||  hrState_g.disk_list[0] == 0) {
+		syslog(LOG_ERR, "hrDiskStorageTable: sysctl #2 kern.disks failed: %m");
+		return;
+	}
+	
+	for (disk_cnt = 0; disk_cnt < disk_list_len; disk_cnt++) {
+		char* disk = NULL;
+		char disk_device[128] = "";
+		disk = strsep(&hrState_g.disk_list, " ");
+		if (disk == NULL)
+			break;
+			
+		(void)snprintf(disk_device, sizeof(disk_device) - 1, 
+			"%s%s", _PATH_DEV, disk);
+		/*
+		First check if the disk is in the hrDeviceTable.
+		If not,add it.
+		NOTE; most disk devices (ATA, removable)  are not detected by libdevice API
+		*/
+		entry = hrDeviceTblEntry_find_by_name(disk);
+		if (entry == NULL) {
+			HR_DPRINTF((stderr,
+			 "hrDiskStorageTable; disk %s not in hrDeviceTable\n",
+			 disk_device ));
+			entry =  hrDeviceTblEntry_create(disk);
+			entry->flags |= HR_DEVICE_IMMUTABLE;
+			entry->type = OIDX_hrDeviceDiskStorage_c;
+			entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+			entry->status = (int32_t)DS_RUNNING;
+			entry->errors = 0; /*FIX ME*/
+			(void)snprintf((char *)entry->descr, sizeof(entry->descr) - 1, 
+				"%s: Disk Storage",
+				disk);
+		}else{
+			HR_DPRINTF((stderr,
+			 "hrDiskStorageTable; disk %s already in hrDeviceTable\n",
+			 disk_device ));
+ 			entry->type = OIDX_hrDeviceDiskStorage_c;
+			entry->flags |= HR_DEVICE_IMMUTABLE;
+		}
+		/*Then check hrDiskStorage table for this device*/
+		disk_entry = hrDiskStorageTblEntry_find_by_index(entry->index);
+		if (disk_entry == NULL) {
+			disk_entry = hrDiskStorageEntry_create(entry);
+		}
+		assert(disk_entry != NULL);
+		disk_entry->flags |= HR_DISKSTORAGE_FOUND;
+		
+		if ((disk_entry->flags & HR_DISKSTORAGE_ATA) == HR_DISKSTORAGE_ATA || 
+		    (disk_entry->flags & HR_DISKSTORAGE_MD) == HR_DISKSTORAGE_MD) {
+			/*ATA detection is running before this one, 
+			so don't waste the time here */
+			continue;
+		}
+		
+		disk_entry->access = (int32_t)DS_READ_WRITE;
+		disk_entry->media = (int32_t)DSM_UNKNOWN;
+		disk_entry->removable = (int32_t)SNMP_FALSE;
+		
+		
+		if (strncmp((const char*)disk_entry->dev_name, 
+			"da", strlen("da")) == 0) {
+			disk_entry->media = (int32_t)DSM_HARDDISK;
+			disk_entry->removable = (int32_t)SNMP_FALSE;
+		} else 	if (strncmp((const char*)disk_entry->dev_name, 
+			"cd", strlen("cd")) == 0) {
+			disk_entry->media = (int32_t)DSM_OPTICALDISKROM;
+			disk_entry->removable = (int32_t)SNMP_TRUE;
+	 	} else {
+			disk_entry->media = (int32_t)DSM_UNKNOWN;
+			disk_entry->removable = (int32_t)SNMP_FALSE;
+		}
+		
+		memset(&disk_entry->dev_name[0], 0, 
+			sizeof(disk_entry->dev_name));
+			
+		strncpy((char *)disk_entry->dev_name, disk, 
+			sizeof(disk_entry->dev_name)-1);
+		
+		hrDiskStorage_queryDisk(disk_entry);
+		disk_entry->r_tick = this_tick;
+
+				
+	}
+
+}
+
+/*
+ * Init the things for both of hrDiskStorageTable 
+ */
+void init_hrDiskStorage_tbl_v(void) {
+	refresh_DiskStorage_tbl_v();
+}
+
+/*
+ * Finalization routine for hrDiskStorageTable 
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_DiskStorage_tbl_v(void) {
+	struct hrDiskStorageTblEntry *n1 = NULL, *n2 = NULL;			
+	n1 = TAILQ_FIRST(&hrState_g.hr_disk_storage_tbl);
+	while (n1 != NULL) {
+		n2 = TAILQ_NEXT(n1, link);
+		free(n1);
+		n1 = n2;
+
+	}
+	TAILQ_INIT(&hrState_g.hr_disk_storage_tbl);
+
+}
+
+
+/*
+ * Refresh routine for hrDiskStorageTable 
+ * Usable for polling the system for any changes.
+ */
+void refresh_DiskStorage_tbl_v(void) {
+	struct hrDiskStorageTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if (  this_tick <= hrState_g.hr_disk_storage_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	
+	Partition_tbl_pre_refresh_v();
+		
+	/*mark each entry as missing*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_disk_storage_tbl, link) {
+		entry->flags &= ~HR_DISKSTORAGE_FOUND;
+	}
+	
+	hrDiskStorage_OS_get_ATA_disks_v(); /*this must be called first !*/
+	hrDiskStorage_OS_get_MD_disks_v();
+	hrDiskStorage_OS_get_disks_v();
+	
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_disk_storage_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_DISKSTORAGE_FOUND) ) {
+			struct hrDeviceTblEntry * dev_entry = NULL;
+			dev_entry = hrDeviceTblEntry_find_by_index(entry->index);
+			if (dev_entry != NULL) {
+				hrDeviceTblEntry_delete_v(dev_entry);
+			}
+			hrDiskStorageEntry_delete_v(entry);
+		}	
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_disk_storage_tick = this_tick;			
+			
+	hrState_g.hrDiskStorage_age = time(NULL);	
+
+	Partition_tbl_post_refresh_v();					
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+
+}
+
+
+/*
+ * This is the implementation for a generated (by our SNMP "compiler" tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrDiskStorageTable
+ */
+  
+int op_hrDiskStorageTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrDiskStorageTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+	
+	if ( (time(NULL) - hrState_g.hrDiskStorage_age) > HR_DISKSTORAGE_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_DiskStorage_tbl_v();
+	}
+	
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_disk_storage_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = 
+		     hrDiskStorageTblEntry_find_by_index(value->var.subs[sub])) 
+		     == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+	  case LEAF_hrDiskStorageAccess:
+	  	value->v.integer = entry->access;
+	  	break;	
+	  case LEAF_hrDiskStorageMedia:
+	  	value->v.integer = entry->media;
+	  	break;	
+	  case LEAF_hrDiskStorageRemoveble:
+	  	value->v.integer = entry->removable;
+	  	break;	
+	  case LEAF_hrDiskStorageCapacity:
+	  	value->v.integer = entry->capacity;
+	  	break;	
+		
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_fs_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_fs_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_fs_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_fs_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,515 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for hrFSTable
+ */
+ 
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <sys/sysctl.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <syslog.h>
+#include <limits.h>
+#include <string.h>
+#include <err.h>
+
+/*some constant variables*/
+static 
+const struct asn_oid OIDX_hrFSBerkeleyFFS_c = OIDX_hrFSBerkeleyFFS;
+
+static 
+const struct asn_oid OIDX_hrFSiso9660_c = OIDX_hrFSiso9660;
+
+static 
+const struct asn_oid OIDX_hrFSNFS_c = OIDX_hrFSNFS;
+
+static 
+const struct asn_oid OIDX_hrFSLinuxExt2_c = OIDX_hrFSLinuxExt2;
+
+static 
+const struct asn_oid OIDX_hrFSOther_c = OIDX_hrFSOther;
+
+static 
+const struct asn_oid OIDX_hrFSFAT32_c = OIDX_hrFSFAT32;
+
+static 
+const struct asn_oid OIDX_hrFSNTFS_c = OIDX_hrFSNTFS;
+
+static 
+const struct asn_oid OIDX_hrFSNetware_c = OIDX_hrFSNetware;
+
+static 
+const struct asn_oid OIDX_hrFSHPFS_c = OIDX_hrFSHPFS;
+
+static 
+const struct asn_oid OIDX_hrFSUnknown_c = OIDX_hrFSUnknown;
+
+extern 
+void 
+handle_partition_fs_index(const char *name, int32_t fs_idx);
+
+static
+struct hrFSTblEntry* 
+hrFSTblEntry_create( const char *name ) {
+	struct hrFSTblEntry	*entry;
+	struct FSNameMapEntry 	*map = NULL;
+
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "%s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+	strncpy((char *)entry->mountPoint, name, 
+		sizeof(entry->mountPoint)-1);
+
+	STAILQ_FOREACH(map, &hrState_g.fs_name_map, link)
+		if (strncmp((const char*)map->a_name, 
+			(const char*)entry->mountPoint, 
+			sizeof(map->a_name) - 1) == 0) {
+			
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrFS_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrFSTable index wrap", __func__ );
+			errx(1, "hrStorage index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "%s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrFS_index ++;
+		map->a_name[sizeof(map->a_name)-1]='\0';
+		strncpy((char*)map->a_name, 
+			(const char*)entry->mountPoint, 
+			sizeof(map->a_name) - 1);
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.fs_name_map, map, link);
+		HR_DPRINTF((stderr, "%s  added into hrFSMap at index=%d\n ", 
+				name, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s  exists in hrFSMap index=%d\n ", 
+				name, map->hrIndex));
+	}
+	
+	entry->index = map->hrIndex;
+
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_fs_tbl);
+	
+	return entry;
+	
+}
+
+static
+void
+hrFSTblEntry_delete_v( struct hrFSTblEntry* entry ) {
+	struct FSNameMapEntry  *map;
+	assert(entry != NULL);
+	
+	TAILQ_REMOVE(&hrState_g.hr_fs_tbl, entry, link);	
+	STAILQ_FOREACH(map, &hrState_g.fs_name_map, link)
+		if (map->entry_p == entry) {
+			map->entry_p = NULL;
+			break;
+		}
+			
+	free(entry);
+}
+
+static
+struct hrFSTblEntry*
+hrFSTblEntry_find_by_name(const char *name) {
+	struct hrFSTblEntry *entry =  NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_fs_tbl, link)
+		if (strncmp((const char*)entry->mountPoint, 
+			name, 
+			sizeof(entry->mountPoint) - 1) == 0)
+			return (entry);
+	return (NULL);
+}
+
+static
+struct hrFSTblEntry *
+hrFSTblEntry_find_by_index(int32_t idx) {
+	struct hrFSTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_fs_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+
+void init_hrFS_tbl_v(void) {
+
+	refresh_hrFS_tbl_v();	
+	HR_DPRINTF((stderr, "%s: TABLE INIT DONE\n ",__func__));
+	
+}
+
+
+void fini_hrFS_tbl_v(void) {
+	struct FSNameMapEntry  *n1, *n2;
+			
+     	n1 = STAILQ_FIRST(&hrState_g.fs_name_map);
+     	while (n1 != NULL) {
+             n2 = STAILQ_NEXT(n1, link);
+	     if(n1->entry_p != NULL){
+	     	TAILQ_REMOVE(&hrState_g.hr_fs_tbl, n1->entry_p, link);
+             	free( n1->entry_p );
+		n1->entry_p = NULL;
+	     }
+	     free(n1);
+             n1 = n2;
+     	}
+     	STAILQ_INIT(&hrState_g.fs_name_map);
+	TAILQ_INIT(&hrState_g.hr_fs_tbl);
+
+}
+
+void
+FS_tbl_pre_refresh_v(void) {
+	struct hrFSTblEntry *entry = NULL;
+
+	/*mark each entry as missisng*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_fs_tbl, link)
+		entry->flags &= ~HR_FS_FOUND;
+
+}
+
+
+void
+FS_tbl_post_refresh_v(void) {
+	struct hrFSTblEntry *entry = NULL, *entry_tmp = NULL;
+
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_fs_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_FS_FOUND))
+			hrFSTblEntry_delete_v(entry);
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_fs_tick = this_tick;			
+			
+	hrState_g.hrFS_tbl_age = time(NULL);	
+}
+
+void refresh_hrFS_tbl_v(void) {
+	
+	if ( this_tick <= hrState_g.hr_fs_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	
+	refresh_hrStorage_tbl_v();	
+	
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+		
+}
+
+static 
+void get_FS_type_v(const struct statfs *fs_p, struct asn_oid *out_type_p) {
+	assert(fs_p != NULL);
+	assert(out_type_p != NULL);
+
+	if(strncmp( fs_p->f_fstypename, "ufs", strlen("ufs") ) == 0) {
+		*out_type_p = OIDX_hrFSBerkeleyFFS_c;
+		return;
+	}
+	if(strncmp( fs_p->f_fstypename, "cd9660", strlen("cd9660") ) == 0) {
+		*out_type_p = OIDX_hrFSiso9660_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "nfs", strlen("nfs") ) == 0) {
+		*out_type_p = OIDX_hrFSNFS_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "ext2fs", strlen("ext2fs") ) == 0) {
+		*out_type_p = OIDX_hrFSLinuxExt2_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "procfs", strlen("procfs") ) == 0) {
+		*out_type_p = OIDX_hrFSOther_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "devfs", strlen("devfs") ) == 0) {
+		*out_type_p = OIDX_hrFSOther_c;
+		return;
+	}
+		
+	if(strncmp( fs_p->f_fstypename, "msdosfs", strlen("msdosfs") ) == 0) {
+		*out_type_p = OIDX_hrFSFAT32_c;
+		return;
+	}
+			
+	if(strncmp( fs_p->f_fstypename, "ntfs", strlen("ntfs") ) == 0) {
+		*out_type_p = OIDX_hrFSNTFS_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "nwfs", strlen("nwfs") ) == 0) {
+		*out_type_p = OIDX_hrFSNetware_c;
+		return;
+	}
+
+	if(strncmp( fs_p->f_fstypename, "hpfs", strlen("hpfs") ) == 0) {
+		*out_type_p = OIDX_hrFSHPFS_c;
+		return;
+	}
+
+																																																																																																								
+	*out_type_p = OIDX_hrFSUnknown_c;
+}
+
+void 
+FS_tbl_process_statfs_entry_v(const struct statfs *fs_p, int32_t storage_idx) {
+	struct hrFSTblEntry *entry = NULL; 
+	
+	assert(fs_p != 0);
+	
+	HR_DPRINTF((stderr, "%s:for hrStorageEntry::index %d\n ", __func__, storage_idx));
+	
+	if(fs_p == NULL) {
+		return;
+	}
+	
+	entry = hrFSTblEntry_find_by_name(fs_p->f_mntonname);
+	if(entry != NULL) {
+		/*entry already exists, update it*/
+		entry->flags |= HR_FS_FOUND;
+		
+		entry->mountPoint[0]='\0'; 
+		strncpy((char *)&entry->mountPoint[0], &fs_p->f_mntonname[0], 
+			sizeof(entry->mountPoint) - 1 );
+		
+		
+		if( !(fs_p->f_flags &  MNT_LOCAL) ) {
+			/*this remote mount*/
+			strncpy((char*)&entry->remoteMountPoint[0], 
+				&fs_p->f_mntfromname[0], 
+				sizeof(entry->remoteMountPoint)-1);
+		} else {
+			entry->remoteMountPoint[0]='\0';	
+		}
+		
+		get_FS_type_v(fs_p, &entry->type);
+		
+		if( (fs_p->f_flags &  MNT_RDONLY) == MNT_RDONLY ) {
+			entry->access = (int32_t)FS_READ_ONLY;
+		} else {
+			entry->access = (int32_t)FS_READ_WRITE;		
+		}
+		
+		/*FIX ME - bootable fs ?! */
+		if( ( fs_p->f_flags &  MNT_ROOTFS ) == MNT_ROOTFS ) {
+			entry->bootable = (int32_t)SNMP_TRUE; 
+		} else {
+			entry->bootable = (int32_t)SNMP_FALSE; 
+		}
+		
+		entry->storageIndex = storage_idx;
+		
+		memset(&entry->lastFullBackupDate[0], 0, 
+			sizeof(entry->lastFullBackupDate)); /*Info not available*/
+
+		
+		
+		memset(&entry->lastPartialBackupDate[0], 0, 
+			sizeof(entry->lastPartialBackupDate)); /*Info not available*/
+
+
+		 
+		handle_partition_fs_index(fs_p->f_mntfromname, entry->index);
+	
+		return;
+	}
+	if ((entry = hrFSTblEntry_create(fs_p->f_mntonname)) != NULL) {
+		entry->flags |= HR_FS_FOUND;
+		
+		memset(&entry->mountPoint[0], '\0',  sizeof(entry->mountPoint));
+		
+		strncpy((char *)&entry->mountPoint[0], &fs_p->f_mntonname[0], 
+			sizeof(entry->mountPoint) - 1 );
+		
+		
+		if( !(fs_p->f_flags &  MNT_LOCAL) ) {
+			/*this remote mount*/
+			strncpy((char *)&entry->remoteMountPoint[0], &fs_p->f_mntfromname[0], 
+				sizeof(entry->remoteMountPoint)-1);
+		} else {
+			entry->remoteMountPoint[0]='\0';	
+		}
+		
+		get_FS_type_v(fs_p, &entry->type);
+		
+		if( ( fs_p->f_flags &  MNT_RDONLY ) == MNT_RDONLY ) {
+			entry->access = (int32_t)FS_READ_ONLY;
+		} else {
+			entry->access = (int32_t)FS_READ_WRITE;		
+		}
+
+		/*FIX ME - bootable fs ?! */
+		if( ( fs_p->f_flags &  MNT_ROOTFS ) == MNT_ROOTFS ) {
+			entry->bootable = (int32_t)SNMP_TRUE; 
+		} else {
+			entry->bootable = (int32_t)SNMP_FALSE; 
+		}
+				
+		
+
+		
+		entry->storageIndex = storage_idx;
+		
+		memset(&entry->lastFullBackupDate[0], 0, 
+			sizeof(entry->lastFullBackupDate)); /*Info not available*/
+
+		memset(&entry->lastPartialBackupDate[0], 0, 
+			sizeof(entry->lastPartialBackupDate)); /*Info not available*/
+
+		handle_partition_fs_index(fs_p->f_mntfromname, entry->index);
+				
+	}
+	return;
+}
+
+
+/*
+ * This is the implementation for a generated (by our SNMP "compiler" tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrFSTable
+ */
+
+
+int op_hrFSTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value , 
+		u_int sub , 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrFSTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+
+/*
+	refresh entries here?!	
+*/
+	if ( (time(NULL) - hrState_g.hrFS_tbl_age) > HR_FS_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrFS_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_fs_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrFSTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrFSIndex:
+		value->v.integer = entry->index;
+		break;
+	  case LEAF_hrFSMountPoint:
+	  	ret = string_get(value, entry->mountPoint, -1);
+	  	break;	
+	  case LEAF_hrFSRemoteMountPoint:
+	  	ret = string_get(value, entry->remoteMountPoint, -1);
+	  	break;	
+	  case 	LEAF_hrFSType:
+	  	value->v.oid = entry->type;
+	  	break;
+	  case LEAF_hrFSAccess:
+	  	value->v.integer = entry->access;
+	  	break;	
+	  case LEAF_hrFSBootable:
+	  	value->v.integer = entry->bootable;
+		break;
+	  case LEAF_hrFSStorageIndex:
+	  	value->v.integer = entry->storageIndex;
+		break;
+	  case LEAF_hrFSLastFullBackupDate:
+		ret = string_get(value, entry->lastFullBackupDate, 8);
+		break;
+	  case LEAF_hrFSLastPartialBackupDate:
+		ret = string_get(value, entry->lastPartialBackupDate, 8);
+		break;
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_network_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_network_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_network_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_network_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,495 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB implementation for SNMPd: instrumentation for
+ * hrNetworkTable
+ */
+/*
+ * This C compilation unit contains code which was inspired by the code
+ * developed by Jordan Hubbard under the following copyright:
+ */
+/*
+ * The new sysinstall program.
+ *
+ * This is probably the last program in the `sysinstall' line - the next
+ * generation being essentially a complete rewrite.
+ *
+ * $FreeBSD: src/usr.sbin/sysinstall/devices.c,v 1.160 2005/01/04 11:04:03 nyan Exp $
+ *
+ * Copyright (c) 1995
+ *	Jordan Hubbard.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    verbatim and that no modifications are made prior to this
+ *    point in the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */ 
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>	
+#include <err.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/errno.h>
+#include <net/if_var.h>
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <arpa/inet.h>
+#include <ctype.h>
+
+
+static 
+const struct asn_oid OIDX_hrDeviceNetwork_c = OIDX_hrDeviceNetwork;
+
+extern
+struct hrDeviceTblEntry*
+hrDeviceTblEntry_find_by_name(const char *dev_name);
+
+
+extern
+struct hrDeviceTblEntry *
+hrDeviceTblEntry_find_by_index(int32_t idx);
+
+
+
+extern
+void
+hrDeviceTblEntry_delete_v( struct hrDeviceTblEntry* entry );
+
+
+static
+struct hrNetworkTblEntry* 
+hrNetworkEntry_create( const struct hrDeviceTblEntry* devEntry) {
+	struct 
+	hrNetworkTblEntry	*entry = NULL;
+
+	assert(devEntry != NULL);
+	if (devEntry == NULL) {
+		return NULL;
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrNetworkTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	entry->index = devEntry->index;
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_network_tbl);
+	return entry;
+
+}
+
+static
+void
+hrNetworkEntry_delete_v( struct hrNetworkTblEntry* entry ) {
+	assert(entry != NULL);
+	if (entry == NULL) {
+		return;
+	}
+	TAILQ_REMOVE(&hrState_g.hr_network_tbl, entry, link);	
+	free(entry);
+}
+
+
+static
+struct hrNetworkTblEntry *
+hrNetworkEntry_find_by_index(int32_t idx) {
+
+	struct hrNetworkTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_network_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+static
+struct hrDeviceTblEntry* 
+hrDeviceTblEntry_create( const char* dev_name) {
+	struct 
+	hrDeviceTblEntry	*entry;
+	struct 
+	deviceNameMapEntry 	*map = NULL;
+
+	
+	assert(dev_name != NULL);
+
+	if (dev_name == NULL) {
+		return (NULL);
+	}
+	
+	if (dev_name[0] == '\0') {
+		return (NULL);	
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrNetworkTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link)
+		if (strcmp((const char*)map->name_key, dev_name) == 0) {
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrDevice_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrDeviceTable index wrap", __func__ );
+			errx(1, "hrDeviceTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrNetworkTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrDevice_index ++;
+		
+		memset(&map->name_key[0], 0, sizeof(map->name_key));
+		
+		strncpy((char *)map->name_key, 
+			dev_name, 
+			sizeof(map->name_key) - 1);
+		
+		memset(&map->location_key[0], 0, sizeof(map->location_key));
+		(void)snprintf((char*)map->location_key, 
+			sizeof(map->location_key) - 1, 
+			"net_device:%s", dev_name);
+
+
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.device_name_map, map, link);
+		HR_DPRINTF((stderr, "%s at %s  added into hrDeviceMap at index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s at %s  exists in hrDeviceMap index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+
+	}
+	
+	entry->index = map->hrIndex;
+	memset(&entry->name[0], 0, sizeof(entry->name));
+	strncpy((char *)entry->name, dev_name, 
+		sizeof(entry->name) - 1);
+		
+	memset(&entry->location[0], 0, sizeof(entry->location));
+	(void)snprintf((char *)entry->location, 
+		sizeof(entry->location) - 1,
+		"net_device:%s", dev_name);
+					
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_device_tbl);
+	
+	return entry;
+	
+}
+
+extern 
+u_int 
+mib2_getIfIndex(const char* dev_name);
+
+static
+void 
+hrNetwork_get_OS_entries(void){
+/*maximum number of interfaces we can get*/
+#define INTERFACE_MAX         64 
+
+	struct ifconf ifc;
+
+	struct ifreq * ifptr;
+	
+	struct ifreq ifrv[INTERFACE_MAX];
+
+	struct hrDeviceTblEntry* dev_entry = NULL;
+	struct hrNetworkTblEntry* net_entry = NULL;
+
+
+	ifc.ifc_len = sizeof(struct ifreq) * INTERFACE_MAX;
+	ifc.ifc_buf = (char*)&ifrv[0];
+
+	memset(&ifrv[0], 0, ifc.ifc_len);
+	
+	if (hrState_g.ifnet_sock <= 0 ) {
+		hrState_g.ifnet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+	}
+	
+	if (hrState_g.ifnet_sock < 0) {
+		syslog(LOG_ERR,"socket(AF_INET, SOCK_DGRAM, 0) failed: %m");
+		return;
+	}
+
+
+	if (ioctl(hrState_g.ifnet_sock, SIOCGIFCONF, (char *) &ifc) < 0) {
+		syslog(LOG_ERR,"failed to SIOCGIFCONF: %m");
+		close(hrState_g.ifnet_sock);
+		hrState_g.ifnet_sock = -1;
+		return;
+	}
+
+
+	
+	for (ifptr = ifrv;
+	     (char *)ifptr < (char *)ifrv + ifc.ifc_len;
+	      ifptr = (struct ifreq *)((char *)&(ifptr->ifr_addr) + ifptr->ifr_addr.sa_len)) {
+
+        	if (ifptr->ifr_name == NULL || ifptr->ifr_name[0] == 0) {
+			continue;
+		}
+
+		/* If it's not a link entry, forget it */
+		if (ifptr->ifr_ifru.ifru_addr.sa_family != AF_LINK) {
+			continue;
+		}
+
+		/* Eliminate network devices that don't make sense */
+		if (strncmp(ifptr->ifr_name, "lo", 2) == 0) {
+			continue;
+		}
+
+		/* If we have a slip device, don't register it */
+		if (strncmp(ifptr->ifr_name, "sl", 2) == 0) {
+	    		continue;
+		}
+		/* And the same for ppp */
+		if (strncmp(ifptr->ifr_name, "tun", 3) == 0 || strncmp(ifptr->ifr_name, "ppp", 3) == 0) {
+	    		continue;
+		}
+		
+		HR_DPRINTF((stderr, "----- hrNetworkTable: got device %s \n",
+			ifptr->ifr_name ));
+
+
+		dev_entry = hrDeviceTblEntry_find_by_name(ifptr->ifr_name);
+
+		if (dev_entry == NULL) {
+			HR_DPRINTF((stderr,
+			"hrNetworkTable: %s not in hrDeviceTable\n",
+			ifptr->ifr_name ));
+			dev_entry =  hrDeviceTblEntry_create(ifptr->ifr_name);
+			if (dev_entry == NULL) {
+				continue;
+			}
+			dev_entry->flags |= HR_DEVICE_IMMUTABLE;
+			dev_entry->type = OIDX_hrDeviceNetwork_c;
+			dev_entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+			dev_entry->status = (int32_t)DS_RUNNING;
+			dev_entry->errors = 0; /*FIX ME*/
+			(void)snprintf((char *)dev_entry->descr, 
+				sizeof(dev_entry->descr) - 1, 
+				"%s: Network device",
+				ifptr->ifr_name);
+		}else{
+			HR_DPRINTF((stderr,
+			"hrNetworkTable: %s already in hrDeviceTable\n",
+			ifptr->ifr_name ));
+			dev_entry->type = OIDX_hrDeviceNetwork_c;
+			dev_entry->flags |= HR_DEVICE_IMMUTABLE;
+		}
+	
+		/*Then check hrNetworkTable for this device*/
+		net_entry = hrNetworkEntry_find_by_index(dev_entry->index);
+		if (net_entry == NULL) {
+			net_entry = hrNetworkEntry_create(dev_entry);
+		}
+		assert(net_entry != NULL);
+		net_entry->flags |= HR_NETWORK_FOUND;
+		net_entry->ifIndex = mib2_getIfIndex(ifptr->ifr_name);
+	
+	} /*end for*/
+	hrState_g.hr_network_tick = this_tick;			
+	hrState_g.hrNetwork_tbl_age = time(NULL);	
+ 	
+}
+ 
+/*
+ * Init the things for hrNetworkTable 
+ */
+void init_hrNetwork_tbl_v(void){
+	hrNetwork_get_OS_entries();
+}
+
+/*
+ * Finalization routine for hrNetworkTable 
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrNetwork_tbl_v(void){
+	struct hrNetworkTblEntry *n1 = NULL, *n2 = NULL;			
+	n1 = TAILQ_FIRST(&hrState_g.hr_network_tbl);
+	while (n1 != NULL) {
+		n2 = TAILQ_NEXT(n1, link);
+		free(n1);
+		n1 = n2;
+
+	}
+	TAILQ_INIT(&hrState_g.hr_network_tbl);
+
+}
+
+void refresh_hrNetwork_tbl_v(void) {
+	struct hrNetworkTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if (  this_tick <= hrState_g.hr_network_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	
+
+		
+	/*mark each entry as missing*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_network_tbl, link) {
+		entry->flags &= ~HR_NETWORK_FOUND;
+	}
+	
+
+
+	hrNetwork_get_OS_entries();
+	
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_network_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_NETWORK_FOUND) ) {
+			struct hrDeviceTblEntry * dev_entry = NULL;
+			dev_entry = hrDeviceTblEntry_find_by_index(entry->index);
+			if (dev_entry != NULL) {
+				hrDeviceTblEntry_delete_v(dev_entry);
+			}
+			hrNetworkEntry_delete_v(entry);
+		}	
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_network_tick = this_tick;			
+			
+	hrState_g.hrNetwork_tbl_age = time(NULL);	
+
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+}
+
+
+/*
+ * This is the implementation for a generated (by our SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrNetworkTable
+ */
+
+
+int op_hrNetworkTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrNetworkTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+	if ( (time(NULL) - hrState_g.hrNetwork_tbl_age) > HR_NETWORK_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrNetwork_tbl_v();
+	}
+
+		
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_network_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = 
+		     hrNetworkEntry_find_by_index(value->var.subs[sub])) 
+		     == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+	  case LEAF_hrNetworkIfIndex:
+	  	value->v.integer = entry->ifIndex;
+	  	break;	
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_partition_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_partition_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_partition_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_partition_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,381 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB: hrPartitionTable implementation for SNMPd.
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <libdisk.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <err.h>
+#include <paths.h>
+
+/*just some prototypes below*/
+void 
+handleDiskStorage(int32_t ds_index, const char* disk_dev_name);
+
+void
+Partition_tbl_pre_refresh_v(void);
+
+void
+Partition_tbl_post_refresh_v(void);
+
+void 
+handle_partition_fs_index(const char *name, int32_t fs_idx);
+
+
+static
+struct hrPartitionTblEntry* 
+hrPartitonTblEntry_create( int32_t ds_index, const struct chunk* curr_chunk) {
+	struct 
+	hrPartitionTblEntry	*entry;
+	struct 
+	PartitionNameMapEntry 	*map = NULL;
+
+	
+	assert(curr_chunk != NULL);
+	assert(curr_chunk->name != NULL);
+	if (curr_chunk == NULL || 
+		curr_chunk->name == NULL || 
+		curr_chunk->name[0] == '\0') {
+		return NULL;
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrPartitionTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+
+	STAILQ_FOREACH(map, &hrState_g.partition_name_map, link)
+		if (strcmp((const char*)map->id, curr_chunk->name) == 0 ) {
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrPartition_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrPartitionTable index wrap", __func__ );
+			errx(1, "hrPartitionTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrPartitionTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->index = hrState_g.next_hrPartition_index ++;
+		
+		memset(&map->id[0], 0, sizeof(map->id));
+		strncpy((char *)map->id, curr_chunk->name, sizeof(map->id) - 1);
+		
+
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.partition_name_map, map, link);
+		HR_DPRINTF((stderr, "%s   added into hrPartitionMap at index=%d\n ",
+				curr_chunk->name, map->index));
+				
+	} else {
+		HR_DPRINTF((stderr, "%s  exists in hrPartitionMap index=%d\n ",
+				curr_chunk->name, map->index));
+
+	}
+	
+	entry->index.len = 2;
+	entry->index.subs[0] = ds_index;
+	entry->index.subs[1] = map->index;
+
+	memset(&entry->id[0], 0, sizeof(entry->id));
+	strncpy((char*)entry->id, curr_chunk->name, sizeof(entry->id) - 1);
+		
+	INSERT_OBJECT_OID_LINK_INDEX(entry, &hrState_g.hr_partition_tbl, link, index);
+
+	return entry;
+	
+}
+
+
+static
+void
+hrPartitionTblEntry_delete_v( struct hrPartitionTblEntry* entry ) {
+	struct PartitionNameMapEntry  *map;
+	assert(entry != NULL);
+	
+	TAILQ_REMOVE(&hrState_g.hr_partition_tbl, entry, link);	
+	STAILQ_FOREACH(map, &hrState_g.partition_name_map, link)
+		if (map->entry_p == entry) {
+			map->entry_p = NULL;
+			break;
+		}
+			
+	free(entry);
+}
+
+static
+struct hrPartitionTblEntry*
+hrPartitionTblEntry_find_by_name(const char *name) {
+	struct hrPartitionTblEntry *entry =  NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_partition_tbl, link)
+		if (strncmp((const char *)entry->id, name, sizeof(entry->id) - 1) == 0)
+			return (entry);
+	return (NULL);
+}
+
+static
+struct hrPartitionTblEntry*
+hrPartitionTblEntry_find_by_label(const char *name) {
+	struct hrPartitionTblEntry *entry =  NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_partition_tbl, link)
+		if (strncmp((const char *)entry->label, name, sizeof(entry->label) - 1) == 0)
+			return (entry);
+	return (NULL);
+}
+
+static
+void handleChunk(int32_t ds_index, const struct chunk* chunk_p) {
+	struct hrPartitionTblEntry* entry = NULL;
+	daddr_t k_size;
+	
+	assert(chunk_p != NULL); 
+	if (chunk_p == NULL)
+		return;
+	if(chunk_p->type == unused){	
+		HR_DPRINTF((stderr,"SKIP  unused chunk %s\n",chunk_p->name));
+		return;
+	}else{
+		HR_DPRINTF((stderr,"ANALYZE chunk %s\n",chunk_p->name));	
+	}
+	entry = hrPartitionTblEntry_find_by_name(chunk_p->name);
+	if (entry == NULL) {
+		entry = hrPartitonTblEntry_create(ds_index, chunk_p);
+	}
+	assert(entry != NULL);
+	entry->flags |= HR_PARTITION_FOUND;
+	(void)snprintf((char* )entry->label, 
+		sizeof(entry->label) - 1, "%s%s",
+		 _PATH_DEV, chunk_p->name );
+	k_size = chunk_p->size/2;
+	/*may overflow the SNMP type*/
+	entry->size =  ( k_size > (daddr_t)INT_MAX ? INT_MAX : 	k_size ); 
+}
+
+void handleDiskStorage(int32_t ds_index, const char* disk_dev_name) {
+	struct disk* disk_p = NULL;
+	struct chunk* chunk_p = NULL;
+	 
+	assert(disk_dev_name != NULL);
+	assert(ds_index>0);
+	
+	
+     	disk_p = Open_Disk(disk_dev_name);
+     	assert(disk_p != NULL);
+     	if (disk_p == NULL) {
+     		return;
+     	}
+     	
+     	chunk_p = disk_p->chunks->part;
+     	while (chunk_p != NULL) {
+     		struct chunk* partition_p = chunk_p->part;
+     		handleChunk(ds_index, chunk_p);
+     		while (partition_p != NULL) {
+     			handleChunk(ds_index, partition_p);
+     			partition_p = partition_p->next;
+     		}
+     		chunk_p = chunk_p->next;
+     	}
+     	Free_Disk(disk_p);
+
+}
+
+/*
+ * Init the things for hrPartitionTable 
+ */
+void init_hrPartition_tbl_v(void) {
+}
+
+/*
+ * Finalization routine for hrPartitionTable  
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrPartition_tbl_v(void) {
+	struct PartitionNameMapEntry  *n1, *n2;
+			
+     	n1 = STAILQ_FIRST(&hrState_g.partition_name_map);
+     	while (n1 != NULL) {
+             n2 = STAILQ_NEXT(n1, link);
+	     if(n1->entry_p != NULL){
+	     	TAILQ_REMOVE(&hrState_g.hr_partition_tbl, n1->entry_p, link);
+             	free( n1->entry_p );
+		n1->entry_p = NULL;
+	     }
+	     free(n1);
+             n1 = n2;
+     	}
+     	STAILQ_INIT(&hrState_g.partition_name_map);
+	TAILQ_INIT(&hrState_g.hr_partition_tbl);
+}
+
+void
+Partition_tbl_pre_refresh_v(void) {
+	struct hrPartitionTblEntry *entry = NULL;
+
+	/*mark each entry as missisng*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_partition_tbl, link)
+		entry->flags &= ~HR_PARTITION_FOUND;
+
+}
+
+
+void
+Partition_tbl_post_refresh_v(void) {
+	struct hrPartitionTblEntry *entry = NULL, *entry_tmp = NULL;
+
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_partition_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_PARTITION_FOUND))
+			hrPartitionTblEntry_delete_v(entry);
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_partition_tick = this_tick;			
+			
+	hrState_g.hrPartition_tbl_age = time(NULL);	
+}
+
+
+void 
+handle_partition_fs_index(const char *name, int32_t fs_idx){
+	struct hrPartitionTblEntry* entry = NULL;
+	
+	entry = hrPartitionTblEntry_find_by_label(name);
+	if (entry == NULL) {
+		HR_DPRINTF((stderr, "%s  IS MISSING from  hrPartitionTable\n ", name));
+	} else {
+		HR_DPRINTF((stderr, "%s [FS index = %d] IS in hrPartitionTable\n ", name, fs_idx));
+		entry->fs_Index = fs_idx;
+	}
+
+}
+
+
+/*
+ * This is the implementation for a generated (by our SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrPartitionTable
+ */
+
+int op_hrPartitionTable(struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	struct hrPartitionTblEntry *entry = NULL;
+	int ret = SNMP_ERR_NOERROR;
+
+	if ( (time(NULL) - hrState_g.hrDiskStorage_age) > HR_DISKSTORAGE_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_DiskStorage_tbl_v();
+	}
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT: {
+                int found = 0;
+		TAILQ_FOREACH(entry, &hrState_g.hr_partition_tbl, link)
+			if (index_compare(&value->var, sub, &entry->index) < 0) {
+				found = 1;
+				break;						
+			}	
+		if (found == 0) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		index_append(&value->var, sub, &entry->index);
+		break;
+	  }
+	  case SNMP_OP_GET: {
+                int found = 0;
+		TAILQ_FOREACH(entry, &hrState_g.hr_partition_tbl, link)
+			if (index_compare(&value->var, sub, &entry->index) == 0) {
+				found = 1;
+				break;						
+			}	
+		if (found == 0) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		break;
+	 }
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  default:
+		assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	if (entry == NULL) {
+		return (SNMP_ERR_GENERR);
+	}
+	
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrPartitionIndex:
+		value->v.integer = entry->index.subs[1];
+		break;
+
+	  case LEAF_hrPartitionLabel:
+	  	ret = string_get(value, entry->label, -1);
+		break;
+
+	  case LEAF_hrPartitionID:
+		ret = string_get(value, entry->id, -1);
+		break;
+
+	  case LEAF_hrPartitionSize:
+		value->v.integer = entry->size;	  
+		break;
+
+	  case LEAF_hrPartitionFSIndex:
+		value->v.integer = entry->fs_Index;	
+		break;
+	}
+	return (ret);
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_printer_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_printer_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_printer_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_printer_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,976 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB implementation for SNMPd: instrumentation for
+ * hrPrinterTable
+ */
+ 
+ /*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h" 
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h> 
+#include <assert.h>
+#include <paths.h>
+#include <syslog.h>
+#include <err.h>
+#include <sys/stat.h>
+
+static 
+const struct asn_oid OIDX_hrDevicePrinter_c = OIDX_hrDevicePrinter;
+
+
+#define	_PATH_PRINTCAP		"/etc/printcap"
+#define	_PATH_DEFDEVLP		"/dev/lp"
+#define	_PATH_DEFSPOOL		"/var/spool/output/lpd"
+/*
+ * Error codes for our mini printcap library.
+ */
+#define	PCAPERR_TCLOOP		(-3)
+#define	PCAPERR_OSERR		(-2)
+#define	PCAPERR_NOTFOUND	(-1)
+#define	PCAPERR_SUCCESS		0
+#define	PCAPERR_TCOPEN		1
+
+/*
+ * Defaults for line printer capabilities data base
+ */
+#define	DEFLP		"lp"
+#define DEFLOCK		"lock"
+#define DEFSTAT		"status"
+#define	DEFMX		0
+#define DEFMAXCOPIES	0
+#define DEFFF		"\f"
+#define DEFWIDTH	132
+#define DEFLENGTH	66
+#define DEFUID		1
+#define DEFTIMEOUT	120
+  
+struct	printer {
+	char	*printer;	/* printer name */
+	int	 remote;	/* true if RM points to a remote host */
+	int	 rp_matches_local; /* true if rp has same name as us */
+
+	char	*log_file;	/* LF: log file */
+	char	*lock_file;	/* LO: lock file */
+	char	*lp;		/* LP: device name or network address */
+
+	char	*remote_host;	/* RM: remote machine name */
+	char	*remote_queue;	/* RP: remote printer name */
+	long	 restricted;	/* RS: restricted to those with local accts */
+	long	 rw;		/* RW: open LP for reading and writing */
+
+	char	*spool_dir;	/* SD: spool directory */
+
+	char	*stat_recv;	/* SR: statistics file, receiving jobs */
+	char	*stat_send;	/* SS: statistics file, sending jobs */
+	char	*status_file;	/* ST: status file name */
+
+};
+
+
+/*
+ * Routines and data used in processing the printcap file.
+ */
+
+
+
+static char 	*capdb_canonical_name(const char *_bp);
+static int	 capdb_getaltlog(char *_bp, const char *_shrt,
+		    const char *_lng);
+
+static int	 capdb_getaltstr(char *_bp, const  char *_shrt,
+		    const char *lng, const char *_dflt, char **_result);
+static int	 getprintcap_int(char *_bp, struct printer *_pp);
+
+static void	 init_printer(struct printer *pp);
+
+static int	 firstprinter(struct printer *pp, int *error);
+
+static int	 nextprinter(struct printer *pp, int *error);
+
+static void	 free_printer(struct printer *pp);
+
+static void	 lastprinter(void);
+
+const char	*pcaperr(int error);
+
+static
+char *
+status_file_name(const struct printer *pp, char *buf, size_t len)
+{
+	static char staticbuf[MAXPATHLEN];
+
+	if (buf == 0)
+		buf = staticbuf;
+	if (len == 0)
+		len = MAXPATHLEN;
+
+	if (pp->status_file[0] == '/')
+		(void)strlcpy(buf, pp->status_file, len);
+	else
+		(void)snprintf(buf, len, "%s/%s", pp->spool_dir, pp->status_file);
+
+	return buf;
+}
+
+static
+char *
+lock_file_name(const struct printer *pp, char *buf, size_t len)
+{
+	static char staticbuf[MAXPATHLEN];
+
+	if (buf == 0)
+		buf = staticbuf;
+	if (len == 0)
+		len = MAXPATHLEN;
+
+	if (pp->lock_file[0] == '/')
+		(void)strlcpy(buf, pp->lock_file, len);
+	else
+		(void)snprintf(buf, len, "%s/%s", pp->spool_dir, pp->lock_file);
+
+	return buf;
+}
+
+extern
+struct hrDeviceTblEntry*
+hrDeviceTblEntry_find_by_name(const char *dev_name);
+
+
+extern
+struct hrDeviceTblEntry *
+hrDeviceTblEntry_find_by_index(int32_t idx);
+
+
+
+extern
+void
+hrDeviceTblEntry_delete_v( struct hrDeviceTblEntry* entry );
+
+
+
+/*
+ * Map the status values returned by cgetfirst/cgetnext into those
+ * used by cgetent, returning truth if there are more records to
+ * examine.  This points out what is arguably a bug in the cget*
+ * interface (or at least a nasty wart).
+ */
+static int
+firstnextmap(int *status)
+{
+	switch (*status) {
+	case 0:
+		return 0;
+	case 1:
+		*status = 0;
+		return 1;
+	case 2:
+		*status = 1;
+		return 1;
+	case -1:
+		*status = -2;
+		return 0;
+	case -2:
+		*status = -3;
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * Scan through the database of printers using cgetfirst/cgetnext.
+ * Return false of error or end-of-database; else true.
+ */
+
+int
+firstprinter(struct printer *pp, int *error)
+{
+	int status;
+	char *bp;
+
+	init_printer(pp);
+	
+	assert(hrState_g._printcapdb != NULL);
+	
+	status = cgetfirst(&bp, hrState_g._printcapdb);
+	if (firstnextmap(&status) == 0) {
+		if (error)
+			*error = status;
+		return 0;
+	}
+	if (error)
+		*error = status;
+	status = getprintcap_int(bp, pp);
+	free(bp);
+	if (error && status)
+		*error = status;
+	return 1;
+}
+
+
+int
+nextprinter(struct printer *pp, int *error)
+{
+	int status;
+	char *bp;
+
+	free_printer(pp);
+	
+	assert(hrState_g._printcapdb != NULL);
+	
+	status = cgetnext(&bp, hrState_g._printcapdb);
+	if (firstnextmap(&status) == 0) {
+		if (error)
+			*error = status;
+		return 0;
+	}
+	if (error)
+		*error = status;
+	status = getprintcap_int(bp, pp);
+	free(bp);
+	if (error && status)
+		*error = status;
+	return 1;
+}
+
+
+void
+lastprinter(void)
+{
+	if (cgetclose() != 0) {
+		syslog(LOG_ERR, "cgetclose() failed: %m");
+	}
+}
+
+
+/*
+ * Internal routine for both getprintcap() and nextprinter().
+ * Actually parse the printcap entry using cget* functions.
+ * Also attempt to figure out the canonical name of the printer
+ * and store a malloced copy of it in pp->printer.
+ */
+static int
+getprintcap_int(char *bp, struct printer *pp)
+{
+
+	char *rp_name;
+	int error;
+
+	if ((pp->printer = capdb_canonical_name(bp)) == 0)
+		return PCAPERR_OSERR;
+
+#define CHK(x) do {if ((x) == PCAPERR_OSERR) return PCAPERR_OSERR;}while(0)
+
+
+
+	CHK(capdb_getaltstr(bp, "lf", "spool.log", _PATH_CONSOLE, 
+			    &pp->log_file));
+	CHK(capdb_getaltstr(bp, "lo", "spool.lock", DEFLOCK, &pp->lock_file));
+	CHK(capdb_getaltstr(bp, "lp", "tty.device", _PATH_DEFDEVLP, &pp->lp));
+
+
+
+	CHK(capdb_getaltstr(bp, "rm", "remote.host", 0, &pp->remote_host));
+	CHK(capdb_getaltstr(bp, "rp", "remote.queue", DEFLP, 
+			    &pp->remote_queue));
+	CHK(capdb_getaltstr(bp, "sd", "spool.dir", _PATH_DEFSPOOL,
+			    &pp->spool_dir));
+	CHK(capdb_getaltstr(bp, "sr", "stat.recv", 0, &pp->stat_recv));
+	CHK(capdb_getaltstr(bp, "ss", "stat.send", 0, &pp->stat_send));
+	CHK(capdb_getaltstr(bp, "st", "spool.status", DEFSTAT,
+			    &pp->status_file));
+
+	pp->restricted = capdb_getaltlog(bp, "rs", "daemon.restricted");
+
+
+	pp->rw = capdb_getaltlog(bp, "rw", "tty.rw");
+
+	
+	/*
+	 * Decide if the remote printer name matches the local printer name.
+	 * If no name is given then we assume they mean them to match.
+	 * If a name is given see if the rp_name is one of the names for
+	 * this printer.
+	 */
+	pp->rp_matches_local = 1;
+	CHK((error = capdb_getaltstr(bp, "rp", "remote.queue", 0, &rp_name)));
+	if (error != PCAPERR_NOTFOUND && rp_name != NULL) {
+		if (cgetmatch(bp,rp_name) != 0)
+			pp->rp_matches_local = 0;
+		free(rp_name);
+	}
+
+
+	return 0;
+}
+
+/*
+ * Decode the error codes returned by cgetent() using the names we
+ * made up for them from "lp.h".
+ * This would have been much better done with Common Error, >sigh<.
+ * Perhaps this can be fixed in the next incarnation of cget*.
+ */
+const char *
+pcaperr(int error)
+{
+	switch(error) {
+	case PCAPERR_TCOPEN:
+		return "unresolved tc= expansion";
+	case PCAPERR_SUCCESS:
+		return "no error";
+	case PCAPERR_NOTFOUND:
+		return "printer not found";
+	case PCAPERR_OSERR:
+		return strerror(errno);
+	case PCAPERR_TCLOOP:
+		return "loop detected in tc= expansion";
+	default:
+		return "unknown printcap error";
+	}
+}
+
+/*
+ * Initialize a `struct printer' to contain values harmless to
+ * the other routines in liblpr.
+ */
+static 
+void
+init_printer(struct printer *pp)
+{
+	static struct printer zero;
+	*pp = zero;
+}
+
+/*
+ * Free the dynamically-allocated strings in a `struct printer'.
+ * Idempotent.
+ */
+void
+free_printer(struct printer *pp)
+{
+
+#define	cfree(x)	do { if (x) free(x); } while(0)
+	cfree(pp->printer);
+
+
+	cfree(pp->log_file);
+	cfree(pp->lock_file);
+	cfree(pp->lp);
+
+	cfree(pp->remote_host);
+	cfree(pp->remote_queue);
+	cfree(pp->spool_dir);
+	cfree(pp->stat_recv);
+	cfree(pp->stat_send);
+	cfree(pp->status_file);
+
+
+	init_printer(pp);
+}
+
+
+/* 
+ * The following routines are part of what would be a sensible library 
+ * interface to capability databases.  Maybe someday this will become
+ * the default.
+ */
+
+/*
+ * It provides similar functionality to cgetstr(),
+ * except that it provides for both a long and a short
+ * capability name and allows for a default to be specified.
+ */
+static int
+capdb_getaltstr(char *bp, const char *shrt, const char *lng, 
+    const char *dflt, char **result)
+{
+	int status;
+
+	status = cgetstr(bp, lng, result);
+	if (status >= 0 || status == PCAPERR_OSERR)
+		return status;
+	status = cgetstr(bp, shrt, result);
+	if (status >= 0 || status == PCAPERR_OSERR)
+		return status;
+	if (dflt) {
+		*result = strdup(dflt);
+		if (*result == 0)
+			return PCAPERR_OSERR;
+		return strlen(*result);
+	}
+	return PCAPERR_NOTFOUND;
+}
+
+
+
+/*
+ * Likewise for logical values.  There's no need for a default parameter
+ * because the default is always false.
+ */
+static int
+capdb_getaltlog(char *bp, const char *shrt, const char *lng)
+{
+	if (cgetcap(bp, (char *)/*XXX*/lng, ':'))
+		return 1;
+	if (cgetcap(bp, (char *)/*XXX*/shrt, ':'))
+		return 1;
+	return 0;
+}
+
+/*
+ * Also should be a part of a better cget* library.
+ * Given a capdb entry, attempt to figure out what its canonical name
+ * is, and return a malloced copy of it.  The canonical name is
+ * considered to be the first one listed.
+ */
+static char *
+capdb_canonical_name(const char *bp)
+{
+	char *retval;	
+	const char *nameend;
+
+	nameend = strpbrk(bp, "|:");
+	if (nameend == 0)
+		nameend = bp + 1;
+	if ((retval = malloc(nameend - bp + 1)) != 0) {
+		retval[0] = '\0';
+		strncat(retval, bp, nameend - bp);
+	}
+	return retval;
+}
+
+
+static
+struct hrPrinterTblEntry* 
+hrPrinterEntry_create( const struct hrDeviceTblEntry* devEntry) {
+	struct 
+	hrPrinterTblEntry	*entry = NULL;
+
+	assert(devEntry != NULL);
+	if (devEntry == NULL) {
+		return NULL;
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrPrinterTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	entry->index = devEntry->index;
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_printer_tbl);
+	return entry;
+
+}
+
+static
+void
+hrPrinterEntry_delete_v( struct hrPrinterTblEntry* entry ) {
+	assert(entry != NULL);
+	if (entry == NULL) {
+		return;
+	}
+	TAILQ_REMOVE(&hrState_g.hr_printer_tbl, entry, link);	
+	free(entry);
+}
+
+
+static
+struct hrPrinterTblEntry *
+hrPrinterEntry_find_by_index(int32_t idx) {
+
+	struct hrPrinterTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_printer_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+static
+struct hrDeviceTblEntry* 
+hrDeviceTblEntry_create( const char* dev_name) {
+	struct 
+	hrDeviceTblEntry	*entry;
+	struct 
+	deviceNameMapEntry 	*map = NULL;
+	
+	
+	assert(dev_name != NULL);
+
+	if (dev_name == NULL) {
+		return (NULL);
+	}
+	
+	if (dev_name[0] == '\0') {
+		return (NULL);	
+	}
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "hrPrinterTable: %s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	
+
+
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link) {
+		if (strcmp((const char*)map->name_key, dev_name) == 0) {
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrDevice_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrDeviceTable index wrap", __func__ );
+			errx(1, "hrDeviceTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrPrinterTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrDevice_index ++;
+		
+		memset(&map->name_key[0], 0, sizeof(map->name_key));
+		strncpy((char *)map->name_key, dev_name, sizeof(map->name_key) - 1);
+		
+		memset(&map->location_key[0], 0, sizeof(map->location_key));
+		(void)snprintf((char *)map->location_key, 
+			sizeof(map->location_key) - 1, 
+			"printer:%s", dev_name);
+
+
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.device_name_map, map, link);
+		HR_DPRINTF((stderr, "%s at %s  added into hrDeviceMap at index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s at %s  exists in hrDeviceMap index=%d\n ",
+				dev_name, 
+				dev_name, map->hrIndex));
+
+	}
+	
+	entry->index = map->hrIndex;
+	memset(&entry->name[0], 0, sizeof(entry->name));
+	strncpy((char *)entry->name, dev_name, sizeof(entry->name) - 1);
+		
+	memset(&entry->location[0], 0, sizeof(entry->location));
+	(void)snprintf((char *)entry->location, 
+		sizeof(entry->location) - 1, 
+		"printer:%s", dev_name);
+					
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_device_tbl);
+	
+	return (entry);
+	
+}
+
+static
+enum PrinterStatus 
+getPrinterSatus(const struct printer *pp) {
+	char statfile[MAXPATHLEN];
+	char lockfile[MAXPATHLEN];
+	
+	char line[128];
+	int fd  = -1;
+	FILE* f = NULL;
+	enum PrinterStatus ps = PS_UNKNOWN;
+
+	(void)lock_file_name(pp, lockfile, sizeof lockfile);
+	fd = open(lockfile, O_RDONLY);
+	if (fd < 0 || flock(fd, LOCK_SH|LOCK_NB) == 0) {
+		(void) close(fd);	/* unlocks as well */
+		fd = -1;
+		ps = PS_IDLE;
+		goto  LABEL_DONE;
+	}
+	
+			
+	(void)status_file_name(pp, statfile, sizeof(statfile));
+	f = fopen(statfile, "r");
+	if (f == NULL) {
+		syslog(LOG_ERR, "cannot open status file: %s\n", 
+			strerror(errno));
+		ps = PS_UNKNOWN;
+		goto  LABEL_DONE;		
+	}
+	
+
+		
+	memset(&line[0], '\0', sizeof(line));
+	if (fgets(line, sizeof(line) -1, f) == NULL) {
+		ps = PS_UNKNOWN;
+		goto  LABEL_DONE;
+	}
+	if (strstr(line, "is ready and printing") != NULL) {
+		ps = PS_PRINTING;
+		goto  LABEL_DONE;
+	} 
+	if (strstr(line, "to become ready (offline?)") != NULL) {
+		ps = PS_OTHER;
+		goto  LABEL_DONE;
+	}
+	
+	
+LABEL_DONE:
+	if (fd > 0) {
+		(void) close(fd);	/* unlocks as well */
+	}
+	if (f != NULL) {
+		fclose(f);
+	}	
+		
+	return (ps);
+
+}
+static
+void
+handle_printer(struct printer *pp) {
+	struct hrDeviceTblEntry* dev_entry = NULL;
+	struct hrPrinterTblEntry* printer_entry = NULL;
+	char dev_only[128];
+	struct stat sb;
+	
+	if (pp->rp_matches_local != 1) {
+		HR_DPRINTF((stderr,
+		"hrPrinterTable: skipped %s because it is not a local one\n",
+		pp->printer ));
+		return;
+		
+	}
+		
+	if (strncmp(pp->lp, _PATH_DEV, strlen(_PATH_DEV)) != 0) {
+		HR_DPRINTF((stderr,
+		"hrPrinterTable: skipped %s [device %s] because it is not a local one\n",
+		pp->printer,
+		pp->lp ));
+		return;
+	
+	}
+	memset(&dev_only[0], '\0', sizeof(dev_only));
+	(void)snprintf(dev_only, sizeof(dev_only) - 1, 
+		"%s", pp->lp + strlen(_PATH_DEV));
+	
+	HR_DPRINTF((stderr,
+		"hrPrinterTable: printer %s has device %s\n",
+		pp->printer,
+		dev_only ));	
+	
+	if (stat(pp->lp, &sb) < 0) {
+		if (errno == ENOENT) {
+			HR_DPRINTF((stderr,
+				"hrPrinterTable: printer %s has its device %s missing. SKIPPING it.\n",
+				pp->printer,
+				pp->lp));
+			return;	
+		}		
+		
+	}
+	
+	dev_entry = hrDeviceTblEntry_find_by_name(dev_only);
+
+	if (dev_entry == NULL) {
+		
+		
+		HR_DPRINTF((stderr,
+		"hrPrinterTable: %s not in hrDeviceTable\n",
+		pp->lp ));
+		
+		
+		
+		dev_entry =  hrDeviceTblEntry_create(dev_only);
+		if (dev_entry == NULL) {
+			return;
+		}
+		dev_entry->flags |= HR_DEVICE_IMMUTABLE;
+		dev_entry->type = OIDX_hrDevicePrinter_c;
+		dev_entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+		dev_entry->status = (int32_t)DS_RUNNING;
+		dev_entry->errors = 0; /*FIX ME*/
+		(void)snprintf((char *)dev_entry->descr, 
+			sizeof(dev_entry->descr) - 1, 
+			"printer %s: %s ",
+			pp->printer ,
+			pp->lp);
+	}else{
+		HR_DPRINTF((stderr,
+		"hrPrinterTable: %s already in hrDeviceTable\n",
+		pp->lp ));
+		dev_entry->type = OIDX_hrDevicePrinter_c;
+		dev_entry->flags |= HR_DEVICE_IMMUTABLE;
+	}
+
+	/*Then check hrPrinterTable for this device*/
+	printer_entry = hrPrinterEntry_find_by_index(dev_entry->index);
+	if (printer_entry == NULL) {
+		printer_entry = hrPrinterEntry_create(dev_entry);
+	}
+	assert(printer_entry != NULL);
+	printer_entry->flags |= HR_PRINTER_FOUND;
+	printer_entry->status = (int32_t)getPrinterSatus(pp);
+	memset(printer_entry->detectedErrorState, 0, 
+		sizeof(printer_entry->detectedErrorState));
+
+
+}
+
+static
+void 
+hrPrinter_get_OS_entries(void){
+	int  status, more;
+	struct printer myprinter, *pp = &myprinter;
+	
+	init_printer(pp);
+	HR_DPRINTF((stderr,  "---->Getting printers .....\n" ));
+	more = firstprinter(pp, &status);
+	if (status)
+		goto errloop;
+	while (more) {
+		
+		do {
+			HR_DPRINTF((stderr,  "---->Got printer %s\n", pp->printer));
+			
+			handle_printer(pp);
+			
+			more = nextprinter(pp, &status);
+errloop:
+			if (status)
+				syslog(LOG_WARNING, 
+				    "hrPrinterTable: printcap entry for %s has errors, skipping",
+				    pp->printer ? pp->printer : "<noname?>");
+		} while (more && status);
+	}
+	
+	lastprinter();
+	hrState_g.hr_printer_tick = this_tick;			
+	hrState_g.hrPrinter_tbl_age = time(NULL);		
+	
+}
+
+
+/*
+ * Init the things for hrPrinterTable 
+ */
+void init_hrPrinter_tbl_v(void){
+	hrState_g._printcapdb = (char**)malloc ( 2 * sizeof(char*) );
+	hrState_g._printcapdb[0] = strdup(_PATH_PRINTCAP);
+	hrState_g._printcapdb[1] = NULL;
+	
+	hrPrinter_get_OS_entries();
+}
+
+/*
+ * Finalization routine for hrPrinterTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrPrinter_tbl_v(void) {
+	struct hrPrinterTblEntry *n1 = NULL, *n2 = NULL;			
+	n1 = TAILQ_FIRST(&hrState_g.hr_printer_tbl);
+	while (n1 != NULL) {
+		n2 = TAILQ_NEXT(n1, link);
+		free(n1);
+		n1 = n2;
+
+	}
+	TAILQ_INIT(&hrState_g.hr_printer_tbl);
+
+	if (hrState_g._printcapdb != NULL) { 
+		if (hrState_g._printcapdb[0] != NULL) {
+			free(hrState_g._printcapdb[0]);
+			hrState_g._printcapdb[0] = NULL;
+		}
+		free(hrState_g._printcapdb);
+		hrState_g._printcapdb = NULL;
+	}
+	
+	
+
+}
+
+
+
+void refresh_hrPrinter_tbl_v(void){
+	struct hrPrinterTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if (  this_tick <= hrState_g.hr_printer_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	
+
+		
+	/*mark each entry as missing*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_printer_tbl, link) {
+		entry->flags &= ~HR_PRINTER_FOUND;
+	}
+	
+
+
+	hrPrinter_get_OS_entries();
+	
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_printer_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_PRINTER_FOUND) ) {
+			struct hrDeviceTblEntry * dev_entry = NULL;
+			dev_entry = hrDeviceTblEntry_find_by_index(entry->index);
+			if (dev_entry != NULL) {
+				hrDeviceTblEntry_delete_v(dev_entry);
+			}
+			hrPrinterEntry_delete_v(entry);
+		}	
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_printer_tick = this_tick;			
+			
+	hrState_g.hrPrinter_tbl_age = time(NULL);	
+
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+
+}
+
+
+int op_hrPrinterTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrPrinterTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+	if ( (time(NULL) - hrState_g.hrPrinter_tbl_age) > HR_PRINTER_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrPrinter_tbl_v();
+	}
+
+		
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_printer_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = 
+		     hrPrinterEntry_find_by_index(value->var.subs[sub])) 
+		     == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+	  case LEAF_hrPrinterStatus:
+	  	value->v.integer = entry->status;
+	  	break;	
+	  case LEAF_hrPrinterDetectedErrorState:
+		ret = string_get(value, 
+			entry->detectedErrorState, 
+			sizeof(entry->detectedErrorState));	  
+	  	break;	
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	
+	}
+	return (ret);
+
+}
+  
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_processor_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_processor_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_processor_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_processor_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for hrProcessorTable
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <stdarg.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <math.h>
+
+static 
+int get_avg_load( struct hrProcessorTblEntry *entry ) {
+	int i = 0;
+	double sum = 0.0;
+	assert(entry != NULL);
+	for( i = 0; i < MAX_CPU_SAMPLES; i++ ){
+		sum += entry->samples[i];
+	}
+	return ((int)floor((double)sum/(double)MAX_CPU_SAMPLES));
+}
+
+
+static
+struct hrProcessorTblEntry *
+hrProcessorTblEntry_find_by_cpu_no(u_char cpu_no) {
+
+	struct hrProcessorTblEntry *entry = NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_processor_tbl, link)
+		if (entry->cpu_no == cpu_no)
+			return (entry);
+	return (NULL);
+}
+
+
+static
+double
+hrProcessor_getpcpu(struct kinfo_proc* ki_p) {
+	/*
+	 * Stolen from /usr/src/bin/ps/print.c
+	 */
+	size_t oldlen;
+	if( hrState_g.ccpu == 0 ){
+		oldlen = sizeof(hrState_g.ccpu);
+		if (sysctlbyname("kern.ccpu", &hrState_g.ccpu, &oldlen, NULL, 0) < 0 ) {
+			syslog(LOG_ERR, "hrProcessorTable: sysctl(kern.ccpu) failed");
+			hrState_g.ccpu = 0;
+		}
+	}	
+	if ( hrState_g.fscale == 0){
+		oldlen = sizeof( hrState_g.fscale);
+		if (sysctlbyname("kern.fscale", & hrState_g.fscale, &oldlen, NULL, 0) < 0 ) {
+			syslog(LOG_ERR, "hrProcessorTable: sysctl(kern.fscale) failed");
+			hrState_g.fscale = 0;
+		
+		}	
+	}
+	if( hrState_g.ccpu == 0 ||  hrState_g.fscale == 0) {
+		return (0.0);
+	}
+	
+#define	fxtofl(fixpt)	((double)(fixpt) /  hrState_g.fscale)
+
+	/* XXX - I don't like this */
+	if (ki_p->ki_swtime == 0 || (ki_p->ki_sflag & PS_INMEM) == 0)
+		return (0.0);
+		
+	return (100.0 * fxtofl(ki_p->ki_pctcpu) /
+		(1.0 - exp(ki_p->ki_swtime * log(fxtofl( hrState_g.ccpu)))));
+}
+
+static
+void hrProcessor_get_pids_v(void) { 
+	struct kinfo_proc *plist =  NULL, *kp;
+	int i = 0;
+	int nproc = -1;
+
+	
+	plist = kvm_getprocs(hrState_g.kd, KERN_PROC_ALL, 0, &nproc);
+	if (plist == NULL || nproc < 0) {
+		syslog(LOG_ERR, "hrProcessor: kvm_getprocs() failed: %m");
+		return;
+	}
+	for (i = 0, kp = plist; i < nproc; i++, kp++) {	
+		if ( ! (IS_KERNPROC(kp)) ) {
+			continue;
+		}	
+		if (strncmp(kp->ki_ocomm, "idle", strlen("idle")) == 0) {
+			/*got one*/
+			struct hrProcessorTblEntry *entry = NULL;
+			
+			HR_DPRINTF((stderr, "%s proc with pid %d is on CPU #%d (last on #%d)\n",
+				kp->ki_ocomm, kp->ki_pid, kp->ki_oncpu,kp->ki_lastcpu));
+				
+			
+			entry = hrProcessorTblEntry_find_by_cpu_no(kp->ki_lastcpu);
+			
+			assert(entry != NULL); /*what? FIX ME!*/
+			if (entry == NULL) {
+				continue;
+			}
+			
+			entry->idle_pid = kp->ki_pid;
+			
+			HR_DPRINTF((stderr, "CPU no. %d with SNMP index=%d has idle PID %d\n ", 
+				entry->cpu_no, 
+				entry->index,
+				entry->idle_pid));
+				
+
+			entry->samples[entry->cur_sample_idx] = (double)100.0 - hrProcessor_getpcpu(plist);
+			/*this is fisrt time, thus no previous samples*/
+			entry->load = (int)floor(entry->samples[entry->cur_sample_idx]); 
+			entry->cur_sample_idx = (entry->cur_sample_idx + 1) % MAX_CPU_SAMPLES;
+			
+		}
+		
+	}
+
+}
+        
+ /*
+ * Init the things for hrProcessorTable 
+ */
+void init_hrProcessor_tbl_v(void) {
+	struct 
+	deviceNameMapEntry	*map = NULL;
+	struct
+	hrProcessorTblEntry	*entry = NULL;
+	int cpu_no = -1;
+	
+	hrState_g.detected_processor_count = 0;
+	/*
+	 * Because hrProcessorTable depeneds on hrDeviceTable,
+	 * the device detection must be performed at this point
+	 * If not, no entries will be present in the hrProcessor Table
+	 */ 
+	STAILQ_FOREACH(map, &hrState_g.device_name_map, link) {
+	if (strncmp((const char*)map->name_key, "cpu", strlen("cpu")) == 0 && 
+	    strstr((const char*)map->location_key, ".CPU") != NULL) {
+		if (sscanf((const char*)map->name_key,"cpu%d", &cpu_no) != 1) {
+			syslog(LOG_ERR, 
+			"hrProcessorTable: Failed to get cpu no. from device named \"%s\"",
+			map->name_key);
+			continue;
+		}
+		
+		entry = (struct	hrProcessorTblEntry *)malloc(sizeof(*entry));		
+		if (entry == NULL) {
+			syslog(LOG_ERR, 
+			"hrProcessorTable: %s malloc failed: %m", __func__);
+			continue; /*next time?*/
+		}
+		memset(entry, 0, sizeof(*entry));
+		
+		entry->index = map->hrIndex;
+		entry->load = 0;
+		entry->cpu_no = (u_char)cpu_no; 
+		entry->idle_pid = 0;
+		entry->frwId = oid_zeroDotZero; /*unknown id - FIX ME*/
+
+		INSERT_OBJECT_INT(entry, &hrState_g.hr_processor_tbl);
+		
+		hrState_g.detected_processor_count++;
+		
+		HR_DPRINTF((stderr, "CPU %d added with SNMP index=%d\n ", 
+			entry->cpu_no, 
+			entry->index));
+		
+	}
+	}
+	HR_DPRINTF((stderr, "%s: %d CPUs detected\n", __func__, 
+		hrState_g.detected_processor_count));
+
+	hrProcessor_get_pids_v();	
+	 
+}
+
+
+/*
+ * Finalization routine for hrProcessorTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrProcessor_tbl_v(void) {
+	struct hrProcessorTblEntry *n1 = NULL, *n2 = NULL;			
+	n1 = TAILQ_FIRST(&hrState_g.hr_processor_tbl);
+	while (n1 != NULL) {
+		n2 = TAILQ_NEXT(n1, link);
+		free(n1);
+		n1 = n2;
+		hrState_g.detected_processor_count--;
+	}
+	assert(hrState_g.detected_processor_count == 0);
+	hrState_g.detected_processor_count = 0;
+	TAILQ_INIT(&hrState_g.hr_processor_tbl);
+
+}
+
+
+
+static 
+void hrProcessor_refill_tbl(void) {
+	if(hrState_g.hw_ncpu <= 0){
+		size_t size = sizeof(hrState_g.hw_ncpu);
+		if (sysctlbyname("hw.ncpu", &hrState_g.hw_ncpu, &size, NULL, 0) < 0 ||
+		    size != sizeof(hrState_g.hw_ncpu)) {
+			syslog(LOG_ERR, "hrProcessorTable: sysctl(hw.ncpu) failed");
+			hrState_g.hw_ncpu = 0;		
+			return;
+		}
+	}
+	if( hrState_g.hw_ncpu != hrState_g.detected_processor_count) {
+		fini_hrProcessor_tbl_v();
+		init_hrProcessor_tbl_v();
+	}	
+	
+}
+
+static
+struct hrProcessorTblEntry *
+hrProcessorTblEntry_find_by_index(int32_t idx) {
+
+	struct hrProcessorTblEntry *entry = NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_processor_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+void get_cpus_samples(void* arg __unused) {
+	
+	HR_DPRINTF((stderr, "[hrProcessorTable] [%llu]: ENTER\n ", get_ticks()));
+	refresh_hrProcessor_tbl_v();	
+	HR_DPRINTF((stderr, "[hrProcessorTable] [%llu]: EXIT\n ", get_ticks() ));	
+}
+
+
+void refresh_hrProcessor_tbl_v(void) {
+	struct hrProcessorTblEntry *entry = NULL;
+	int need_pids = 0;
+	
+	hrProcessor_refill_tbl();
+	
+	TAILQ_FOREACH(entry, &hrState_g.hr_processor_tbl, link) {
+		struct kinfo_proc *plist =  NULL;
+		int nproc =  -1;
+	
+		if (entry->idle_pid <= 0) {
+			need_pids = 1;
+			continue;
+		} 
+		
+		assert(hrState_g.kd != NULL);
+		
+		plist = kvm_getprocs(hrState_g.kd, KERN_PROC_PID, entry->idle_pid, &nproc);
+		if (plist == NULL || nproc != 1) {
+			syslog(LOG_ERR, "hrProcessorTable: %s: missing item with PID = %d for CPU #%d\n ", 
+					__func__, 
+					 entry->idle_pid,
+					 entry->cpu_no);
+			need_pids = 1;					 
+			continue;
+		}
+		entry->samples[entry->cur_sample_idx] = (double)100.0 - hrProcessor_getpcpu(plist);
+		entry->load = get_avg_load(entry);
+		entry->cur_sample_idx = (entry->cur_sample_idx + 1) % MAX_CPU_SAMPLES;
+		
+	}
+	if (need_pids == 1) {
+		hrProcessor_get_pids_v();
+	}
+	
+	hrState_g.hr_device_tick = this_tick;			
+	hrState_g.hrDevice_tbl_age = time(NULL);
+	
+	
+}
+
+int op_hrProcessorTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrProcessorTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+	
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_processor_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrProcessorTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+	  case LEAF_hrProcessorFrwID:
+	  	value->v.oid = entry->frwId;
+	  	break;	
+	  case LEAF_hrProcessorLoad:
+	  	value->v.integer = entry->load;
+	  	break;	
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_scalars.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_scalars.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_scalars.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_scalars.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,672 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB scalars implementation for SNMPd.
+ */
+#include "hostres_snmp.h" 
+#include "hostres_tree.h"
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <sys/sysctl.h>
+#include <syslog.h>
+#include <utmp.h>
+#include <pwd.h>
+
+/*
+ * Get system uptime in hundredths of seconds since the epoch
+ * Returns 0 in case of an error  
+ */
+static 
+uint32_t OS_getSystemUptime(void);
+
+
+/*
+ * Get system local date and time in a foramt suitable for DateAndTime TC:
+            field  octets  contents                  range
+            -----  ------  --------                  -----
+              1      1-2   year*                     0..65536
+              2       3    month                     1..12
+              3       4    day                       1..31
+              4       5    hour                      0..23
+              5       6    minutes                   0..59
+              6       7    seconds                   0..60
+                           (use 60 for leap-second)
+              7       8    deci-seconds              0..9
+              8       9    direction from UTC        '+' / '-'
+              9      10    hours from UTC*           0..13
+             10      11    minutes from UTC          0..59
+
+            * Notes:
+            - the value of year is in network-byte order
+            - daylight saving time in New Zealand is +13
+
+            For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be
+            displayed as:
+
+                             1992-5-26,13:30:15.0,-4:0
+ 
+ * Returns -1 in case of an error or the length of the string (8 or 11)
+ * Actually returns always 11 on freebsd 
+ */
+static
+int OS_getSystemDate(u_char s_date_time[11]);
+
+/*
+ * Get kernel boot path. For FreeBSD it seems that no arguments are present.
+ * Returns NULL if an error occured. The returned data is a pointer to a global strorage
+ */
+ 
+u_char* OS_getSystemInitialLoadParameters(void);
+
+/*
+ * Get number of current users which are logged in 
+ * Returns -1 in case of an error
+ */
+static 
+int OS_getSystemNumUsers(void);
+
+/*
+ * Get number of current processes existing into the system
+ * Returns -1 in case of an error
+ */
+static 
+int OS_getSystemProcesses(void);
+
+/*
+ * Get maximum number of processes allowed on this system
+ * Returns -1 in case of an error
+ */
+static
+int OS_getSystemMaxProcesses(void);
+
+/*
+ * Get the physical memeory size in Kbytes
+ * Returns 0 in case of an error.
+ */
+static 
+uint32_t OS_getMemorySize(void);
+
+/*
+ * Try to use the s_date_time parameter as a DateAndTime TC to fill in
+ * the second paramter. 
+ * Returns 0 on succes an < 0 for an error.
+ * Bug: time zone info is not used
+ */
+static 
+int OS_checkSystemDateInput(u_char s_date_time[11], struct timeval* out);
+/*
+ * Set system date and time. Timezone is not changed
+ * Return 0 for success, < 0 for an error
+ */
+static
+int OS_setSystemDate(struct timeval* timeval_to_set);
+/*
+ * prototype of this function was genrated by gensnmptree tool in header file 
+ * hostres_tree.h
+ * Returns SNMP_ERR_NOERROR on success
+*/
+int op_hrSystem(struct snmp_context *ctx, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op)
+{
+	
+
+        if(curr_op == SNMP_OP_GET){
+		switch (value->var.subs[sub - 1]) {
+			case LEAF_hrSystemUptime:
+				value->v.uint32 = OS_getSystemUptime();
+			break;
+
+			case LEAF_hrSystemDate: {
+				u_char s_date_time[11];
+				int s_date_time_len = -1;
+				if((s_date_time_len = OS_getSystemDate(s_date_time)) < 0) {
+					return (SNMP_ERR_GENERR);
+				}
+				return (string_get(value, s_date_time, s_date_time_len));
+			}
+	  
+			case LEAF_hrSystemInitialLoadDevice:
+				value->v.uint32 = 0; /*FIX ME*/
+			break;
+	  
+			case LEAF_hrSystemInitialLoadParameters: {
+				u_char *sys_load_param = NULL;
+				if((sys_load_param = OS_getSystemInitialLoadParameters()) != NULL) {
+					return (string_get(value, sys_load_param, -1));
+				}else{
+					return (SNMP_ERR_GENERR);
+				}
+	  		}
+			case LEAF_hrSystemNumUsers: {
+				int num_users = OS_getSystemNumUsers();
+				if( num_users >= 0 ) {
+					value->v.uint32 = num_users;
+				}else{
+					return (SNMP_ERR_GENERR);
+				}	
+			}			
+			break;
+	  
+			case LEAF_hrSystemProcesses: {
+				int num_proc = OS_getSystemProcesses();
+				if( num_proc >= 0 ) {
+					value->v.uint32 = num_proc;
+				}else{
+					return (SNMP_ERR_GENERR);
+				}
+			}	
+			break;
+	  
+			case LEAF_hrSystemMaxProcesses: {
+				int max_proc = OS_getSystemMaxProcesses();
+				if( max_proc >= 0 ){
+					value->v.uint32 = max_proc;
+				}else{
+					return (SNMP_ERR_GENERR);
+				}
+			}	
+			break;
+	  
+			default:{
+				assert(0);
+				return  (SNMP_ERR_GENERR);
+			}	
+
+		}/*end switch*/
+	} else if(curr_op == SNMP_OP_SET ) {
+
+		switch (value->var.subs[sub - 1]) {
+			case LEAF_hrSystemDate: {
+				if (  string_save(value, ctx, 8, 
+				       &hrState_g.time_to_set ) == SNMP_ERR_NOERROR  
+					||  
+				      string_save(value, ctx, 11, 
+				       &hrState_g.time_to_set ) == SNMP_ERR_NOERROR 
+				 ) {
+				
+					if( OS_checkSystemDateInput( hrState_g.time_to_set, 
+							&hrState_g.timeval_to_set) != 0 ) {
+						HR_DPRINTF((stderr, 
+						            "Parse for '%s' failed as DateAndTime \n", 
+							    hrState_g.time_to_set));
+		                		return  (SNMP_ERR_GENERR);
+					}
+				}
+				return (SNMP_ERR_NOERROR);
+			
+			}
+			case LEAF_hrSystemInitialLoadDevice:
+			case LEAF_hrSystemInitialLoadParameters:
+			default: {
+				/*not implmeted yet*/
+				assert(0);
+                		return  (SNMP_ERR_GENERR);
+
+			}
+			
+		}
+	} else if (curr_op == SNMP_OP_ROLLBACK ) {
+		switch (value->var.subs[sub - 1]) { 
+			case LEAF_hrSystemDate: {
+				HR_DPRINTF((stderr, "SNMP_OP_ROLLBACK for LEAF_hrSystemDate\n"));
+				string_rollback(ctx, &hrState_g.time_to_set);
+				hrState_g.timeval_to_set.tv_sec = 0;
+				hrState_g.timeval_to_set.tv_usec = 0;
+				return (SNMP_ERR_NOERROR);
+			}
+			
+			case LEAF_hrSystemInitialLoadDevice:
+			case LEAF_hrSystemInitialLoadParameters:
+			default: {
+				/*not implmeted yet*/
+				assert(0);
+                		return  (SNMP_ERR_GENERR);
+
+			}
+		}
+
+	} else if (curr_op == SNMP_OP_COMMIT ) {
+		switch (value->var.subs[sub - 1]) { 
+			case LEAF_hrSystemDate: {
+				HR_DPRINTF((stderr, 
+				  "SNMP_OP_COMMIT for LEAF_hrSystemDate\n"));
+				string_commit(ctx);
+				if( OS_setSystemDate(&hrState_g.timeval_to_set) != 0 ) {
+					HR_DPRINTF((stderr, 
+					 "SNMP_OP_COMMIT  FAILEDfor LEAF_hrSystemDate\n"));
+					return (SNMP_ERR_GENERR);
+				}
+				return (SNMP_ERR_NOERROR);
+			}
+			
+			case LEAF_hrSystemInitialLoadDevice:
+			case LEAF_hrSystemInitialLoadParameters:
+			default: {
+				/*not implmeted yet*/
+				assert(0);
+                		return  (SNMP_ERR_GENERR);
+
+			}
+		}
+	
+	} else{
+		/*get next*/
+		HR_DPRINTF((stderr, "SNMP_OP_GETNEXT meaningless for scalars \n"));	
+		return  (SNMP_ERR_GENERR);
+	}
+        return (SNMP_ERR_NOERROR);
+}
+
+/*
+ * prototype of this function was genrated by gensnmptree tool in the header file 
+ * hostres_tree.h
+ * Returns SNMP_ERR_NOERROR on success
+ */
+int op_hrStorage(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op)
+{
+	/*only GET is possible*/
+	switch (curr_op) {
+	
+		case SNMP_OP_GET:
+		break;
+ 		case SNMP_OP_SET:	
+			return (SNMP_ERR_NOT_WRITEABLE);
+		case SNMP_OP_ROLLBACK:
+		case SNMP_OP_COMMIT:
+		case SNMP_OP_GETNEXT:
+	  	default: {
+			assert(0);
+                	return  (SNMP_ERR_GENERR);
+		}	
+	}/*end switch*/
+
+	switch (value->var.subs[sub - 1]) {
+		case LEAF_hrMemorySize:{
+		        uint32_t phys_mem_size = OS_getMemorySize();
+			if( phys_mem_size > 0){
+				value->v.uint32 = phys_mem_size;
+			}else{
+				return  (SNMP_ERR_GENERR);
+			}
+		}	
+		break;
+
+  
+		default:{
+			assert(0);
+			return  (SNMP_ERR_GENERR);
+		}	
+
+	}/*end switch*/
+
+	return  (SNMP_ERR_NOERROR);
+}
+		
+
+/*
+ * FreeBSD specific functions zone
+ */
+
+uint32_t OS_getSystemUptime(void) {
+ 
+
+        struct timeval right_now = {0,0};
+	
+        if( hrState_g.kernel_boot == 0 ) {
+	
+		/*first time, do the sysctl*/
+		
+		struct timeval  kernel_boot_timestamp={ 0, 0 };
+		int mib[2]={ CTL_KERN, KERN_BOOTTIME };
+		size_t len = sizeof(kernel_boot_timestamp);
+		
+		if(sysctl(mib, 2, &kernel_boot_timestamp, &len, NULL, 0) == -1) {
+			syslog(LOG_ERR, "sysctl KERN_BOOTTIME failed: %m ");
+			return (0); /*error*/
+		}
+	
+		HR_DPRINTF((stderr, "Got boot timestamp from kernel:{%ld,%ld}\n",
+			kernel_boot_timestamp.tv_sec, 
+			kernel_boot_timestamp.tv_usec));
+			
+		hrState_g.kernel_boot = (kernel_boot_timestamp.tv_sec * 100) + 
+		              (kernel_boot_timestamp.tv_usec / 10000);			
+        }		     
+
+        if( gettimeofday(&right_now, NULL) < 0 ) {
+		syslog(LOG_ERR, "gettimeofday failed: %m ");
+		return (0); /*error*/		
+	}
+	
+	return ( (right_now.tv_sec * 100) + 
+	         (right_now.tv_usec / 10000) -
+		 hrState_g. kernel_boot );
+		  
+
+
+}
+
+
+
+int OS_getSystemDate(u_char s_date_time[11]) {
+	struct tm	tloc_tm;
+	time_t		tloc_time_t;
+	struct timeval	right_now = {0,0};
+	int		string_len = -1;
+
+        if( gettimeofday(&right_now, NULL) < 0 ) {
+		syslog(LOG_ERR, "gettimeofday failed: %m ");
+		return (-1); /*error*/		
+	}
+	
+	tloc_time_t = right_now.tv_sec;	
+	
+        if(localtime_r(&tloc_time_t, &tloc_tm) == NULL ) {
+		syslog(LOG_ERR, "localtime_r() failed: %m ");
+		return (-1); /*error*/			
+	}
+
+
+	s_date_time[0] = (u_char)((tloc_tm.tm_year + 1900) >> 8);
+	s_date_time[1] = (u_char)(tloc_tm.tm_year + 1900);
+	s_date_time[2] = tloc_tm.tm_mon + 1;
+	s_date_time[3] = tloc_tm.tm_mday;
+	s_date_time[4] = tloc_tm.tm_hour;
+	s_date_time[5] = tloc_tm.tm_min;
+	s_date_time[6] = tloc_tm.tm_sec;
+	s_date_time[7] = right_now.tv_usec/100000;   /*deci-seconds */
+
+	if (tloc_tm.tm_gmtoff < 0){
+        	s_date_time[8] = '-';
+	}else{
+        	s_date_time[8] = '+';
+	}
+	s_date_time[9] =  (u_char)(abs(tloc_tm.tm_gmtoff) / 3600);
+	s_date_time[10] = (u_char)((abs(tloc_tm.tm_gmtoff) - s_date_time[9] * 3600) / 60);
+	string_len = 11;
+
+ 	return (string_len);
+
+}
+
+u_char*
+OS_getSystemInitialLoadParameters(void){
+
+	
+	if( strlen(hrState_g.k_boot_line) == 0) {
+	        int mib[2]={ CTL_KERN, KERN_BOOTFILE };	
+	        char *buf = NULL;
+	        size_t buf_len = 0;
+		
+		
+		/*get the needed buffer len */
+		if(sysctl(mib, 2, NULL, &buf_len, NULL, 0) != 0){
+			syslog(LOG_ERR, "sysctl({CTL_KERN,KERN_BOOTFILE}) failed: %m ");
+			return (NULL); /*error*/		
+		
+		}
+		
+		buf = (char*)malloc(buf_len);
+		
+		if(buf == NULL){
+			syslog(LOG_ERR, "malloc failed ");
+			return (NULL); /*error*/		
+		}
+                if ( sysctl(mib, 2, buf, &buf_len, NULL, 0) ) {
+			syslog(LOG_ERR, "sysctl({CTL_KERN,KERN_BOOTFILE}) failed: %m ");
+			free(buf);
+			return (NULL); /*error*/		
+                }
+		
+		(void)strncpy(hrState_g.k_boot_line, buf, sizeof(hrState_g.k_boot_line) - 1);
+		HR_DPRINTF((stderr, "Got kernel boot file: %s\n", hrState_g.k_boot_line));
+		free(buf);
+	}
+	return ((u_char*)&hrState_g.k_boot_line[0]); 
+}
+
+
+
+int OS_getSystemNumUsers(void) {
+	int user_counter = 0;
+	struct utmp utmp_entry;
+
+	if( hrState_g.utmp_fp == (FILE*)NULL ) {
+		assert(0);
+		return (-1); /*error*/
+   	}
+	/*start with the begining of the utmp file*/
+	rewind(hrState_g.utmp_fp);
+	
+	while (fread(&utmp_entry, sizeof(utmp_entry), 1,  hrState_g.utmp_fp) == 1 ) {
+        	if (utmp_entry.ut_name[0] && utmp_entry.ut_line[0]) {
+			if(  getpwnam(utmp_entry.ut_name) == NULL ) {
+				continue;
+			}	
+			user_counter++;
+		}
+	}
+	return (user_counter);
+	
+}
+
+int OS_getSystemProcesses(void) {
+	int proc_count = 0;
+	
+	if( hrState_g.kd == (kvm_t*)NULL ) {
+		assert(0);
+		return (-1); /*error*/
+   	}
+	
+	if( kvm_getprocs(hrState_g.kd, KERN_PROC_ALL, 0, &proc_count) == NULL ) {
+		syslog(LOG_ERR, "kvm_getprocs failed: %m ");
+		return (-1);/*error*/
+	}
+	return (proc_count);
+}
+
+
+int OS_getSystemMaxProcesses(void) {
+	if( hrState_g.max_proc == 0 ) {
+	
+	        int mib[2] = { CTL_KERN, KERN_MAXPROC };
+        	size_t len = 0;
+        	len = sizeof(hrState_g.max_proc);
+        	if(sysctl(mib, 2, &hrState_g.max_proc, &len, NULL, 0) == -1) {
+			syslog(LOG_ERR, "sysctl KERN_MAXPROC failed: %m ");
+			return (-1); /*error*/
+	   	}
+		HR_DPRINTF((stderr, "Got kernel maxporc: %d\n", hrState_g.max_proc));
+	
+	}
+	return (hrState_g.max_proc);
+}
+
+
+uint32_t OS_getMemorySize(void) {
+	
+	if(hrState_g.phys_mem_size == 0) {
+		int mib[2] = { CTL_HW, HW_PHYSMEM };
+		size_t len = sizeof(hrState_g.phys_mem_size);
+		if (sysctl(mib, 2, &hrState_g.phys_mem_size, &len, NULL, 0) == -1) {
+			syslog(LOG_ERR, "sysctl({ CTL_HW, HW_PHYSMEM }) failed: %m ");
+			return 0; /*error*/
+		}
+		hrState_g.phys_mem_size = hrState_g.phys_mem_size / 1024;
+	}
+        return (hrState_g.phys_mem_size);
+
+}
+
+
+int OS_checkSystemDateInput(u_char s_date_time[11], struct timeval* out) {
+	struct tm 	tm_to_set;
+	time_t 		time_t_to_set;
+
+	
+	if( out == NULL ) {
+		assert(0);
+		return (-1); /*error*/
+	}
+	
+	tm_to_set.tm_year	= (( (int32_t)s_date_time[0] )<<8) + 
+					((int32_t)s_date_time[1]-1900);
+	tm_to_set.tm_mon	= (int32_t)s_date_time[2]-1;
+	tm_to_set.tm_mday	= (int32_t)s_date_time[3];
+	tm_to_set.tm_hour	= (int32_t)s_date_time[4];
+	tm_to_set.tm_min	= (int32_t)s_date_time[5];
+        tm_to_set.tm_sec	= (int32_t)s_date_time[6];
+        
+	/*the input is interpreted as local time, not UTC, not GMT*/	
+	
+	if( (time_t_to_set = mktime(&tm_to_set) ) == (time_t)-1) {
+		return (-1); /*error*/
+	}
+	out->tv_sec	= time_t_to_set; 			/*seconds*/
+	out->tv_usec	= (int32_t)s_date_time[7] * 100000; 	/*deci-seconds to micro-seconds*/
+	
+    	return ( 0 );
+	
+}
+
+int OS_setSystemDate(struct timeval* timeval_to_set) {
+	if(timeval_to_set != NULL) {
+		if( settimeofday( timeval_to_set, (struct timezone *)NULL) < 0 ) {
+			HR_DPRINTF(( stderr, "settimeofday done\n" ));
+			syslog(LOG_ERR, "settimeofday failed: %m ");
+			return (-1); /*error*/
+		}
+		return (0);
+        }
+	return (-1); /*error*/	
+}
+
+int op_hrSWRun(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op)
+{
+	/*only SNMP GET is possible*/
+	switch (curr_op) {	
+		case SNMP_OP_GET:
+		break;
+ 		case SNMP_OP_SET:	
+			return (SNMP_ERR_NOT_WRITEABLE);
+		case SNMP_OP_ROLLBACK:
+		case SNMP_OP_COMMIT:
+		case SNMP_OP_GETNEXT:
+	  	default: {
+			assert(0);
+                	return  (SNMP_ERR_GENERR);
+		}	
+	}	
+
+	switch (value->var.subs[sub - 1]) {
+		case LEAF_hrSWOSIndex:
+			value->v.uint32 = hrState_g.hrSWOSIndex;
+			return (SNMP_ERR_NOERROR);
+		default:
+			assert(0);
+			return  (SNMP_ERR_NOSUCHNAME);
+		
+	}/*end switch*/	
+		
+}
+
+
+int op_hrSWInstalled(struct snmp_context *ctx __unused, 
+                struct snmp_value *value __unused, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	/*only SNMP GET is possible*/
+	switch (curr_op) {	
+		case SNMP_OP_GET:
+		break;
+ 		case SNMP_OP_SET:	
+			return (SNMP_ERR_NOT_WRITEABLE);
+		case SNMP_OP_ROLLBACK:
+		case SNMP_OP_COMMIT:
+		case SNMP_OP_GETNEXT:
+	  	default: {
+			assert(0);
+                	return  (SNMP_ERR_GENERR);
+		}	
+	}	
+
+	switch (value->var.subs[sub - 1]) {
+		case LEAF_hrSWInstalledLastChange:{
+			
+			if (hrState_g.hr_sw_installed_change_tick <= start_tick) {
+				value->v.uint32 = 0;
+			} else {
+				uint64_t lastChange = 
+					hrState_g.hr_sw_installed_change_tick - start_tick;
+				 
+				value->v.uint32 = ( lastChange > (uint64_t)UINT_MAX ? 
+							UINT_MAX : 
+							lastChange ); /*may overflow the SNMP type*/
+  
+			}
+
+			return (SNMP_ERR_NOERROR);
+		}
+		case LEAF_hrSWInstalledLastUpdateTime: {
+			if (hrState_g.hr_sw_installed_full_upd_tick <= start_tick) {
+				value->v.uint32 = 0;
+			} else {
+				uint64_t lastUpd = 
+					hrState_g.hr_sw_installed_full_upd_tick - start_tick;
+				 
+				value->v.uint32 = ( lastUpd > (uint64_t)UINT_MAX ? 
+							UINT_MAX : 
+							lastUpd ); /*may overflow the SNMP type*/
+  
+			}
+
+			return (SNMP_ERR_NOERROR);	
+		}		
+		default:
+			assert(0);
+			return  (SNMP_ERR_NOSUCHNAME);
+		
+	}/*end switch*/	
+
+}
+
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,479 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB implementation for SNMPd.
+ */
+ 
+/* This C file contains code developed by Poul-Henning Kamp
+ * under the following license:
+ */
+ /*
+ * ----------------------------------------------------------------------------
+ * "THE BEER-WARE LICENSE" (Revision 42):
+ * <phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you
+ * can do whatever you want with this stuff. If we meet some day, and you think
+ * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
+ * ----------------------------------------------------------------------------
+ *
+ * $FreeBSD: src/sbin/mdconfig/mdconfig.c,v 1.33.2.1 2004/09/14 03:32:21 jmg Exp $
+ *
+ */
+
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+
+#include <utmp.h>
+#include <syslog.h>
+#include <paths.h> 
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mdioctl.h>
+#include <sys/linker.h>
+#include <sys/module.h>
+
+
+/*internal id got after we'll register this module with the agent */
+static 
+u_int host_registration_id = 0;
+
+/* this our hostres module */
+static 
+struct lmodule *hostres_module;
+
+static 
+const struct asn_oid oid_host = OIDX_host; /*see the generated file hostres_oid.h*/
+
+
+struct hostres_state hrState_g;
+
+static
+void
+mdmaybeload(void)
+{
+        struct module_stat mstat;
+        int fileid, modid;
+        const char *name;
+	char *cp;
+
+	name = MD_MODNAME;
+        /* scan files in kernel */
+        mstat.version = sizeof(struct module_stat);
+        for (fileid = kldnext(0); fileid > 0; fileid = kldnext(fileid)) {
+                /* scan modules in file */
+                for (modid = kldfirstmod(fileid); modid > 0;
+                     modid = modfnext(modid)) {
+                        if (modstat(modid, &mstat) < 0)
+                                continue;
+                        /* strip bus name if present */
+                        if ((cp = strchr(mstat.name, '/')) != NULL) {
+                                cp++;
+                        } else {
+                                cp = mstat.name;
+                        }
+                        /* already loaded? */
+                        if (!strcmp(name, cp))
+                                return;
+                }
+        }
+        /* not present, we should try to load it */
+        if (kldload(name) < 0) {
+		syslog(LOG_ERR,"kldload(%s) failed: %m\n", name);
+	}
+}
+
+
+/*
+ * HOST RESOURCES mib module initialization hook.
+ * Returns 0 on success, < 0 on error
+ */
+static
+int hostres_init(struct lmodule * mod, int argc __unused, char *argv[] __unused) {
+	char mddev[32] = "";
+
+	hostres_module = mod;
+	
+	/*
+	 * NOTE: order of these calls is important here!
+	 */			
+	hrState_g.utmp_fp = (FILE*)NULL;
+	hrState_g.kd      = (kvm_t*)NULL;  
+	hrState_g.kernel_boot = 0;
+
+	memset(&hrState_g.k_boot_line[0], 
+		'\0', 
+		sizeof(hrState_g.k_boot_line));
+		
+        hrState_g.max_proc = 0;
+		
+	hrState_g.phys_mem_size = 0;
+		
+	if( ( hrState_g.utmp_fp = fopen(_PATH_UTMP, "r") ) == (FILE*)NULL) {
+		syslog(LOG_ERR, "fopen(%s) failed: %m ", (const char*)_PATH_UTMP);
+		return (-1); /*error*/
+	}
+	
+	if( ( hrState_g.kd = 
+		kvm_open(NULL, _PATH_DEVNULL, NULL, O_RDONLY, "kvm_open")) == (kvm_t*)NULL )
+	{
+		syslog(LOG_ERR, "kvm_open failed: %m ");
+		return (-1); /*error*/
+	}
+	hrState_g.ata_fd = -1;
+	if ((hrState_g.ata_fd = open("/dev/ata", O_RDWR)) < 0) {
+		syslog(LOG_ERR, "open /dev/ata failed:%m");
+	}
+	
+	mdmaybeload();
+	
+	hrState_g.md_fd = -1;		
+	(void)snprintf(mddev, sizeof(mddev) - 1, "%s%s", _PATH_DEV, MDCTL_NAME);
+	if ((hrState_g.md_fd = open(mddev, O_RDWR)) < 0) {
+		syslog(LOG_ERR, "open %s failed: %m", mddev);
+	}
+	
+	if ((hrState_g.ifnet_sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		syslog(LOG_ERR,"socket(AF_INET, SOCK_DGRAM, 0) failed: %m");
+	}
+	
+	hrState_g.dev_root = NULL;
+	
+	hrState_g.hrSWOSIndex = 0;
+
+	/*data structures initialization for hrStrorageTable*/
+	hrState_g.next_hrStorage_index  = 1;
+	STAILQ_INIT(&hrState_g.storage_name_map);
+	TAILQ_INIT(&hrState_g.hr_storage_tbl);
+
+	/*data structures initialization for hrFSTable*/
+	hrState_g.next_hrFS_index  = 1;
+	STAILQ_INIT(&hrState_g.fs_name_map);
+	TAILQ_INIT(&hrState_g.hr_fs_tbl);
+	
+	/*data structure initialization for hrSWRunTable & hrSWRunTable*/
+	TAILQ_INIT(&hrState_g.hr_swrun_tbl);
+
+	/*data structures initialization for hrDeviceTable*/		
+	hrState_g.next_hrDevice_index  = 1;
+	STAILQ_INIT(&hrState_g.device_name_map);
+	TAILQ_INIT(&hrState_g.hr_device_tbl);
+
+	/*data structure initialization for hrProcessorTable*/	
+	hrState_g.detected_processor_count = 0;	
+	hrState_g.hw_ncpu = 0;
+	hrState_g.fscale = 0;				
+	hrState_g.ccpu = 0;	
+	TAILQ_INIT(&hrState_g.hr_processor_tbl);
+
+	/*data structure initialization for hrDiskStorageTable*/	
+	TAILQ_INIT(&hrState_g.hr_disk_storage_tbl);
+	hrState_g.disk_list = NULL;
+	hrState_g.disk_list_len = 0;	
+	
+	
+	/*data structures initialization for hrPartitionTable*/		
+	hrState_g.next_hrPartition_index  = 1;
+	STAILQ_INIT(&hrState_g.partition_name_map);
+	TAILQ_INIT(&hrState_g.hr_partition_tbl);
+
+
+	/*data structures initialization for hrNetworkTable*/		
+	TAILQ_INIT(&hrState_g.hr_network_tbl);
+
+	/*data structures initialization for hrSWInstalledTable*/		
+	hrState_g.next_hrSWInstalled_index  = 1;
+	STAILQ_INIT(&hrState_g.sw_installed_name_map);
+	TAILQ_INIT(&hrState_g.hr_sw_installed_tbl);
+	hrState_g.hr_sw_installed_tick = 0;
+	hrState_g.hr_sw_installed_change_tick = 0;
+	hrState_g.hrSWInstalled_tbl_age = 0;
+	hrState_g.os_pkg_last_change = 0;
+	hrState_g.hr_sw_installed_full_upd_tick = 0;
+	
+	
+	/*data structures initialization for hrPrinterTable*/			
+	TAILQ_INIT(&hrState_g.hr_printer_tbl);
+	hrState_g._printcapdb = NULL;
+	
+			
+	hrState_g.hr_storage_tick = 0;
+	hrState_g.hr_fs_tick = 0;
+	hrState_g.hr_swrun_tick = 0;
+	hrState_g.hr_device_tick = 0;
+	hrState_g.hr_processor_tick = 0;
+	hrState_g.hr_disk_storage_tick = 0;
+	hrState_g.hr_partition_tick = 0;
+	hrState_g.hr_network_tick = 0;
+	hrState_g.hr_printer_tick = 0;
+	
+	hrState_g.hrStorage_tbl_age = 0;		
+	hrState_g.hrFS_tbl_age = 0;		
+	hrState_g.hrSWRun_tbl_age = 0;	
+	hrState_g.hrDevice_tbl_age = 0;	
+	hrState_g.hrDiskStorage_age = 0;	
+	hrState_g.hrPartition_tbl_age = 0;		
+	hrState_g.hrNetwork_tbl_age = 0;	
+	hrState_g.hrPrinter_tbl_age = 0;	
+	
+	init_hrStorage_tbl_v();
+	init_hrFS_tbl_v();
+	init_hrSWRun_tbl_v(); /*also the hrSWRunPerfTable's
+			       support is initialized here */
+	init_hrDevice_tbl_v();			       
+	init_hrProcessor_tbl_v();			       			
+	
+	init_hrDiskStorage_tbl_v();	
+        init_hrPartition_tbl_v();	
+        init_hrNetwork_tbl_v();	
+
+        init_hrSWInstalled_tbl_v();	
+        init_hrPrinter_tbl_v();	
+
+	if ((hrState_g.devd_sock = create_devd_socket()) < 0) {
+		HR_DPRINTF((stderr, "Failed to create the socket to devd pipe.\n"));			
+	}
+	
+	hrState_g.devd_fd = NULL;
+
+	HR_DPRINTF((stderr, "[%s] done.\n", __func__));			
+	return (0);    
+}
+
+
+/*
+HOST RESOURCES mib module finalization hook.
+Returns 0 on success, < 0 on error
+*/
+static 
+int hostres_fini(void)
+{
+	/* here I free the resources used by this module*/
+	
+	if (hrState_g.cpus_load_timer != NULL) {
+		timer_stop(hrState_g.cpus_load_timer);
+		hrState_g.cpus_load_timer =  NULL;
+	}
+	
+	if (hrState_g.devd_fd != NULL) {
+		fd_deselect(hrState_g.devd_fd);
+		hrState_g.devd_fd = NULL;
+	}
+	
+	if (hrState_g.devd_sock > 0) {
+		close(hrState_g.devd_sock);
+	}
+	
+	if (hrState_g.ifnet_sock > 0) {	
+		close(hrState_g.ifnet_sock);
+	}
+
+	if( hrState_g.utmp_fp != (FILE*)NULL ) {
+		if( fclose(hrState_g.utmp_fp) != 0 ) {
+			syslog(LOG_ERR, "fclose failed: %m ");
+			return (-1); /*error*/
+		}
+		hrState_g.utmp_fp = (FILE*)NULL;
+	}
+	
+	if( hrState_g.kd != (kvm_t*)NULL ) {
+		if( kvm_close(hrState_g.kd) != 0 ) {
+			syslog(LOG_ERR, "kvm_close failed: %m ");
+			return (-1); /*error*/
+		}
+		hrState_g.kd = (kvm_t*)NULL;
+	}
+	
+	hrState_g.kernel_boot = 0;
+	
+	memset(&hrState_g.k_boot_line[0], 
+		'\0', 
+		sizeof(hrState_g.k_boot_line));
+		
+	hrState_g.max_proc = 0;
+	
+	hrState_g.phys_mem_size = 0;		
+
+	fini_hrStorage_tbl_v();
+	fini_hrFS_tbl_v();
+	fini_hrSWRun_tbl_v();
+	fini_hrProcessor_tbl_v();
+	fini_DiskStorage_tbl_v();
+	fini_hrDevice_tbl_v();
+	fini_hrPartition_tbl_v();
+	fini_hrNetwork_tbl_v();
+	fini_hrSWInstalled_tbl_v();
+	fini_hrPrinter_tbl_v();
+
+	hrState_g.hr_storage_tick = 0;
+	hrState_g.hr_fs_tick = 0;
+	hrState_g.hr_swrun_tick = 0;
+	hrState_g.hr_device_tick = 0;
+	hrState_g.hr_processor_tick = 0;
+	hrState_g.hr_disk_storage_tick = 0;
+	hrState_g.hr_partition_tick = 0;
+	hrState_g.hr_network_tick = 0;
+
+	hrState_g.hrStorage_tbl_age = 0;		
+	hrState_g.hrFS_tbl_age = 0;		
+	hrState_g.hrSWRun_tbl_age = 0;	
+	hrState_g.hrDevice_tbl_age = 0;
+	hrState_g.hrDiskStorage_age = 0;	
+	hrState_g.hrPartition_tbl_age = 0;	
+	hrState_g.hrNetwork_tbl_age = 0;	
+				
+	hrState_g.dev_root = NULL;
+	
+	hrState_g.hrSWOSIndex = 0;
+
+	hrState_g.hw_ncpu = 0;
+	hrState_g.fscale = 0;				
+	hrState_g.ccpu = 0;	
+	
+	hrState_g.hr_sw_installed_tick = 0;
+	hrState_g.hr_sw_installed_change_tick = 0;
+	hrState_g.hrSWInstalled_tbl_age = 0;
+	hrState_g.os_pkg_last_change = 0;
+		
+	if (hrState_g.ata_fd > 0) {
+		if (close(hrState_g.ata_fd) < 0) {
+			syslog(LOG_ERR,"close (/dev/ata) failed: %m");
+		}
+		hrState_g.ata_fd = -1;
+	}
+	if (hrState_g.md_fd > 0) {
+		if (close(hrState_g.md_fd) < 0) {
+			syslog(LOG_ERR,"close (/dev/mdctl) failed: %m");
+		}
+		hrState_g.md_fd = -1;
+	}
+	
+	if( host_registration_id > 0){
+		or_unregister(host_registration_id);
+	}	
+	
+	/*paranoia*/
+	memset(&hrState_g, 0, sizeof(hrState_g));
+	
+	HR_DPRINTF((stderr, "[%s] done.\n", __func__));
+	return (0);
+}
+
+
+
+/*
+HOST RESOURCES mib module dump function
+returns nothing
+*/
+static
+void hostres_dump_v(void) {
+	/*nothing iteresting here for the time being*/
+        HR_DPRINTF((stderr, "[%s] done.\n ", __func__));		
+}
+
+
+/*
+HOST RESOURCES mib module reconfiguration function
+returns nothing
+*/
+static
+void hostres_config_v(void) {
+	/*nothing iteresting here for the time being*/
+        HR_DPRINTF((stderr, "[%s] done.\n ", __func__));		
+}
+
+
+
+static 
+void hostres_loading_v(const struct lmodule *mod __unused, int loaded)
+{
+	/*nothing iteresting here for the time being*/
+	if ( loaded == 1 ) {
+		goto LABEL_RETURN;
+        }
+LABEL_RETURN:;	
+        HR_DPRINTF((stderr,"[%s] done.\n ", __func__));       	
+
+}
+/*
+HOST RESOURCES mib module start operation
+returns nothing
+*/
+static
+void hostres_start_v(void) {
+	host_registration_id = or_register(&oid_host, 
+	   "The MIB module for host resource mib (rfc 2790).", 
+	   hostres_module);
+	   
+	if (hrState_g.devd_sock > 0) {   
+		hrState_g.devd_fd = fd_select(hrState_g.devd_sock, devd_socket_callback, NULL, hostres_module);
+		if (hrState_g.devd_fd == NULL) {
+			syslog(LOG_ERR, "fd_select failed on devd socket: %m");
+		}
+	}   
+
+	/*
+	 * Start the cpu stats collector
+	 * The semantics of timer_start parameters is in "SNMP ticks";  
+	 * we have 100 "SNMP ticks" per second, thus we are trying below
+	 * to get MAX_CPU_SAMPLES per minute
+	 */
+	
+	hrState_g.cpus_load_timer = 
+		timer_start(100, 100*60/MAX_CPU_SAMPLES, get_cpus_samples, NULL, hostres_module);
+		
+        HR_DPRINTF((stderr, "[%s] done.\n ", __func__));       
+}
+
+/*this identifies the HOST RESOURCES mib module*/
+const struct snmp_module config = {
+	"This module implements the host resource mib (rfc 2790)",
+	hostres_init,
+	hostres_fini,
+	NULL,			/*idle function, do not use it*/
+	hostres_dump_v,		
+	hostres_config_v,		
+	hostres_start_v,
+	NULL,                   /* proxy a PDU */
+	hostres_ctree,          /* see the generated hostres_tree.h */
+	hostres_CTREE_SIZE,     /* see the generated hostres_tree.h */ 
+	hostres_loading_v
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.h BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.h
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.h	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_snmp.h	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,834 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd.
+ */
+#ifndef __HOSTRES_SNMP_H_INCLUDED__
+#define __HOSTRES_SNMP_H_INCLUDED__ 
+
+#include "asn1.h"
+#include "snmp.h"
+#include "snmpmod.h"
+#include <stdio.h>	/*for FILE */
+#include <fcntl.h>	/*for kvm_open & friends*/
+#include <kvm.h>
+#include <sys/queue.h>  /*for SLIST, TAILQ & friends*/
+
+#include <sys/param.h>  /*for getfsstat*/
+#include <sys/ucred.h>	/*for getfsstat*/
+#include <sys/mount.h>	/*for getfsstat*/
+
+#include <sys/vmmeter.h> 
+#include <devinfo.h>
+
+
+/*a debug macro*/
+#ifndef NDEBUG
+#define	HR_DPRINTF(ARGS) do {					\
+	fprintf(stderr, "HRDEBUG: ");				\
+	fprintf ARGS;						\
+   } while (0)
+#else
+#define HR_DPRINTF(ARGS)
+#endif /*NDEBUG*/
+
+#define	IS_KERNPROC(kp)	( ((kp)->ki_flag & P_KTHREAD) == P_KTHREAD )
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrStorageTable
+ */
+
+struct hrStorageTblEntry {
+	int32_t		index;
+	struct asn_oid	type;
+	u_char		descr[255+1];
+	int32_t		allocationUnits;
+	int32_t		size;
+	int32_t		used;	 
+	uint32_t	allocationFailures;	 
+#define HR_STORAGE_FOUND 0x001	
+	uint32_t	flags;	/*not from the SNMP mib table, only to be used internally*/
+	TAILQ_ENTRY(hrStorageTblEntry) link;	
+};
+
+TAILQ_HEAD(storage_tbl, hrStorageTblEntry);
+
+
+
+/*
+ * Next structure is used to keep o list of mappings from a specific
+ * name (a_name) to an entry in the hrStorageTblEntry;
+ * We are trying to keep the same index for a specific name at least
+ * for the duration of one SNMP agent run
+ */
+struct storageNameMapEntry {
+	int32_t		hrIndex;		/*used for hrStorageTblEntry::index*/
+	u_char		a_name[255+1];		/*map key, also used for hrStorageTblEntry::descr*/
+	
+	/*
+	 * next may be NULL if the respective hrStorageTblEntry 
+	 * is (temporally) gone
+	 */
+	struct hrStorageTblEntry		*entry_p; 
+	STAILQ_ENTRY(storageNameMapEntry) 	link;
+};
+
+STAILQ_HEAD(storage_map_list, storageNameMapEntry);
+
+enum hrFSAccess {
+	FS_READ_WRITE = 1,
+	FS_READ_ONLY  = 2
+};
+
+enum snmpTCTruthValue {
+	SNMP_TRUE = 1,
+	SNMP_FALSE= 2
+};
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrFSTable
+ */
+struct hrFSTblEntry {
+	int32_t		index;
+	u_char		mountPoint[128+1];
+	u_char		remoteMountPoint[128+1];
+	struct asn_oid	type;
+	int32_t		access;			/* enum hrFSAccess, see above */
+	int32_t		bootable;		/* enum snmpTCTruthValue, see above */
+	int32_t		storageIndex;		/* hrStorageTblEntry::index */
+	u_char		lastFullBackupDate[11];
+	u_char		lastPartialBackupDate[11];	
+#define HR_FS_FOUND 0x001
+	uint32_t	flags;			/*not from the SNMP mib table, only to be used internally*/	
+	TAILQ_ENTRY(hrFSTblEntry) link;		
+};
+
+TAILQ_HEAD(fs_tbl, hrFSTblEntry);
+
+
+/*
+ * Next structure is used to keep o list of mappings from a specific
+ * name (a_name) to an entry in the hrFSTblEntry;
+ * We are trying to keep the same index for a specific name at least
+ * for the duration of one SNMP agent run
+ */
+struct FSNameMapEntry {
+	int32_t		hrIndex;		/*used for hrFSTblEntry::index*/
+	u_char		a_name[128+1];		/*map key*/
+	
+	/*
+	 * next may be NULL if the respective hrFSTblEntry 
+	 * is (temporally) gone
+	 */
+	struct 
+	hrFSTblEntry	*entry_p; 
+	STAILQ_ENTRY(FSNameMapEntry) 	link;
+};
+
+STAILQ_HEAD(fs_map_list, FSNameMapEntry);
+
+
+enum SWRunType {
+	SRT_UNKNOWN		=	1,
+	SRT_OPERATING_SYSTEM	=	2,
+	SRT_DEVICE_DRIVER	=	3,
+	SRT_APPLICATION		=	4
+	
+};
+
+enum SWRunStatus {
+	SRS_RUNNING		=	1,
+	SRS_RUNNABLE		=	2,
+	SRS_NOT_RUNNABLE	=	3,
+	SRS_INVALID		=	4
+};
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for both hrSWRunTable and hrSWRunPerfTable because
+ * hrSWRunPerfTable AUGMENTS hrSWRunTable
+ */
+struct hrSWRunTblEntry {
+	int32_t		index;
+	u_char		name[64+1];
+	struct asn_oid	id;
+	u_char		path[128+1];
+	u_char		parameters[128+1];
+	int32_t		type;			/* one item from enum SWRunType, see above */
+	int32_t		status;			/* one item from enum SWRunStatus, see above */
+	int32_t		perfCPU;
+	int32_t		perfMemory;	
+#define HR_SWRUN_FOUND 0x001
+	uint32_t	flags;			/*not from the SNMP mib table, only to be used internally*/
+	uint64_t	r_tick;			/*agent tick when this entry was last time refreshed*/
+	TAILQ_ENTRY(hrSWRunTblEntry) link;		
+};
+
+TAILQ_HEAD(swrun_tbl, hrSWRunTblEntry);
+
+/*
+ * The number of CPU load samples per one minute,
+ * per each CPU
+ */
+#define MAX_CPU_SAMPLES 4
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrProcessorTable
+ * Note that index is external being allocated & maintained 
+ * by the hrDeviceTable code.
+ */
+
+struct	hrProcessorTblEntry {
+	int32_t		index;
+	struct asn_oid	frwId;
+	int32_t		load;
+	TAILQ_ENTRY(hrProcessorTblEntry) link;
+	/*not from SNMP table definition, only used internally*/
+	u_char 		cpu_no;		/*which cpu, counted from 0*/
+	pid_t		idle_pid;	/*the PID of idle process for this CPU */
+	double		samples[MAX_CPU_SAMPLES]; /*the samples from the last 
+						    minute, as required by MIB*/
+	uint32_t	cur_sample_idx;		  /*current sample to fill in next time,
+						    must be < MAX_CPU_SAMPLES*/
+};
+
+TAILQ_HEAD(processor_tbl, hrProcessorTblEntry);
+
+enum hrDiskStrorageAccess {
+	DS_READ_WRITE = 1,
+	DS_READ_ONLY  = 2
+};
+
+enum hrDiskStrorageMedia {
+	DSM_OTHER	=	1,
+	DSM_UNKNOWN	=	2,
+	DSM_HARDDISK	=	3,
+	DSM_FLOPPYDISK	=	4,
+	DSM_OPTICALDISKROM=	5,
+	DSM_OPTICALDISKWORM=	6,
+	DSM_OPTICALDISKRW=	7,
+	DSM_RAMDISK	=	8
+};
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrDiskStorageTable
+ * Note that index is external being allocated & maintained 
+ * by the hrDeviceTable code.
+ * NOTE: according to MIB removable means removable media, not the 
+ * device itself (like a USB card reader)
+ */
+struct hrDiskStorageTblEntry {
+	int32_t		index;
+	int32_t		access; /*enum hrDiskStrorageAccess */
+	int32_t		media;	/*enum hrDiskStrorageMedia*/
+	int32_t		removable; /*enum snmpTCTruthValue*/
+	int32_t		capacity; 
+	TAILQ_ENTRY(hrDiskStorageTblEntry) link;	
+	/*next items are not from the SNMP mib table, only to be used internally*/
+#define HR_DISKSTORAGE_FOUND		0x001	
+#define HR_DISKSTORAGE_ATA		0x002 /*belongs to the ATA subsystem*/		
+#define HR_DISKSTORAGE_MD		0x004 /*it is a MD (memory disk) */		
+	uint32_t	flags;	
+	uint64_t	r_tick;
+	u_char		dev_name[32];	/*device name, i.e. "ad4" or "acd0"*/	
+	
+};
+
+TAILQ_HEAD(disk_storage_tbl, hrDiskStorageTblEntry);
+
+struct hrPartitionTblEntry {
+	struct asn_oid	index;
+	u_char		label[128+1];
+	u_char		id[128+1];
+	int32_t		size;
+	int32_t		fs_Index;
+	TAILQ_ENTRY(hrPartitionTblEntry) link;		
+#define HR_PARTITION_FOUND		0x001	
+	uint32_t	flags;
+};
+
+TAILQ_HEAD(partition_tbl, hrPartitionTblEntry);
+
+struct PartitionNameMapEntry {		
+	int32_t		index;		/*this is hrPartitionTblEntry::index*/
+	u_char		id[128+1];		
+	
+	/*
+	 * next may be NULL if the respective  hrPartitionTblEntry
+	 * is (temporally) gone
+	 */
+	struct 
+	hrPartitionTblEntry	*entry_p; 
+	STAILQ_ENTRY(PartitionNameMapEntry) 	link;
+};
+STAILQ_HEAD(partition_map_list, PartitionNameMapEntry);
+
+
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrNetworkTable
+ */
+
+struct hrNetworkTblEntry {
+	int32_t		index;
+	int32_t		ifIndex;
+	TAILQ_ENTRY(hrNetworkTblEntry) link;		
+#define HR_NETWORK_FOUND		0x001	
+	uint32_t	flags;
+	
+};
+TAILQ_HEAD(network_tbl, hrNetworkTblEntry);
+
+
+enum PrinterStatus {
+	PS_OTHER	=	1,
+	PS_UNKNOWN	=	2,
+	PS_IDLE		=	3,
+	PS_PRINTING	=	4,
+	PS_WARMUP	=	5		
+};
+
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrPrinterTable
+ */
+
+struct hrPrinterTblEntry {
+	int32_t		index;
+	int32_t		status;  /*values from PrinterStatus enum above*/
+	u_char		detectedErrorState[2];
+	TAILQ_ENTRY(hrPrinterTblEntry) link;		
+#define HR_PRINTER_FOUND		0x001	
+	uint32_t	flags;
+	
+};
+TAILQ_HEAD(printer_tbl, hrPrinterTblEntry);
+
+
+
+
+
+enum DeviceStatus {
+	DS_UNKNOWN	=	1,
+	DS_RUNNING	=	2,
+	DS_WARNING	=	3,
+	DS_TESTING	=	4,
+	DS_DOWN		=	5		
+};
+
+
+
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrDeviceTable
+ */
+struct hrDeviceTblEntry {
+	int32_t		index;
+	struct asn_oid	type;
+	u_char		descr[64+1];
+	struct asn_oid	id;
+	int32_t		status;		/* one item from enum DeviceStatus, see above */
+	uint32_t	errors;
+
+#define HR_DEVICE_FOUND		0x001
+#define HR_DEVICE_IMMUTABLE	0x002  /* not dectected by libdevice, so don't try to refresh it*/
+	/*next 3 are not from the SNMP mib table, only to be used internally*/
+	uint32_t	flags;		
+	u_char		name[32+1];	
+	u_char		location[128+1];	
+	TAILQ_ENTRY(hrDeviceTblEntry) link;		
+};
+
+TAILQ_HEAD(device_tbl, hrDeviceTblEntry);
+
+
+/*
+ * Next structure is used to keep o list of mappings from a specific
+ * name (a_name) to an entry in the hrFSTblEntry;
+ * We are trying to keep the same index for a specific name at least
+ * for the duration of one SNMP agent run
+ */
+struct deviceNameMapEntry {
+	int32_t		hrIndex;		/*used for hrDeviceTblEntry::index*/
+	/*map key is the pair (name_key, location_key)*/
+	u_char		name_key[32+1];		/*map key*/
+	u_char		location_key[128+1];	/*map key*/	
+	/*
+	 * next may be NULL if the respective hrDeviceTblEntry 
+	 * is (temporally) gone
+	 */
+	struct 
+	hrDeviceTblEntry	*entry_p; 
+	STAILQ_ENTRY(deviceNameMapEntry) 	link;
+};
+
+STAILQ_HEAD(device_map_list, deviceNameMapEntry);
+
+
+enum SWInstalledType {
+	SWI_UNKNOWN	=	1,
+	SWI_OPERATING_SYSTEM	=	2,
+	SWI_DEVICE_DRIVER	=	3,
+	SWI_APPLICATION	=	4
+};
+
+
+/*
+ * This structure is used to hold a SNMP table entry
+ * for HOST-RESOURCES-MIB's hrSWInstalledTable
+ */
+struct hrSWInstalledTblEntry {
+	int32_t		index;
+	u_char		name[64+1];
+	struct asn_oid	id;	
+	int32_t		type;		/* one item from enum SWInstalledType, see above */
+	u_char		date[11];
+#define HR_SWINSTALLED_FOUND		0x001
+#define HR_SWINSTALLED_IMMUTABLE	0x002
+	/*next items are not from the SNMP mib table, only to be used internally*/
+	uint32_t	flags;		
+	TAILQ_ENTRY(hrSWInstalledTblEntry) link;		
+};
+
+TAILQ_HEAD(sw_installed_tbl, hrSWInstalledTblEntry);
+
+
+struct SWInstalledNameMapEntry {
+	int32_t		hrIndex;		/*used for hrSWInstalledTblEntry::index*/
+	u_char		name[64+1];		/*map key*/
+
+	/*
+	 * next may be NULL if the respective hrSWInstalledTblEntry 
+	 * is (temporally) gone
+	 */
+	struct 
+	hrSWInstalledTblEntry	*entry_p; 
+	STAILQ_ENTRY(SWInstalledNameMapEntry) 	link;
+};
+
+STAILQ_HEAD(sw_installed_map_list, SWInstalledNameMapEntry);
+
+struct hostres_state {
+	FILE		*utmp_fp;		/*file pointer to keep an open instance of utmp*/
+	kvm_t		*kd;			/*kernel descriptor*/
+	uint32_t	kernel_boot;		/*boot timestamp in centi-seconds*/
+	char 	 	k_boot_line[128 + 1];	/*kernel boot line*/
+	int 		max_proc;		/*maximum number of processes */
+	uint32_t	phys_mem_size;		/*physical memory size in Kb*/
+	
+	u_char 		*time_to_set;		/*for setting hrSystemDate*/
+	struct timeval	timeval_to_set;		/*for setting hrSystemDate*/	
+	
+	/* 
+	 * next items are used for hrStorageTable 
+	 */
+	struct 
+	storage_map_list storage_name_map;	/*for consistent table indexing*/
+	
+	struct 
+	storage_tbl	hr_storage_tbl;		/*the head of the list with table's entries */
+	uint64_t 	hr_storage_tick;	/*last (agent) tick when hrStorageTable was updated */
+	struct kvm_swap *swap_devs;		/*for kvm_getswapinfo, malloc'd*/
+	size_t		swap_devs_len;		/*item count for swap_devs */ 
+	struct statfs	*fs_buf;		/*for getfsstat, malloc'd*/
+	size_t		fs_buf_count;		/*item count for fs_buf */	
+	struct vmtotal	mem_stats;
+	uint32_t 	next_hrStorage_index;	/*next int available for indexing the hrStorageTable*/
+	time_t		hrStorage_tbl_age; 
+	
+	/* 
+	 * next items are used for hrFSTable 
+	 */
+	struct 
+	fs_map_list	fs_name_map;		/*for consistent table indexing*/
+	
+	struct fs_tbl	hr_fs_tbl;		/*the head of the list with hrFSTable's entries */	
+	uint32_t 	next_hrFS_index;	/*next int available for indexing the hrFSTable*/
+	time_t		hrFS_tbl_age; 
+	uint64_t 	hr_fs_tick;		/*last (agent) tick when hrFSTable was updated */
+	
+	/* 
+	 * next items are used for both hrSWRunTable and hrSWRunPerfTable
+	 */
+	struct 
+	swrun_tbl	hr_swrun_tbl;		/*the head of the list with hrSWRunTable's entries */
+
+	time_t		hrSWRun_tbl_age; 
+	uint64_t 	hr_swrun_tick;		/*last (agent) tick when hrSWRunTable and hrSWRunPerTable 
+						  were updated */
+	int32_t		hrSWOSIndex;		/* the value of the MIB object with the same name*/	
+	
+	/* 
+	 * next items are used for hrDeviceTable 
+	 */
+	struct 
+	device_map_list	device_name_map;	/*for consistent table indexing*/
+	
+	struct 
+	device_tbl	hr_device_tbl;		/*the head of the list with hrDeviceTable's entries */	
+	uint32_t 	next_hrDevice_index;	/*next int available for indexing the hrDeviceTable*/
+	time_t		hrDevice_tbl_age; 
+	uint64_t 	hr_device_tick;		/*last (agent) tick when hrDeviceTable was updated */
+	
+	struct 
+	devinfo_dev	*dev_root;
+	
+	int 		devd_sock;		/*socket for /var/run/devd.pipe*/
+	void 		*devd_fd;		/*used to wait notifications from /var/run/devd.pipe */
+	/* 
+	 * next items are used for hrProcessorTable 
+	 */
+	struct 
+	processor_tbl	hr_processor_tbl;	/*the head of the list with hrDeviceTable's entries */	
+	int32_t		detected_processor_count;
+	int 		hw_ncpu;		/*get it via sysctlbyname(hw.ncpu)*/
+	fixpt_t		ccpu;			/* kernel _ccpu variable */
+	int		fscale;			/* kernel _fscale variable */
+	
+ 
+	uint64_t 	hr_processor_tick;	/*last (agent) tick when hrProcessorTable was updated */
+	void*		cpus_load_timer;	/*periodic time used to get cpu laod stats*/
+											  						  					  
+
+	/* 
+	 * next items are used for hrDiskStorageTable 
+	 */
+	struct 
+	disk_storage_tbl	hr_disk_storage_tbl;	/*the head of the list with hrDiskStorageTable's entries */	
+	uint64_t		hr_disk_storage_tick;
+	time_t			hrDiskStorage_age;
+	char*			disk_list;		/*returned by sysctl("kern.disks")*/
+	size_t			disk_list_len;
+	int			ata_fd;			/* fd for "/dev/ata"*/
+	int			md_fd;			/* fd for "/dev/mdctl"*/
+
+	/* 
+	 * next items are used for hrPartitionTable 
+	 */
+	struct 
+	partition_map_list	partition_name_map;	/*for consistent table indexing*/
+	
+	struct 
+	partition_tbl	hr_partition_tbl;	/*the head of the list with hrPatitionTable's entries */	
+	uint32_t 	next_hrPartition_index;	/*next int available for indexing the hrPartitionTable*/
+	time_t		hrPartition_tbl_age; 
+	uint64_t 	hr_partition_tick;	/*last (agent) tick when hrPartitionTable was updated */
+	
+	/* 
+	 * next items are used for hrNetworksTable 
+	 */
+	int 		ifnet_sock;		/*socket used to extract the interface list from the O/S*/
+	struct 
+	network_tbl	hr_network_tbl;		/*the head of the list with hrNetworkTable's entries */	
+	time_t		hrNetwork_tbl_age; 
+	uint64_t 	hr_network_tick;	/*last (agent) tick when hrNetworkTable was updated */
+
+	/* 
+	 * next items are used for hrSWInstalledTable 
+	 */
+	struct 
+	sw_installed_map_list	sw_installed_name_map;	/*for consistent table indexing*/
+	
+	struct 
+	sw_installed_tbl	hr_sw_installed_tbl;	/*the head of the list with hrSWInstalledTable's entries */	
+	uint32_t 	next_hrSWInstalled_index;	/*next int available for indexing the hrSWInstalledTable*/
+	uint64_t 	hr_sw_installed_tick;  		/*last (agent) tick when hrSWInstalledTable was updated */
+	uint64_t 	hr_sw_installed_change_tick;	/*last (agent) tick when hrDeviceTable was last changed  */
+	uint64_t 	hr_sw_installed_full_upd_tick;	/*last (agent) tick when hrDeviceTable was fully updated  */	
+
+	time_t		hrSWInstalled_tbl_age; 
+	time_t		os_pkg_last_change;
+
+	/* 
+	 * next items are used for hrSWInstalledTable 
+	 */
+
+	struct 
+	printer_tbl	hr_printer_tbl;		/*the head of the list with hrPrinterTable's entries */	
+	time_t		hrPrinter_tbl_age; 
+	uint64_t 	hr_printer_tick;	/*last (agent) tick when hrPrinterTable was updated */
+	char **		_printcapdb;
+					
+};
+
+/*
+ *  Instance to keep most of the globals related to 
+ *  HOST RESOURCES MIB implementation
+ */
+extern struct hostres_state hrState_g;
+
+
+/*
+ * Init the things for hrStorageTable.
+ */
+void init_hrStorage_tbl_v(void);
+
+/*
+ * Finalization routine for hrStorageTable.
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrStorage_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ * for hrStorageTable
+ */
+#define HR_STORAGE_TBL_REFRESH	7
+/*
+ * Refresh routine for hrStorageTable.
+ * Usable for polling the system for any changes.
+ */
+void refresh_hrStorage_tbl_v(void);
+
+
+/*
+ * Because hrFSTable depends to hrStorageTable we are 
+ * refreshing hrFSTable by refreshing hrStorageTable.
+ * When one entry "of type" fs from hrStorageTable is refreshed
+ * then the corresponding entry from hrFSTable is refreshed
+ * FS_tbl_pre_refresh_v() is called  before refeshing fs part of hrStorageTable
+ */
+void
+FS_tbl_pre_refresh_v(void);
+
+
+void 
+FS_tbl_process_statfs_entry_v(const struct statfs *fs_p, int32_t storage_idx);
+
+/*
+ * FS_tbl_pre_refresh_v() is called after refeshing fs part of hrStorageTable
+ */
+void
+FS_tbl_post_refresh_v(void);
+
+
+/*
+ * Init the things for hrFSTable.
+ */
+void init_hrFS_tbl_v(void);
+
+/*
+ * Finalization routine for hrFSTable.
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrFS_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ * for hrFSTable
+ */
+#define HR_FS_TBL_REFRESH	HR_STORAGE_TBL_REFRESH
+/*
+ * Refresh routine for hrFSTable.
+ * Usable for polling the system for any changes.
+ */
+void refresh_hrFS_tbl_v(void);
+
+/*
+ * Find an entry in hrSWRunTable (or hrSWRunPerfTable)  by its SNMP index
+ * Returns NULL if none found
+ */
+struct hrSWRunTblEntry *
+hrSWRunTblEntry_find_by_index(int32_t idx); 
+
+/*
+ * Init the things for both of hrSWRunTable and hrSWRunPerfTable
+ */
+void init_hrSWRun_tbl_v(void);
+
+/*
+ * Finalization routine for both of hrSWRunTable and hrSWRunPerfTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrSWRun_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ * for both of hrSWRunTable and hrSWRunPerfTable
+ */
+#define HR_SWRUN_TBL_REFRESH	3
+/*
+ * Refresh routine for both of hrSWRunTable and hrSWRunPerfTable
+ * Usable for polling the system for any changes.
+ */
+void refresh_hrSWRun_tbl_v(void);
+
+/*
+ * Init the things for hrDeviceTable 
+ */
+void init_hrDevice_tbl_v(void);
+
+/*
+ * Finalization routine for hrDeviceTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrDevice_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ * for hrDeviceTable
+ */
+#define HR_DEVICE_TBL_REFRESH	10
+/*
+ * Refresh routine for hrDeviceTable
+ * Usable for polling the system for any changes.
+ */
+void refresh_hrDevice_tbl_v(void);
+
+/*
+ * Creates the  sockect to devd pipe, aka
+ * /var/run/devd.pipe. Returs the socket descriptor or
+ * -1 in case of an error
+ */
+int create_devd_socket(void);
+
+/*
+ * Callback for fd_select function; called when
+ * device events are detected in order to trigger
+ * a device table refresh
+ */
+void devd_socket_callback(int, void*);
+
+/*
+ * Init the things for hrProcessorTable 
+ */
+void init_hrProcessor_tbl_v(void);
+
+/*
+ * Finalization routine for hrProcessorTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrProcessor_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ * for hrProcessorTable (only for load numbers)
+ */
+#define HR_PROCESSOR_TBL_REFRESH	5
+/*
+ * Refresh routine for hrProcessorTable
+ * Usable for polling the system for load numbers.
+ */
+void refresh_hrProcessor_tbl_v(void);
+
+/*
+ *  The timer function used to collect the CPUs load samples
+ *  Each CPU is "visited" MAX_CPU_SAMPLES times per one minute
+ */
+void get_cpus_samples(void*);
+
+/*
+ * Init the things for hrDiskStorageTable 
+ */
+void init_hrDiskStorage_tbl_v(void);
+
+/*
+ * Finalization routine for hrDiskStorageTable 
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_DiskStorage_tbl_v(void);
+
+/*
+ * Next macro represents the number of seconds
+ * between two consecutive queries to the OS for getting the new data
+ */
+#define HR_DISKSTORAGE_TBL_REFRESH	3
+/*
+ * Refresh routine for hrDiskStorageTable 
+ * Usable for polling the system for any changes.
+ */
+void refresh_DiskStorage_tbl_v(void);
+
+
+/*
+ * Init the things for hrPartitionTable 
+ */
+void init_hrPartition_tbl_v(void);
+
+/*
+ * Finalization routine for hrPartitionTable  
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrPartition_tbl_v(void);
+
+
+/*
+ * Init the things for hrNetworkTable 
+ */
+void init_hrNetwork_tbl_v(void);
+
+/*
+ * Finalization routine for hrNetworkTable 
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrNetwork_tbl_v(void);
+
+#define HR_NETWORK_TBL_REFRESH	7
+
+void refresh_hrNetwork_tbl_v(void);
+
+
+void init_hrSWInstalled_tbl_v(void);
+
+void fini_hrSWInstalled_tbl_v(void);
+
+#define HR_SWINSTALLED_TBL_REFRESH	120
+
+void refresh_hrSWInstalled_tbl_v(void);
+
+
+/*
+ * Init the things for hrPrinterTable 
+ */
+void init_hrPrinter_tbl_v(void);
+
+/*
+ * Finalization routine for hrPrinterTable
+ * It destroys the lists and frees any allocated heap memory
+ */
+void fini_hrPrinter_tbl_v(void);
+
+#define HR_PRINTER_TBL_REFRESH	7
+
+void refresh_hrPrinter_tbl_v(void);
+
+
+#endif /*__HOSTRES_SNMP_H_INCLUDED__ */
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_storage_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_storage_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_storage_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_storage_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,623 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for hrStorageTable
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <sys/sysctl.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <syslog.h>
+#include <limits.h>
+#include <string.h>
+#include <err.h>
+#include <unistd.h> /*for getpagesize()*/
+#include <vm/vm_param.h>
+#include <paths.h>
+
+static 
+const struct asn_oid OIDX_hrStorageOther_c = OIDX_hrStorageOther;
+
+static 
+const struct asn_oid OIDX_hrStorageFloppyDisk_c = OIDX_hrStorageFloppyDisk;
+
+static 
+const struct asn_oid OIDX_hrStorageCompactDisc_c = OIDX_hrStorageCompactDisc;
+
+static 
+const struct asn_oid OIDX_hrStorageFixedDisk_c = OIDX_hrStorageFixedDisk;
+
+static 
+const struct asn_oid OIDX_hrStorageRam_c = OIDX_hrStorageRam;
+
+static 
+const struct asn_oid OIDX_hrStorageVirtualMemory_c = OIDX_hrStorageVirtualMemory;
+
+static 
+const struct asn_oid OIDX_hrStorageNetworkDisk_c = OIDX_hrStorageNetworkDisk;
+
+
+static
+struct hrStorageTblEntry* 
+hrStorageTblEntry_create( const char *name ) {
+	struct hrStorageTblEntry	*entry;
+	struct storageNameMapEntry 	*map = NULL;
+
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "%s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	strncpy((char *)entry->descr, name, sizeof(entry->descr) - 1);
+
+	STAILQ_FOREACH(map, &hrState_g.storage_name_map, link)
+		if (strcmp((const char*)map->a_name, 
+			(const char*)entry->descr) == 0) {
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrStorage_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrStorageTable index wrap", __func__ );
+			errx(1, "hrStorage index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "hrStorageTable: %s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrStorage_index ++;
+		strncpy((char *)map->a_name, (char *)entry->descr, 
+			sizeof(map->a_name) - 1);
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.storage_name_map, map, link);
+		HR_DPRINTF((stderr, "%s  added into hrStorageMap at index=%d\n ", 
+		  name, 
+		  map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s  exists in hrStorageMap index=%d\n ", 
+		  name, 
+		  map->hrIndex));
+	}
+	
+	entry->index = map->hrIndex;
+
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_storage_tbl);
+	
+	return entry;
+	
+}
+
+static
+void
+hrStorageTblEntry_delete_v( struct hrStorageTblEntry* entry ) {
+	struct storageNameMapEntry  *map;
+	assert(entry != NULL);
+	
+	TAILQ_REMOVE(&hrState_g.hr_storage_tbl, entry, link);	
+	STAILQ_FOREACH(map, &hrState_g.storage_name_map, link)
+		if (map->entry_p == entry) {
+			map->entry_p = NULL;
+			break;
+		}
+	
+			
+	free(entry);
+}
+
+static
+struct hrStorageTblEntry*
+hrStorageTblEntry_find_by_name(const char *name) {
+	struct hrStorageTblEntry *entry =  NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_storage_tbl, link)
+		if (strncmp((const char*)entry->descr, name, 
+			sizeof(entry->descr) - 1) == 0)
+			return (entry);
+	return (NULL);
+}
+
+static
+struct hrStorageTblEntry *
+hrStorageTblEntry_find_by_index(int32_t idx) {
+	struct hrStorageTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_storage_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+/*
+ * Very silly implementation for VM info. 
+ * Should be changed to use libmemestat API 
+ * (Robert N M Watson has just created, not yet 
+ * available for public for the time being)
+ * FIX ME
+ */
+
+static
+void hrStorage_OS_get_vm_v(void) {
+	/*FIX ME*/
+	int mib[2] = { CTL_VM, VM_TOTAL };
+	size_t len = sizeof(hrState_g.mem_stats);
+	int page_size_bytes;
+	struct hrStorageTblEntry *entry = NULL;
+	if ( sysctl(mib, 2, &hrState_g.mem_stats, &len, NULL, 0) < 0 ) {
+		syslog(LOG_ERR,
+		  "hrStoragetable: %s: sysctl( { CTL_VM, VM_METER } ) failed: %m ", 
+		  __func__ );	
+		assert(0);
+		return;
+	}
+	
+	page_size_bytes = getpagesize();
+	
+
+	
+	/*Real Memory Metrics*/
+	entry = hrStorageTblEntry_find_by_name("Real Memory Metrics");
+	if ( entry == NULL ) {
+		entry =  hrStorageTblEntry_create("Real Memory Metrics");
+	}
+	assert(entry != NULL);
+	if ( entry == NULL) return; /*I'm out of luck now, maybe next time*/
+	
+	entry->flags |= HR_STORAGE_FOUND;
+	entry->type = OIDX_hrStorageRam_c;
+	entry->allocationUnits = page_size_bytes;
+	entry->size = hrState_g.mem_stats.t_rm;
+	entry->used = hrState_g.mem_stats.t_arm; /*ACTIVE is not USED - FIX ME */
+	entry->allocationFailures = 0;						
+
+	
+
+	/*Shared Real Memory Metrics*/
+	entry = hrStorageTblEntry_find_by_name("Shared Real Memory Metrics");
+	if ( entry == NULL ) {
+		entry =  hrStorageTblEntry_create("Shared Real Memory Metrics");
+	}
+	assert(entry != NULL);
+	if ( entry == NULL) return; /*I'm out of luck now, maybe next time*/
+	
+	entry->flags |= HR_STORAGE_FOUND;
+	entry->type = OIDX_hrStorageRam_c;
+	entry->allocationUnits = page_size_bytes;
+	entry->size = hrState_g.mem_stats.t_rmshr;
+	entry->used = hrState_g.mem_stats.t_armshr; /*ACTIVE is not USED - FIX ME */
+	entry->allocationFailures = 0;						
+	
+}
+
+
+static
+void hrStorage_OS_get_swap_v(void) {
+        int nswapdev = 0;
+	size_t len  = sizeof(nswapdev);
+	struct hrStorageTblEntry *entry;
+	char swap_w_prefix[255+1];
+	
+	if ( sysctlbyname("vm.nswapdev", &nswapdev, &len, NULL,0 ) < 0 ) {
+		syslog(LOG_ERR, 
+		"hrStorageTable: sysctlbyname(\"vm.nswapdev\") failed. %m \n");
+		assert(0);
+		return;
+	}
+	if ( nswapdev <= 0 ) {
+		HR_DPRINTF((stderr, "vm.nswapdev is %d\n ",nswapdev));
+		return;		
+	}
+	 
+	if ( nswapdev + 1 != (int)hrState_g.swap_devs_len  ||  hrState_g.swap_devs == NULL ) {
+		hrState_g.swap_devs_len = nswapdev + 1;
+		
+		hrState_g.swap_devs = 
+			(struct kvm_swap *)reallocf( hrState_g.swap_devs, 
+		        hrState_g.swap_devs_len * sizeof(struct kvm_swap));
+			
+		assert( hrState_g.swap_devs != NULL );	
+		if ( hrState_g.swap_devs == NULL ) {
+			hrState_g.swap_devs_len = 0;
+			return;
+		}
+	}
+	
+	nswapdev = kvm_getswapinfo( hrState_g.kd, hrState_g.swap_devs,hrState_g.swap_devs_len, 0);
+	
+	if ( nswapdev < 0 ) {
+		syslog(LOG_ERR,"hrStorageTable: kvm_getswapinfo failed. %m \n");	
+		assert(0);
+		return;
+	}
+	
+
+	
+	for (len = 0; len < (size_t)nswapdev; len++ ) {
+		memset(&swap_w_prefix[0], '\0', sizeof(swap_w_prefix) );
+		(void)snprintf(swap_w_prefix, sizeof(swap_w_prefix) - 1, 
+			"Swap:%s%s", _PATH_DEV, hrState_g.swap_devs[len].ksw_devname);
+		entry = hrStorageTblEntry_find_by_name(swap_w_prefix);
+		if (entry != NULL) {
+			entry->flags |= HR_STORAGE_FOUND;
+			entry->type = OIDX_hrStorageVirtualMemory_c;
+			entry->allocationUnits = getpagesize();
+			entry->size = hrState_g.swap_devs[len].ksw_total;
+			entry->used = hrState_g.swap_devs[len].ksw_used;
+			entry->allocationFailures = 0;						
+			continue;
+		}
+		if ((entry = hrStorageTblEntry_create(swap_w_prefix)) != NULL) {
+			entry->flags |= HR_STORAGE_FOUND;
+			entry->type = OIDX_hrStorageVirtualMemory_c;
+			entry->allocationUnits = getpagesize();
+			entry->size = hrState_g.swap_devs[len].ksw_total;			
+			entry->used = hrState_g.swap_devs[len].ksw_used;
+			entry->allocationFailures = 0;			
+		}
+		
+	}/*end for*/
+
+		
+	
+}
+
+/*
+ * Very silly detection for FS storage types. 
+ * Should be changed to use devinfo API.
+ * FIX ME
+ */
+static
+void hrStrorage_getType_v(const struct statfs *fs_p, struct asn_oid *out_type_p) {
+	assert(fs_p != NULL);
+	assert(out_type_p != NULL);
+	
+	if ( !(fs_p->f_flags &  MNT_LOCAL) ) {
+		*out_type_p = OIDX_hrStorageNetworkDisk_c;
+		return;
+	}
+	
+	if ( strncmp (fs_p->f_fstypename, "procfs", MFSNAMELEN ) == 0 || 
+	     strncmp (fs_p->f_fstypename, "devfs", MFSNAMELEN ) == 0  ) {
+		*out_type_p = OIDX_hrStorageOther_c;
+		return;
+	
+	}
+	if ( strncmp (fs_p->f_mntfromname, "/dev/fd", strlen("/dev/fd") ) == 0  || 
+	     strncmp (fs_p->f_mntfromname, "/dev/afd", strlen("/dev/afd") ) == 0) {
+		*out_type_p = OIDX_hrStorageFloppyDisk_c; 
+		return;
+	}
+
+	if ( strncmp (fs_p->f_mntfromname, "/dev/acd", strlen("/dev/acd") ) == 0  || 
+	     strncmp (fs_p->f_mntfromname, "/dev/cd", strlen("/dev/cd") ) == 0) {
+		*out_type_p = OIDX_hrStorageCompactDisc_c; 
+		return;
+	}
+
+		
+	if ( strncmp (fs_p->f_mntfromname, "/dev/ad", strlen("/dev/ad") ) == 0 ||
+	     strncmp (fs_p->f_mntfromname, "/dev/ar", strlen("/dev/ar") ) == 0 ||
+	     strncmp (fs_p->f_mntfromname, "/dev/da", strlen("/dev/da") ) == 0 ) {
+		*out_type_p = OIDX_hrStorageFixedDisk_c; 
+		return;		
+	}
+
+		
+	*out_type_p = OIDX_hrStorageOther_c; /*not known*/
+	return;
+	
+}
+
+/*
+ * Query the underlaying OS for the mounted file systems
+ * anf fill in the respective lists (for hrStorageTable and for hrFSTable)
+ */
+static
+void hrStorage_OS_get_fs_v(void) {
+	int mounted_fs_count = 0;
+	int i = 0;
+	struct hrStorageTblEntry *entry;
+	char fs_string[255+1];
+	uint64_t used_blocks_count = 0;
+	
+	if ( (mounted_fs_count = getfsstat(NULL, 0, MNT_NOWAIT)) < 0 ) {
+		syslog(LOG_ERR, "hrStorageTable: getfsstat(NULL, 0, MNT_NOWAIT) failed: %m\n");
+		return; /*out of luck this time*/
+	}
+	
+	if ( mounted_fs_count != (int)hrState_g.fs_buf_count || hrState_g.fs_buf == NULL ) {
+		hrState_g.fs_buf_count = mounted_fs_count;
+		hrState_g.fs_buf = (struct statfs *)reallocf(hrState_g.fs_buf, 
+			hrState_g.fs_buf_count * sizeof(struct statfs));
+		if (hrState_g.fs_buf == NULL) {
+			hrState_g.fs_buf_count = 0;
+			assert(0);
+			return;
+		}	
+	}
+	
+	if ( (mounted_fs_count = getfsstat(hrState_g.fs_buf, 
+		hrState_g.fs_buf_count * sizeof(struct statfs), 
+		MNT_NOWAIT)) < 0 ) {
+		syslog(LOG_ERR, "hrStorageTable: getfsstat(, , MNT_NOWAIT) failed: %m \n");
+		return; /*out of luck this time*/
+	}
+	
+	HR_DPRINTF((stderr, "%s: Got %d mounted FS\n ", __func__, mounted_fs_count));
+	
+	FS_tbl_pre_refresh_v();	
+	
+	for (i = 0; i < mounted_fs_count; i++ ) {
+		
+		
+		memset(&fs_string[0], '\0', sizeof(fs_string) );
+		(void)snprintf(fs_string, sizeof(fs_string) - 1, 
+			"%s, type: %s, dev: %s", 
+			hrState_g.fs_buf[i].f_mntonname, 
+			hrState_g.fs_buf[i].f_fstypename,
+			hrState_g.fs_buf[i].f_mntfromname);
+		
+		entry = hrStorageTblEntry_find_by_name(fs_string);
+		if (entry != NULL) {
+			entry->flags |= HR_STORAGE_FOUND;
+			
+			hrStrorage_getType_v( &hrState_g.fs_buf[i], &entry->type);
+			
+			entry->allocationUnits = ( hrState_g.fs_buf[i].f_bsize > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					(int32_t)hrState_g.fs_buf[i].f_bsize ); /*may overflow the SNMP type*/
+					
+			entry->size = ( hrState_g.fs_buf[i].f_blocks > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					(int32_t)hrState_g.fs_buf[i].f_blocks ); /*may overflow the SNMP type*/
+			
+			used_blocks_count = hrState_g.fs_buf[i].f_blocks - hrState_g.fs_buf[i].f_bfree;				
+			
+			entry->used = ( used_blocks_count > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					used_blocks_count ); /*may overflow the SNMP type*/
+					
+			entry->allocationFailures = 0;	
+			
+			/*take care of hrFSTable*/
+			FS_tbl_process_statfs_entry_v(&hrState_g.fs_buf[i], entry->index);
+					
+			continue;
+		}
+		if ((entry = hrStorageTblEntry_create(fs_string)) != NULL) {
+			entry->flags |= HR_STORAGE_FOUND;
+			
+			hrStrorage_getType_v( &hrState_g.fs_buf[i], &entry->type);
+					
+			entry->allocationUnits = ( hrState_g.fs_buf[i].f_bsize > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					(int32_t)hrState_g.fs_buf[i].f_bsize ); /*may overflow the SNMP type*/
+					
+			entry->size = ( hrState_g.fs_buf[i].f_blocks > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					(int32_t)hrState_g.fs_buf[i].f_blocks ); /*may overflow the SNMP type*/
+			
+			used_blocks_count = hrState_g.fs_buf[i].f_blocks - hrState_g.fs_buf[i].f_bfree;				
+			
+			entry->used = ( used_blocks_count > (uint64_t)INT_MAX ? 
+					INT_MAX : 
+					used_blocks_count ); /*may overflow the SNMP type*/
+					
+			entry->allocationFailures = 0;						
+			
+			/*take care of hrFSTable*/
+			FS_tbl_process_statfs_entry_v(&hrState_g.fs_buf[i], entry->index);
+
+			
+		}
+		
+	}/*end for*/
+	
+	FS_tbl_post_refresh_v();
+
+}
+
+void init_hrStorage_tbl_v(void) {
+	hrState_g.swap_devs = NULL;
+	hrState_g.swap_devs_len = 0;
+	
+	hrState_g.fs_buf = NULL;
+	hrState_g.fs_buf_count = 0;
+
+	memset( &hrState_g.mem_stats, 0, sizeof(hrState_g.mem_stats) );
+			
+	
+	refresh_hrStorage_tbl_v();
+	
+}
+
+void fini_hrStorage_tbl_v(void) {
+	struct storageNameMapEntry  *n1, *n2;
+	
+	if ( hrState_g.swap_devs != NULL ) {
+		free( hrState_g.swap_devs );
+		hrState_g.swap_devs = NULL;
+	}
+	hrState_g.swap_devs_len = 0;
+
+	if ( hrState_g.fs_buf != NULL ) {
+		free( hrState_g.fs_buf );
+		hrState_g.fs_buf = NULL;
+	}
+	hrState_g.fs_buf_count = 0;
+
+				
+     	n1 = STAILQ_FIRST(&hrState_g.storage_name_map);
+     	while (n1 != NULL) {
+             n2 = STAILQ_NEXT(n1, link);
+	     if (n1->entry_p != NULL) {
+	     	TAILQ_REMOVE(&hrState_g.hr_storage_tbl, n1->entry_p, link);
+             	free( n1->entry_p );
+		n1->entry_p = NULL;
+	     }
+	     free(n1);
+             n1 = n2;
+     	}
+     	STAILQ_INIT(&hrState_g.storage_name_map);
+
+}
+
+
+void refresh_hrStorage_tbl_v(void) {
+
+	struct hrStorageTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if ( this_tick <= hrState_g.hr_storage_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	/*mark each entry as missisng*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_storage_tbl, link)
+		entry->flags &= ~HR_STORAGE_FOUND;
+	
+	
+	hrStorage_OS_get_vm_v();
+	
+	hrStorage_OS_get_swap_v();
+	
+	hrStorage_OS_get_fs_v();
+	
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_storage_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_STORAGE_FOUND))
+			hrStorageTblEntry_delete_v(entry);
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_storage_tick = this_tick;			
+			
+	hrState_g.hrStorage_tbl_age = time(NULL);	
+	
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+}
+
+
+/*
+ * This is the implementation for a generated (by our SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It handles the SNMP operations for hrStorageTable
+ */
+
+int op_hrStorageTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrStorageTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+
+/*
+	refresh entries here?!	
+*/
+	if ( (time(NULL) - hrState_g.hrStorage_tbl_age) > HR_STORAGE_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrStorage_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_storage_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrStorageTblEntry_find_by_index(value->var.subs[sub]))
+			 == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrStorageIndex:
+		value->v.integer = entry->index;
+		break;
+	  case LEAF_hrStorageType:
+	  	value->v.oid = entry->type;
+	  	break;	
+	  case LEAF_hrStorageDescr:
+	  	ret = string_get(value, entry->descr, -1);
+	  	break;	
+	  case 	LEAF_hrStorageAllocationUnits:
+	  	value->v.integer = entry->allocationUnits;
+	  	break;
+	  case LEAF_hrStorageSize:
+	  	value->v.integer = entry->size;
+	  	break;	
+	  case LEAF_hrStorageUsed:
+	  	value->v.integer = entry->used;
+		break;
+	  case LEAF_hrStorageAllocationFailures:
+	  	value->v.uint32 = entry->allocationFailures;
+		break;
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swinstalled_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swinstalled_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swinstalled_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swinstalled_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB implementation for SNMPd: instrumentation for
+ * hrSWInstalledTable
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <sys/sysctl.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <syslog.h>
+#include <string.h>
+#include <err.h>
+#include <sys/utsname.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+extern
+u_char* OS_getSystemInitialLoadParameters(void);
+
+static
+struct hrSWInstalledTblEntry* 
+hrSWInstalledTblEntry_create( const char *name ) {
+	struct hrSWInstalledTblEntry	*entry;
+	struct SWInstalledNameMapEntry 	*map = NULL;
+
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "%s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	strncpy((char*)entry->name, name, sizeof(entry->name)-1);
+
+	STAILQ_FOREACH(map, &hrState_g.sw_installed_name_map, link)
+		if (strncmp((const char*)map->name, 
+			(const char*)entry->name, 
+			sizeof(map->name) - 1) == 0) {
+			
+			entry->index = map->hrIndex;
+			map->entry_p = entry;
+			break;
+		}
+	
+	if (map == NULL) {
+		/* new object - get a new index */
+		if (hrState_g.next_hrSWInstalled_index > INT_MAX) {
+		        syslog(LOG_ERR, "%s: hrSWInstalledTable index wrap", __func__ );
+			errx(1, "hrSWInstalledTable index wrap");
+		}	
+
+		if ((map = malloc(sizeof(*map))) == NULL) {
+			syslog(LOG_ERR, "%s: %m", __func__ );
+			free(entry);
+			return (NULL);
+		}
+		map->hrIndex = hrState_g.next_hrSWInstalled_index ++;
+		map->name[sizeof(map->name)-1]='\0';
+		strncpy((char *)map->name, (const char *)entry->name, sizeof(map->name) - 1);
+		map->entry_p = entry;
+		STAILQ_INSERT_TAIL(&hrState_g.sw_installed_name_map, map, link);
+		HR_DPRINTF((stderr, "%s  added into hrSWInstalled at index=%d\n ", 
+				name, map->hrIndex));
+	} else {
+		HR_DPRINTF((stderr, "%s  exists in hrSWInstalled index=%d\n ", 
+				name, map->hrIndex));
+	}
+	
+	entry->index = map->hrIndex;
+
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_sw_installed_tbl);
+	
+	return entry;
+	
+}
+
+static
+void
+hrSWInstalledTblEntry_delete_v( struct hrSWInstalledTblEntry* entry ) {
+	struct SWInstalledNameMapEntry  *map;
+	assert(entry != NULL);
+	
+	TAILQ_REMOVE(&hrState_g.hr_sw_installed_tbl, entry, link);	
+	STAILQ_FOREACH(map, &hrState_g.sw_installed_name_map, link)
+		if (map->entry_p == entry) {
+			map->entry_p = NULL;
+			break;
+		}
+			
+	free(entry);
+}
+
+static
+struct hrSWInstalledTblEntry*
+hrSWInstalledTblEntry_find_by_name(const char *name) {
+	struct hrSWInstalledTblEntry *entry =  NULL;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_sw_installed_tbl, link)
+		if (strncmp((const char*)entry->name, name, 
+			sizeof(entry->name) - 1) == 0)
+			
+			return (entry);
+	return (NULL);
+}
+
+static
+struct hrSWInstalledTblEntry *
+hrSWInstalledTblEntry_find_by_index(int32_t idx) {
+	struct hrSWInstalledTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_sw_installed_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+
+
+
+void fini_hrSWInstalled_tbl_v(void) {
+	struct SWInstalledNameMapEntry  *n1, *n2;
+			
+     	n1 = STAILQ_FIRST(&hrState_g.sw_installed_name_map);
+     	while (n1 != NULL) {
+             n2 = STAILQ_NEXT(n1, link);
+	     if(n1->entry_p != NULL){
+	     	TAILQ_REMOVE(&hrState_g.hr_sw_installed_tbl, n1->entry_p, link);
+             	free( n1->entry_p );
+		n1->entry_p = NULL;
+	     }
+	     free(n1);
+             n1 = n2;
+     	}
+     	STAILQ_INIT(&hrState_g.sw_installed_name_map);
+	TAILQ_INIT(&hrState_g.hr_sw_installed_tbl);
+
+}
+
+/*
+ * Get the *running* O/S identification
+ */
+static
+void hrSWInstalled_get_OS_ident(void) {
+	struct utsname os_id;
+	char os_string[64+1];
+	struct hrSWInstalledTblEntry *entry = NULL;
+	
+	memset(&os_id, 0, sizeof(os_id));
+	memset(&os_string[0], 0, sizeof(os_string));
+	if (uname(&os_id) != 0) {
+		return;
+	}
+	
+	(void)snprintf(os_string, sizeof(os_string) - 1, "%s: %s", 
+		os_id.sysname, os_id.version);
+	
+	entry = hrSWInstalledTblEntry_find_by_name(os_string);		
+	if (entry  == NULL) {
+		if ((entry = hrSWInstalledTblEntry_create(os_string)) != NULL) {
+			struct stat sb;
+		        struct tm k_ts;
+
+
+			memset(&sb, 0, sizeof(sb));
+			
+			entry->flags |= (HR_SWINSTALLED_FOUND | HR_SWINSTALLED_IMMUTABLE);
+			entry->id = oid_zeroDotZero;
+			entry->type = (int32_t)SWI_OPERATING_SYSTEM;
+			memset(&entry->date[0], 0, sizeof(entry->date));
+			
+			(void)OS_getSystemInitialLoadParameters();
+			
+			if( strlen(hrState_g.k_boot_line) > 0) {
+				if(stat(hrState_g.k_boot_line, &sb) == 0) {
+					if(localtime_r(&sb.st_ctime, &k_ts) != NULL) {
+						entry->date[0] = (u_char)((k_ts.tm_year + 1900) >> 8);
+						entry->date[1] = (u_char)(k_ts.tm_year + 1900);
+						entry->date[2] = k_ts.tm_mon + 1;
+						entry->date[3] = k_ts.tm_mday;
+						entry->date[4] = k_ts.tm_hour;
+						entry->date[5] = k_ts.tm_min;
+						entry->date[6] = k_ts.tm_sec;
+						entry->date[7] = 0;   /*deci-seconds */
+
+						if (k_ts.tm_gmtoff < 0){
+							entry->date[8] = '-';
+						}else{
+							entry->date[8] = '+';
+						}
+						entry->date[9] =  (u_char)(abs(k_ts.tm_gmtoff) / 3600);
+						entry->date[10] = (u_char)((abs(k_ts.tm_gmtoff) - entry->date[9] * 3600) / 60);
+					
+					
+					}
+				}
+			}
+		} 
+	}	
+}
+
+static
+void hrSWInstalled_get_packages(void) {
+/* Where we put logging information by default, else ${PKG_DBDIR} if set */
+#define DEF_LOG_DIR     "/var/db/pkg"
+/* just in case we change the environment variable name */
+#define PKG_DBDIR       "PKG_DBDIR"
+/* macro to get name of directory where we put logging information */
+#define LOG_DIR         (getenv(PKG_DBDIR) ? getenv(PKG_DBDIR) : DEF_LOG_DIR)
+#define CONTENTS_FNAME          "+CONTENTS"
+
+	char 	pkg_dir[PATH_MAX]; /*1024, for sure it's too much f
+					or this situation*/
+	struct stat sb;
+	DIR *p_dir = NULL;	
+	struct dirent dir_entry;
+	struct dirent *result = NULL;
+	int return_code = -1;
+	struct hrSWInstalledTblEntry *entry = NULL;
+	
+	memset(&pkg_dir[0], 0, sizeof(pkg_dir));
+	memset(&sb, 0, sizeof(sb));
+	
+	(void)snprintf(pkg_dir, sizeof(pkg_dir) - 1, "%s", LOG_DIR);
+	if (stat(pkg_dir, &sb) != 0) {
+		syslog(LOG_ERR, 
+		"hrSWInstalledTable: stat(\"%s\") failed: %m ", pkg_dir);
+		return;
+	}
+	if (!S_ISDIR(sb.st_mode)) {
+		syslog(LOG_ERR, 
+		"hrSWInstalledTable: \"%s\" is not a directory! ", pkg_dir);
+		return;
+	}
+	if (sb.st_ctime <= hrState_g.os_pkg_last_change) {
+		HR_DPRINTF((stderr, 
+		 "%s: no need to rescan installed packages, directory time-stamp unmodified \n ",
+		 __func__));
+		 
+		TAILQ_FOREACH(entry, &hrState_g.hr_sw_installed_tbl, link)
+			entry->flags |= HR_SWINSTALLED_FOUND;			
+		return;
+	}
+	
+	
+	
+     	p_dir = opendir(pkg_dir);
+     	if (p_dir == NULL) {
+     		syslog(LOG_ERR, "hrSWInstalledTable: opendir(\"%s\") failed: %m ", pkg_dir);
+		return;
+     	}
+     	
+        for (return_code = readdir_r(p_dir, &dir_entry, &result);
+         	result != NULL && return_code == 0;
+         	return_code = readdir_r(p_dir, &dir_entry, &result) ) {
+         	
+         	struct tm k_ts;
+      	        char   pkg_file[PATH_MAX] = "";
+
+         	
+         	
+      		HR_DPRINTF((stderr,">>pkg file: %s\n", dir_entry.d_name));
+      		if (strncmp(dir_entry.d_name, ".", 1) == 0 ||
+      		    strncmp(dir_entry.d_name, "..", 2) == 0 ||
+      		    strncmp(dir_entry.d_name,"pkgdb.db", 8) == 0 ) {
+      			continue;
+      		}	
+      		
+      		
+      		
+      		(void)snprintf(pkg_file, sizeof(pkg_file) - 1, "%s/%s/%s",
+      		 		 pkg_dir,
+      		 		 dir_entry.d_name, 
+      		 		 CONTENTS_FNAME);
+      		 		 
+      		
+      		if (stat(pkg_file, &sb) != 0 ) {
+      			continue;
+      		}
+		if (!S_ISREG(sb.st_mode)) {
+			syslog(LOG_ERR, "hrSWInstalledTable: \"%s\" not a regular file, pkg. skipped ", pkg_file);
+			continue;
+		}
+      		
+      		entry = hrSWInstalledTblEntry_find_by_name(dir_entry.d_name);
+      		if (entry == NULL) {
+      	        	
+      			if ((entry = hrSWInstalledTblEntry_create(dir_entry.d_name)) == NULL) {
+      				goto PKG_LOOP_END;
+      			}
+      
+      			/*new entry, update the timestamp*/
+			hrState_g.hr_sw_installed_change_tick = get_ticks();
+		}
+		
+		memset(&sb, 0, sizeof(sb));
+		memset(&pkg_file[0], 0, sizeof(pkg_file));
+			
+			
+		entry->flags |= HR_SWINSTALLED_FOUND;
+		entry->id = oid_zeroDotZero;
+		entry->type = (int32_t)SWI_APPLICATION;
+		memset(&entry->date[0], 0, sizeof(entry->date));
+			
+		(void)snprintf(pkg_file, sizeof(pkg_file) - 1, "%s/%s", 
+			pkg_dir, dir_entry.d_name);
+			
+	
+		if(stat(pkg_file, &sb) == 0) {
+			if(localtime_r(&sb.st_ctime, &k_ts) != NULL) {
+				entry->date[0] = (u_char)((k_ts.tm_year + 1900) >> 8);
+				entry->date[1] = (u_char)(k_ts.tm_year + 1900);
+				entry->date[2] = k_ts.tm_mon + 1;
+				entry->date[3] = k_ts.tm_mday;
+				entry->date[4] = k_ts.tm_hour;
+				entry->date[5] = k_ts.tm_min;
+				entry->date[6] = k_ts.tm_sec;
+				entry->date[7] = 0;   /*deci-seconds */
+
+				if (k_ts.tm_gmtoff < 0){
+					entry->date[8] = '-';
+				}else{
+					entry->date[8] = '+';
+				}
+				entry->date[9] =  (u_char)(abs(k_ts.tm_gmtoff) / 3600);
+				entry->date[10] = (u_char)((abs(k_ts.tm_gmtoff) - entry->date[9] * 3600) / 60);
+					
+			}
+		}
+			
+					
+      		
+      		
+      		
+        }/*end for*/
+     	
+	if (return_code != 0) {
+		syslog(LOG_ERR, 
+		"hrSWInstalledTable: readdir_r(\"%s\") failed: %m ", pkg_dir);
+	} else {
+		/*save the timestamp of directory
+	 	to avoid any further scanning*/
+		hrState_g.os_pkg_last_change = sb.st_ctime;
+	}
+	
+PKG_LOOP_END:
+	if ( p_dir != NULL ) {
+		if (closedir(p_dir) != 0) {
+		  syslog(LOG_ERR, 
+		 "hrSWInstalledTable: closedir failed: %m ");
+		}
+	}
+	
+
+}
+
+void init_hrSWInstalled_tbl_v(void) {
+	hrSWInstalled_get_OS_ident();
+	refresh_hrSWInstalled_tbl_v();	
+	HR_DPRINTF((stderr, "%s: TABLE INIT DONE\n ",__func__));
+	
+}
+
+
+void refresh_hrSWInstalled_tbl_v(void) {
+	struct hrSWInstalledTblEntry *entry = NULL, *entry_tmp;
+		
+	if ( this_tick <= hrState_g.hr_sw_installed_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+
+
+	/*mark each entry as missisng*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_sw_installed_tbl, link)
+		entry->flags &= ~HR_SWINSTALLED_FOUND;
+
+		
+	hrSWInstalled_get_packages();
+	
+	entry = TAILQ_FIRST(&hrState_g.hr_sw_installed_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_SWINSTALLED_FOUND) && !(entry->flags & HR_SWINSTALLED_IMMUTABLE) ) {
+			hrSWInstalledTblEntry_delete_v(entry);
+			/*entry deleted, update the timestamp*/
+			hrState_g.hr_sw_installed_change_tick = get_ticks();
+
+		}	
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_sw_installed_tick = this_tick;			
+			
+	hrState_g.hrSWInstalled_tbl_age = time(NULL);	
+
+	hrState_g.hr_sw_installed_full_upd_tick = get_ticks();
+		
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+		
+}
+
+
+int op_hrSWInstalledTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value , 
+		u_int sub , 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrSWInstalledTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+	
+	if ( (time(NULL) - hrState_g.hrSWInstalled_tbl_age) > HR_SWINSTALLED_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ", __func__));
+		refresh_hrSWInstalled_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_sw_installed_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrSWInstalledTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrSWInstalledIndex:
+		value->v.integer = entry->index;
+		break;
+	  case LEAF_hrSWInstalledName:
+	  	ret = string_get(value, entry->name, -1);
+	  	break;	
+	  case 	LEAF_hrSWInstalledID:
+	  	value->v.oid = entry->id;
+	  	break;
+	  case LEAF_hrSWInstalledType:
+	  	value->v.integer = entry->type;
+	  	break;	
+	  case LEAF_hrSWInstalledDate:
+		ret = string_get(value, entry->date, 11);
+		break;
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrun_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrun_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrun_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrun_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,600 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for hrSWRunTable
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <stdlib.h>
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <assert.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <sys/linker.h>
+#include <signal.h>
+
+
+/*
+ * Ugly thing: PID_MAX, NO_PID defined only in kernel
+ */
+#define	NO_PID		100000
+
+/*
+ * Malloc a new entry and add it to the list
+ * associated to this table. The item  identified by 
+ * the index parameter must not exist in this list
+ */
+static
+struct hrSWRunTblEntry* 
+hrSWRunTblEntry_create( int32_t idx ) {
+	struct hrSWRunTblEntry* entry = NULL;
+	
+	if ((entry = malloc(sizeof(*entry))) == NULL) {
+		syslog(LOG_WARNING, "%s: %m", __func__);
+		return (NULL);
+	}
+	memset(entry, 0, sizeof(*entry));
+	entry->index = idx;
+	
+	INSERT_OBJECT_INT(entry, &hrState_g.hr_swrun_tbl);
+	return entry;
+
+
+}
+
+/*
+ * Unlink the entry from the list and then free its heap memory
+ */
+static
+void
+hrSWRunTblEntry_delete_v( struct hrSWRunTblEntry* entry ) {
+	assert(entry != NULL);
+	
+	TAILQ_REMOVE(&hrState_g.hr_swrun_tbl, entry, link);	
+	
+	free(entry);
+}
+
+
+/*
+ * Search one item by its index, return NULL if none found
+ */
+
+struct hrSWRunTblEntry *
+hrSWRunTblEntry_find_by_index(int32_t idx) {
+	struct hrSWRunTblEntry *entry;
+
+	TAILQ_FOREACH(entry, &hrState_g.hr_swrun_tbl, link)
+		if (entry->index == idx)
+			return (entry);
+	return (NULL);
+}
+
+
+void init_hrSWRun_tbl_v(void) {
+	
+	refresh_hrSWRun_tbl_v();
+	HR_DPRINTF((stderr, "[%s] done.\n", __func__));
+}
+
+void fini_hrSWRun_tbl_v(void) {
+	struct hrSWRunTblEntry *n1 = NULL, *n2 = NULL;			
+	n1 = TAILQ_FIRST(&hrState_g.hr_swrun_tbl);
+	while (n1 != NULL) {
+		n2 = TAILQ_NEXT(n1, link);
+		free(n1);
+		n1 = n2;
+	}
+	
+}
+
+static
+enum SWRunStatus 
+hrSWRun_OS_get_proc_status(const struct kinfo_proc *kp) {
+	assert(kp != NULL);
+	if(kp ==  NULL) {
+		return SRS_INVALID;
+	}
+	/*
+	 * I'm using the old style flags - they look cleaner to me,
+	 * at least for the purpose of this SNMP table
+	 */
+	switch (kp->ki_stat) {
+		case SSTOP:
+			return SRS_NOT_RUNNABLE;
+		
+		case SWAIT:
+		case SLOCK:
+		case SSLEEP:
+			return SRS_RUNNABLE;
+		case SZOMB:
+			return SRS_INVALID;
+		case SIDL:
+		case SRUN:
+			return SRS_RUNNING;
+		default:
+			syslog(LOG_ERR,"Unknown process state: %d", kp->ki_stat);	
+			return SRS_INVALID;		
+	}
+}
+
+static
+void 
+kinfo_proc_to_hrSWRunTblEntry_v(const struct kinfo_proc *kp, struct hrSWRunTblEntry* entry) {
+	char **argv = NULL;
+	uint64_t cpu_time = 0;
+	
+	
+	entry->name[sizeof(entry->name) - 1] = '\0';
+	(void)strncpy((char*)&entry->name[0], 
+		&kp->ki_ocomm[0], sizeof(entry->name) - 1);
+	
+	entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+	
+	entry->path[0] = '\0';
+	entry->parameters[0] = '\0';
+	
+	assert(hrState_g.kd != NULL);
+	
+	argv = kvm_getargv(hrState_g.kd, kp, sizeof(entry->parameters) - 1);
+	if(argv !=  NULL){
+		memset(&entry->parameters[0], '\0', sizeof(entry->parameters));
+		/* 
+		 * FIX ME
+		 * Path seems to not be available.
+		 * Try to hack the info in argv[0];
+		 * this argv is under control of the program so this info 
+		 * is not realiable
+		 */
+		if(*argv != NULL && (*argv)[0] == '/') {
+			memset(&entry->path[0], '\0', sizeof(entry->path));
+			(void)strncpy((char*)&entry->path[0], 
+				*argv, sizeof(entry->path) - 1);
+		}
+		
+		argv++; /*skip the first one which was used for path*/
+				
+		while (argv != NULL && *argv != NULL ) {
+			if (entry->parameters[0] != 0)  {
+				/*add a space between parameters, except before the first one*/
+				strncat((char *)&entry->parameters[0], 
+				  " ", 
+				  sizeof(entry->parameters) - 
+				    strlen((const char*)&entry->parameters[0]) 
+				    - 1);
+			}
+			strncat((char *)&entry->parameters[0], *argv, 
+				sizeof(entry->parameters) - 
+				strlen((const char*)&entry->parameters[0]) 
+				- 1);
+			argv++;
+		}/*end while */
+
+	}
+	
+	entry->type = ( IS_KERNPROC(kp) ? (int32_t)SRT_OPERATING_SYSTEM : 
+						(int32_t)SRT_APPLICATION );
+	
+	entry ->status = (int32_t)hrSWRun_OS_get_proc_status(kp);
+	cpu_time = kp->ki_runtime / 100000; /*centi-seconds*/
+	/*may overflow the snmp type */
+	entry->perfCPU = (cpu_time > (uint64_t)INT_MAX ? INT_MAX : cpu_time); 
+	
+	entry->perfMemory = kp->ki_size / 1024; /*in kilo-bytes*/
+	entry->r_tick = get_ticks();
+
+}
+
+static 
+void 
+kld_file_stat_to_hrSWRunTblEntry_v(const struct kld_file_stat* kfs, struct hrSWRunTblEntry* entry) {
+	assert(kfs != NULL);
+	assert(entry != NULL);
+	
+	entry->name[sizeof(entry->name) - 1] = '\0';
+	(void)strncpy((char *)&entry->name[0], &kfs->name[0], 
+			sizeof(entry->name) - 1);
+	
+	/*FIX ME: can we find the location where the module was loaded from? */
+	entry->path[0] = '\0'; 
+	
+	/*no parameters for kernel files (.ko) of for the kernel*/
+	entry->parameters[0] = '\0'; 
+	
+	entry->id = oid_zeroDotZero; /*unknown id - FIX ME*/
+	
+	if (strncmp(kfs->name, "kernel", strlen("kernel") ) == 0) {
+		entry->type = (int32_t)SRT_OPERATING_SYSTEM;
+		hrState_g.hrSWOSIndex = entry->index;
+	}else{
+		entry->type = (int32_t)SRT_DEVICE_DRIVER; /*well, not really*/
+	}
+	entry->status = (int32_t)SRS_RUNNING;
+	entry->perfCPU = 0; /*Info not available*/
+	entry->perfMemory = kfs->size / 1024; /*in kilo-bytes*/
+	entry->r_tick = get_ticks();
+}
+
+/*
+ * Get all visible proceses including the kernel visible threads
+ */
+static 
+void hrSWRun_OS_get_procs_v(void) {
+	struct kinfo_proc *plist =  NULL, *kp;
+	int i = 0;
+	int nproc = -1;
+	struct hrSWRunTblEntry *entry = NULL;
+	
+	plist = kvm_getprocs(hrState_g.kd, KERN_PROC_ALL, 0, &nproc);
+	if (plist == NULL || nproc < 0) {
+		syslog(LOG_ERR, "kvm_getprocs() failed: %m");
+		return;
+	}
+	for (i = 0, kp = plist; i < nproc; i++, kp++) {	
+			
+		/*
+		 * The SNMP table's index must begin from 1 (as specified by 
+		 * this table definition),  the PIDs are starting from 0 
+		 * so we are translating the PIDs to +1
+		 */
+		entry = hrSWRunTblEntry_find_by_index((int32_t)kp->ki_pid + 1);
+		if(entry == NULL){
+			/*new entry - get memory for it*/
+			entry = hrSWRunTblEntry_create((int32_t)kp->ki_pid + 1);
+		}
+		assert(entry !=  NULL);
+		entry->flags |= HR_SWRUN_FOUND; /*mark it as found*/
+		
+		kinfo_proc_to_hrSWRunTblEntry_v(kp,entry);		
+		
+	}
+}
+
+/*
+ * Get kernel items: first the kernel itself, then the loaded modules.	
+ */
+static 
+void hrSWRun_OS_get_kinfo_v(void) {
+	int fileid = 0;
+	struct hrSWRunTblEntry *entry = NULL;
+	
+	for (fileid = kldnext(0); fileid > 0; fileid = kldnext(fileid)) {
+		struct kld_file_stat stat;
+		stat.version = sizeof(struct kld_file_stat);
+		if (kldstat(fileid, &stat) < 0) {
+			syslog(LOG_ERR, "kldstat() failed: %m");
+			continue;
+		}
+		/*
+		 * kernel and kernel files (*.ko) will be indexed starting with
+		 * NO_PID + 1; NO_PID is PID_MAX + 1 thus it will be no risk to
+		 * overlap with real PIDs which are in range of 1 .. NO_PID
+		 */
+		entry = hrSWRunTblEntry_find_by_index(NO_PID + 1 + stat.id);
+		if(entry == NULL){
+			/*new entry - get memory for it*/
+			entry = hrSWRunTblEntry_create(NO_PID + 1 + stat.id);
+		}
+		assert(entry !=  NULL);
+		entry->flags |= HR_SWRUN_FOUND; /*mark it as found*/
+		
+		kld_file_stat_to_hrSWRunTblEntry_v(&stat, entry);
+	}    
+	
+}
+
+void refresh_hrSWRun_tbl_v(void) {
+
+	struct hrSWRunTblEntry *entry = NULL, *entry_tmp = NULL;
+	
+	if ( this_tick <= hrState_g.hr_swrun_tick) {
+		HR_DPRINTF((stderr, "%s: no refresh needed\n ",__func__));
+		return;
+	}
+	/*mark each entry as missing*/
+	TAILQ_FOREACH(entry, &hrState_g.hr_swrun_tbl, link)
+		entry->flags &= ~HR_SWRUN_FOUND;
+	
+	hrSWRun_OS_get_procs_v();
+	hrSWRun_OS_get_kinfo_v();
+	/*
+	 * Purge items that disappeared
+	 */
+	entry = TAILQ_FIRST(&hrState_g.hr_swrun_tbl);
+	while (entry != NULL) {
+		entry_tmp = TAILQ_NEXT(entry, link);
+		if (!(entry->flags & HR_SWRUN_FOUND))
+			hrSWRunTblEntry_delete_v(entry);
+		entry = entry_tmp;
+	}
+	
+	hrState_g.hr_swrun_tick = this_tick;			
+			
+	hrState_g.hrSWRun_tbl_age = time(NULL);	
+	
+	HR_DPRINTF((stderr, "%s: refresh DONE\n ",__func__));
+}
+
+static
+void fetch_hrSWRun_entry_v(struct hrSWRunTblEntry *entry) {
+	int item_found = 0;
+	struct kinfo_proc *plist =  NULL;
+	int nproc =  -1;
+	int fileid = 0;
+	
+	assert(entry !=  NULL);
+	
+	if( entry->index >= NO_PID + 1)	{
+		/* this is a kernel item */
+		item_found = 0;
+		for (fileid = kldnext(0); fileid > 0; fileid = kldnext(fileid)) {
+			struct kld_file_stat stat;
+			stat.version = sizeof(struct kld_file_stat);
+			if (kldstat(fileid, &stat) < 0) {
+				syslog(LOG_ERR, "kldstat() failed: %m");
+				continue;
+			}
+			/*
+			* kernel and kernel files (*.ko) will be indexed starting with
+			* NO_PID + 1; NO_PID is PID_MAX + 1 thus it will be no risk to
+			* overlap with real PIDs which are in range of 1 .. NO_PID
+			*/
+			if( NO_PID + 1 + stat.id == entry->index ) {
+				kld_file_stat_to_hrSWRunTblEntry_v(&stat, entry);
+				item_found = 1;
+				break;
+			}
+
+		} /* end for*/   
+		if (item_found == 0) {
+			/* not found, it's gone. Mark it as invalid for now, it
+			 * will be removed from the list at next global refersh
+			 */  
+			 HR_DPRINTF((stderr, 
+			   "%s: missing item with kid = %d \n ", 
+			   __func__,
+			    entry->index -  NO_PID - 1));
+			 entry->status = (int32_t)SRS_INVALID;
+			 
+		}
+		
+	} else {
+	
+		/* this is user space visible process*/
+		assert(hrState_g.kd != NULL);
+		plist = kvm_getprocs(hrState_g.kd, KERN_PROC_PID, entry->index - 1, &nproc);
+		if (plist == NULL || nproc != 1) {
+			HR_DPRINTF((stderr, "%s: missing item with PID = %d \n ", 
+			  __func__, 
+			  entry->index - 1));
+			entry->status = (int32_t)SRS_INVALID;
+			return; 
+		}
+		kinfo_proc_to_hrSWRunTblEntry_v(plist,entry);
+
+	}
+}
+
+static
+int invalidate_hrSWRun_entry(struct hrSWRunTblEntry *entry) {
+	struct kinfo_proc *plist =  NULL;
+	int nproc =  -1;
+
+	
+	assert(entry !=  NULL);
+	
+	if( entry->index >= NO_PID + 1)	{
+		/* this is a kernel item */
+		int item_found = 0;
+		int fileid = 0;
+
+		HR_DPRINTF((stderr, "%s: atempt to delete a kernel item %d \n ", __func__, entry->index -  NO_PID - 1));
+		
+		if( entry->index == hrState_g.hrSWOSIndex) {
+			/*can't invalidate the kernel itself*/
+			return (SNMP_ERR_NOT_WRITEABLE);/*error*/
+		}
+		
+		for (fileid = kldnext(0); fileid > 0; fileid = kldnext(fileid)) {
+			struct kld_file_stat stat;
+			stat.version = sizeof(struct kld_file_stat);
+			if (kldstat(fileid, &stat) < 0) {
+				syslog(LOG_ERR, "kldstat() failed: %m");
+				continue;
+			}
+			
+			if( NO_PID + 1 + stat.id == entry->index ) {
+				if(kldunload(fileid) < 0) {
+					syslog(LOG_ERR,"kldunload for %s failed: %m", stat.name);
+					return (SNMP_ERR_RES_UNAVAIL); /*error*/
+				}
+				item_found = 1;
+				break;
+			}
+
+		} /* end for*/   
+		if (item_found == 0) {
+			/* not found, it's gone. Mark it as invalid for now, it
+			 * will be removed from the list at next global refersh
+			 */  
+			 HR_DPRINTF((stderr, "%s: missing item with kid = %d \n ", 
+			   __func__, 
+			   entry->index -  NO_PID - 1));
+			 entry->status = (int32_t)SRS_INVALID;
+			 return (SNMP_ERR_NOERROR); 
+			 
+		}
+		
+	} else {
+	
+		/* this is user space visible process*/
+		assert(hrState_g.kd != NULL);
+		plist = kvm_getprocs(hrState_g.kd, KERN_PROC_PID, entry->index - 1, &nproc);
+		if (plist == NULL || nproc != 1) {
+			HR_DPRINTF((stderr, "%s: missing item with PID = %d \n ", 
+			  __func__, 
+			  entry->index - 1));
+			entry->status = (int32_t)SRS_INVALID;
+			return (SNMP_ERR_NOERROR); 
+		}
+		if(IS_KERNPROC(plist)) {
+			/*you don't want to do this*/
+			return (SNMP_ERR_NOT_WRITEABLE);
+		} else {
+			if(kill(entry->index - 1, SIGKILL) < 0) {
+				syslog(LOG_ERR,"kill (%d, SIGKILL) failed: %m", entry->index - 1);
+				return (SNMP_ERR_GENERR);
+			}
+			return (SNMP_ERR_NOERROR); 
+		}
+		
+
+	}
+	return (SNMP_ERR_NOERROR); 
+	
+}
+
+/*
+ * This is the implementation for a generated (by a SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It hanldes the SNMP operations for hrSWRunTable
+ */
+int op_hrSWRunTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrSWRunTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+
+/*
+	refresh entries here?!	
+*/
+	if ( (time(NULL) - hrState_g.hrSWRun_tbl_age) > HR_SWRUN_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrSWRun_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_swrun_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrSWRunTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrSWRunTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		
+		if (entry->r_tick < this_tick) {
+			HR_DPRINTF((stderr, "%s: Specific entry with SNMP INDEX = %d needs refresh\n ",
+					__func__, 
+					entry->index));
+			fetch_hrSWRun_entry_v(entry);
+		}	
+		if(entry->status == (int32_t)SRS_INVALID){
+			return (SNMP_ERR_NOERROR);
+		}
+		
+		switch (value->var.subs[sub - 1]) {
+			case LEAF_hrSWRunStatus: {
+				if( value->v.integer !=  (int32_t)SRS_INVALID) {
+					return (SNMP_ERR_WRONG_VALUE);
+				}
+				return (invalidate_hrSWRun_entry(entry));
+			}	
+			default:
+				return (SNMP_ERR_NOT_WRITEABLE);
+
+		} /* end switch (value->var.subs[sub - 1]) */
+		/*not reachable*/
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+		return (SNMP_ERR_NOERROR);
+	}
+
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrSWRunIndex:
+		value->v.integer = entry->index;
+		break;
+	  case LEAF_hrSWRunName:
+	  	ret = string_get(value, entry->name, -1);
+	  	break;	
+	  case LEAF_hrSWRunID:
+	  	value->v.oid =  entry->id;
+	  	break;	
+	  case 	LEAF_hrSWRunPath:
+	  	ret = string_get(value, entry->path, -1);
+	  	break;
+	  case LEAF_hrSWRunParameters:
+	  	ret = string_get(value, entry->parameters, -1);
+	  	break;	
+	  case LEAF_hrSWRunType:
+	  	value->v.integer = entry->type;
+		break;
+	  case LEAF_hrSWRunStatus:
+	  	value->v.integer = entry->status;
+		break;
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrunperf_tbl.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrunperf_tbl.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrunperf_tbl.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_swrunperf_tbl.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Host Resources MIB for SNMPd. Implementation for the hrSWRunPerfTable
+ */
+#include "hostres_snmp.h"
+#include "hostres_oid.h"
+#include "hostres_tree.h"
+#include <assert.h>
+
+/*
+ * This is the implementation for a generated (by a SNMP tool) 
+ * function prototype, see hostres_tree.h 
+ * It hanldes the SNMP operations for hrSWRunPerfTable
+ */
+   
+int op_hrSWRunPerfTable(struct snmp_context *ctx __unused, 
+                struct snmp_value *value, 
+		u_int sub, 
+		u_int iidx __unused, 
+		enum snmp_op curr_op )
+{
+	struct hrSWRunTblEntry *entry =  NULL;
+	int ret =  SNMP_ERR_NOERROR;
+
+
+/*
+	refresh entries here?!	
+*/
+	if ( (time(NULL) - hrState_g.hrSWRun_tbl_age) > HR_SWRUN_TBL_REFRESH ) {
+		HR_DPRINTF((stderr, "%s: need refresh\n ",__func__));
+		refresh_hrSWRun_tbl_v();
+	}
+
+
+	switch (curr_op) {
+
+	  case SNMP_OP_GETNEXT:
+		if ((entry = NEXT_OBJECT_INT(&hrState_g.hr_swrun_tbl, 
+					     &value->var, sub)) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}	
+		value->var.len = sub + 1;
+		value->var.subs[sub] = entry->index;
+		break;
+
+	  case SNMP_OP_GET:
+		if (value->var.len - sub != 1) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+			
+		if ((entry = hrSWRunTblEntry_find_by_index(value->var.subs[sub])) == NULL) {
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);	  
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+	}
+
+	ret = SNMP_ERR_NOERROR;
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_hrSWRunPerfCPU:
+		value->v.integer = entry->perfCPU;
+		break;
+	  case LEAF_hrSWRunPerfMem:
+		value->v.integer = entry->perfMemory;
+	  	break;	
+	  default:
+	  	assert(0);
+		ret = SNMP_ERR_NOSUCHNAME;
+		break;
+	}
+	return (ret);
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_tree.def BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_tree.def
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_tree.def	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_hostres/hostres_tree.def	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,272 @@
+#
+# Copyright (c) 2005 The FreeBSD Project
+# Author: Victor Cruceru <soc-victor@freebsd.org>
+# 
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+#
+# This is the .def file for both HOST-RESOURCES-MIB and HOST-RESOURCES-TYPES
+#
+
+(1 internet
+  (2 mgmt
+    (1 mib_2
+      (25 host
+        (1 hrSystem
+          (1 hrSystemUptime TIMETICKS op_hrSystem GET)
+          (2 hrSystemDate OCTETSTRING op_hrSystem GET SET)
+          (3 hrSystemInitialLoadDevice INTEGER op_hrSystem GET SET)
+          (4 hrSystemInitialLoadParameters OCTETSTRING op_hrSystem GET SET)
+          (5 hrSystemNumUsers GAUGE op_hrSystem GET)
+          (6 hrSystemProcesses GAUGE op_hrSystem GET)
+          (7 hrSystemMaxProcesses INTEGER op_hrSystem GET)
+        )
+        (2 hrStorage
+          (1 hrStorageTypes
+            (1 hrStorageOther
+            )
+            (2 hrStorageRam
+            )
+            (3 hrStorageVirtualMemory
+            )
+            (4 hrStorageFixedDisk
+            )
+            (5 hrStorageRemovableDisk
+            )
+            (6 hrStorageFloppyDisk
+            )
+            (7 hrStorageCompactDisc
+            )
+            (8 hrStorageRamDisk
+            )
+            (9 hrStorageFlashMemory
+            )
+            (10 hrStorageNetworkDisk
+            )	  
+          )
+          (2 hrMemorySize INTEGER op_hrStorage GET)
+          (3 hrStorageTable
+            (1 hrStorageEntry : INTEGER op_hrStorageTable
+              (1 hrStorageIndex INTEGER GET)
+              (2 hrStorageType OID GET)
+              (3 hrStorageDescr OCTETSTRING GET)
+              (4 hrStorageAllocationUnits INTEGER GET)
+              (5 hrStorageSize INTEGER GET SET)
+              (6 hrStorageUsed INTEGER GET)
+              (7 hrStorageAllocationFailures COUNTER GET)
+            )
+          )
+        )
+        (3 hrDevice
+          (1 hrDeviceTypes
+            (1 hrDeviceOther
+            )
+            (2 hrDeviceUnknown
+            )
+            (3 hrDeviceProcessor
+            )
+            (4 hrDeviceNetwork
+            )
+            (5 hrDevicePrinter
+            )
+            (6 hrDeviceDiskStorage
+            )
+            (10 hrDeviceVideo
+            )
+            (11 hrDeviceAudio
+            )
+            (12 hrDeviceCoprocessor
+            )
+            (13 hrDeviceKeyboard
+            )
+            (14 hrDeviceModem
+            )
+            (15 hrDeviceParallelPort
+            )
+            (16 hrDevicePointing
+            )
+            (17 hrDeviceSerialPort
+            )
+            (18 hrDeviceTape
+            )
+            (19 hrDeviceClock
+            )
+            (20 hrDeviceVolatileMemory
+            )
+            (21 hrDeviceNonVolatileMemory
+            )	  
+          )
+          (2 hrDeviceTable
+            (1 hrDeviceEntry : INTEGER op_hrDeviceTable
+              (1 hrDeviceIndex INTEGER GET)
+              (2 hrDeviceType OID GET)
+              (3 hrDeviceDescr OCTETSTRING GET)
+              (4 hrDeviceID OID GET)
+              (5 hrDeviceStatus INTEGER GET)
+              (6 hrDeviceErrors COUNTER GET)
+            )
+          )
+          (3 hrProcessorTable
+            (1 hrProcessorEntry : INTEGER op_hrProcessorTable
+              (1 hrProcessorFrwID OID GET)
+              (2 hrProcessorLoad INTEGER GET)
+            )
+          )
+          (4 hrNetworkTable
+            (1 hrNetworkEntry : INTEGER op_hrNetworkTable
+              (1 hrNetworkIfIndex INTEGER GET)
+            )
+          )
+          (5 hrPrinterTable
+            (1 hrPrinterEntry : INTEGER op_hrPrinterTable
+              (1 hrPrinterStatus INTEGER GET)
+              (2 hrPrinterDetectedErrorState OCTETSTRING GET)
+            )
+          )
+          (6 hrDiskStorageTable
+            (1 hrDiskStorageEntry : INTEGER op_hrDiskStorageTable
+              (1 hrDiskStorageAccess INTEGER GET)
+              (2 hrDiskStorageMedia INTEGER GET)
+              (3 hrDiskStorageRemoveble INTEGER GET)
+              (4 hrDiskStorageCapacity INTEGER GET)
+            )
+          )
+          (7 hrPartitionTable
+            (1 hrPartitionEntry : INTEGER INTEGER op_hrPartitionTable
+              (1 hrPartitionIndex INTEGER GET)
+              (2 hrPartitionLabel OCTETSTRING GET)
+              (3 hrPartitionID OCTETSTRING GET)
+              (4 hrPartitionSize INTEGER GET)
+              (5 hrPartitionFSIndex INTEGER GET)
+            )
+          )
+          (8 hrFSTable
+            (1 hrFSEntry : INTEGER op_hrFSTable
+              (1 hrFSIndex INTEGER GET)
+              (2 hrFSMountPoint OCTETSTRING GET)
+              (3 hrFSRemoteMountPoint OCTETSTRING GET)
+              (4 hrFSType OID GET)
+              (5 hrFSAccess INTEGER GET)
+              (6 hrFSBootable INTEGER GET)
+              (7 hrFSStorageIndex INTEGER GET)
+              (8 hrFSLastFullBackupDate OCTETSTRING GET SET)
+              (9 hrFSLastPartialBackupDate OCTETSTRING GET SET)
+            )
+          )
+          (9 hrFSTypes
+            (1 hrFSOther
+            )
+            (2 hrFSUnknown
+            )
+            (3 hrFSBerkeleyFFS
+            )
+            (4 hrFSSys5FS
+            )
+            (5 hrFSFat
+            )
+            (6 hrFSHPFS
+            )
+            (7 hrFSHFS
+            )
+            (8 hrFSMFS
+            )
+            (9 hrFSNTFS
+            )
+            (10 hrFSVNode
+            )
+            (11 hrFSJournaled
+            )
+            (12 hrFSiso9660
+            )
+            (13 hrFSRockRidge
+            )
+            (14 hrFSNFS
+            )
+            (15 hrFSNetware
+            )
+            (16 hrFSAFS
+            )
+            (17 hrFSDFS
+            )
+            (18 hrFSAppleshare
+            )
+            (19 hrFSRFS
+            )
+            (20 hrFSDGCFS
+            )
+            (21 hrFSBFS
+            )
+            (22 hrFSFAT32
+            )
+            (23 hrFSLinuxExt2
+            )
+          )
+        )
+        (4 hrSWRun
+          (1 hrSWOSIndex INTEGER op_hrSWRun GET)
+          (2 hrSWRunTable
+            (1 hrSWRunEntry : INTEGER op_hrSWRunTable
+              (1 hrSWRunIndex INTEGER GET)
+              (2 hrSWRunName OCTETSTRING GET)
+              (3 hrSWRunID OID GET)
+              (4 hrSWRunPath OCTETSTRING GET)
+              (5 hrSWRunParameters OCTETSTRING GET)
+              (6 hrSWRunType INTEGER GET)
+              (7 hrSWRunStatus INTEGER GET SET)
+            )
+          )
+        )
+        (5 hrSWRunPerf
+          (1 hrSWRunPerfTable
+            (1 hrSWRunPerfEntry : INTEGER op_hrSWRunPerfTable
+              (1 hrSWRunPerfCPU INTEGER GET)
+              (2 hrSWRunPerfMem INTEGER GET)
+            )
+          )
+        )
+        (6 hrSWInstalled
+          (1 hrSWInstalledLastChange TIMETICKS op_hrSWInstalled GET)
+          (2 hrSWInstalledLastUpdateTime TIMETICKS op_hrSWInstalled GET)
+          (3 hrSWInstalledTable
+            (1 hrSWInstalledEntry : INTEGER op_hrSWInstalledTable
+              (1 hrSWInstalledIndex INTEGER GET)
+              (2 hrSWInstalledName OCTETSTRING GET)
+              (3 hrSWInstalledID OID GET)
+              (4 hrSWInstalledType INTEGER GET)
+              (5 hrSWInstalledDate OCTETSTRING GET)
+            )
+          )
+        )
+        (7 hrMIBAdminInfo
+          (1 hostResourcesMibModule
+          )
+          (2 hrMIBCompliances
+          )
+          (3 hrMIBGroups
+          )
+        )
+      )
+    )
+  )
+)
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_mibII/Makefile BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_mibII/Makefile
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_mibII/Makefile	Tue Sep 13 11:22:23 2005
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_mibII/Makefile	Tue Sep 13 11:21:29 2005
@@ -8,8 +8,8 @@ CONTRIB=${.CURDIR}/../../../../contrib/b
 MOD=	mibII
 SRCS=	mibII.c mibII_ifmib.c mibII_ip.c mibII_interfaces.c		\
 	mibII_ipaddr.c mibII_ifstack.c mibII_rcvaddr.c			\
-	mibII_nettomedia.c mibII_tcp.c mibII_udp.c mibII_route.c
-XSYM=	ipAddrTable ifTable ifRcvAddressEntry ifMIB ipMIB tcpMIB udpMIB	\
+	mibII_nettomedia.c mibII_route.c
+XSYM=	ipAddrTable ifTable ifRcvAddressEntry ifMIB ipMIB 	\
 	ipForward ifIndex linkDown linkUp
 MAN=	snmp_mibII.3
 
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/INET-ADDRESS-MIB.txt BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/INET-ADDRESS-MIB.txt
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/INET-ADDRESS-MIB.txt	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/INET-ADDRESS-MIB.txt	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,297 @@
+INET-ADDRESS-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY, mib-2, Unsigned32 FROM SNMPv2-SMI
+    TEXTUAL-CONVENTION                 FROM SNMPv2-TC;
+
+inetAddressMIB MODULE-IDENTITY
+    LAST-UPDATED "200205090000Z"
+    ORGANIZATION
+        "IETF Operations and Management Area"
+    CONTACT-INFO
+        "Juergen Schoenwaelder (Editor)
+         TU Braunschweig
+         Bueltenweg 74/75
+         38106 Braunschweig, Germany
+         Phone: +49 531 391-3289
+         EMail: schoenw@ibr.cs.tu-bs.de
+         Send comments to <mibs@ops.ietf.org>."
+    DESCRIPTION
+        "This MIB module defines textual conventions for
+         representing Internet addresses. An Internet
+         address can be an IPv4 address, an IPv6 address
+         or a DNS domain name. This module also defines
+         textual conventions for Internet port numbers,
+         autonomous system numbers and the length of an
+         Internet address prefix."
+    REVISION     "200205090000Z"
+    DESCRIPTION
+        "Second version, published as RFC 3291. This
+         revisions contains several clarifications and it
+         introduces several new textual conventions:
+         InetAddressPrefixLength, InetPortNumber,
+         InetAutonomousSystemNumber, InetAddressIPv4z,
+         and InetAddressIPv6z."
+    REVISION     "200006080000Z"
+    DESCRIPTION
+        "Initial version, published as RFC 2851."
+    ::= { mib-2 76 }
+
+InetAddressType ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+        "A value that represents a type of Internet address.
+         unknown(0)  An unknown address type. This value MUST
+                     be used if the value of the corresponding
+                     InetAddress object is a zero-length string.
+                     It may also be used to indicate an IP address
+                     which is not in one of the formats defined
+                     below.
+
+         ipv4(1)     An IPv4 address as defined by the
+                     InetAddressIPv4 textual convention.
+
+         ipv6(2)     A global IPv6 address as defined by the
+                     InetAddressIPv6 textual convention.
+
+         ipv4z(3)    A non-global IPv4 address including a zone
+                     index as defined by the InetAddressIPv4z
+                     textual convention.
+
+         ipv6z(4)    A non-global IPv6 address including a zone
+                     index as defined by the InetAddressIPv6z
+                     textual convention.
+
+         dns(16)     A DNS domain name as defined by the
+                     InetAddressDNS textual convention.
+
+         Each definition of a concrete InetAddressType value must be
+         accompanied by a definition of a textual convention for use
+         with that InetAddressType.
+
+         To support future extensions, the InetAddressType textual
+         convention SHOULD NOT be sub-typed in object type definitions.
+         It MAY be sub-typed in compliance statements in order to
+         require only a subset of these address types for a compliant
+         implementation.
+
+         Implementations must ensure that InetAddressType objects
+         and any dependent objects (e.g. InetAddress objects) are
+         consistent.  An inconsistentValue error must be generated
+         if an attempt to change an InetAddressType object would,
+         for example, lead to an undefined InetAddress value.  In
+         particular, InetAddressType/InetAddress pairs must be
+         changed together if the address type changes (e.g. from
+         ipv6(2) to ipv4(1))."
+    SYNTAX      INTEGER {
+                    unknown(0),
+                    ipv4(1),
+                    ipv6(2),
+                    ipv4z(3),
+                    ipv6z(4),
+                    dns(16)
+                }
+
+InetAddress ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+        "Denotes a generic Internet address.
+
+         An InetAddress value is always interpreted within the context
+         of an InetAddressType value. Every usage of the InetAddress
+         textual convention is required to specify the InetAddressType
+         object which provides the context.  It is suggested that the
+         InetAddressType object is logically registered before the
+         object(s) which use the InetAddress textual convention if
+         they appear in the same logical row.
+
+         The value of an InetAddress object must always be
+         consistent with the value of the associated InetAddressType
+         object. Attempts to set an InetAddress object to a value
+         which is inconsistent with the associated InetAddressType
+         must fail with an inconsistentValue error.
+
+         When this textual convention is used as the syntax of an
+         index object, there may be issues with the limit of 128
+         sub-identifiers specified in SMIv2, STD 58. In this case,
+         the object definition MUST include a 'SIZE' clause to
+         limit the number of potential instance sub-identifiers."
+    SYNTAX      OCTET STRING (SIZE (0..255))
+
+InetAddressIPv4 ::= TEXTUAL-CONVENTION
+    DISPLAY-HINT "1d.1d.1d.1d"
+    STATUS       current
+    DESCRIPTION
+        "Represents an IPv4 network address:
+
+           octets   contents         encoding
+            1-4     IPv4 address     network-byte order
+
+         The corresponding InetAddressType value is ipv4(1).
+
+         This textual convention SHOULD NOT be used directly in object
+         definitions since it restricts addresses to a specific format.
+         However, if it is used, it MAY be used either on its own or in
+         conjunction with InetAddressType as a pair."
+    SYNTAX       OCTET STRING (SIZE (4))
+
+InetAddressIPv6 ::= TEXTUAL-CONVENTION
+    DISPLAY-HINT "2x:2x:2x:2x:2x:2x:2x:2x"
+    STATUS       current
+    DESCRIPTION
+        "Represents an IPv6 network address:
+
+           octets   contents         encoding
+            1-16    IPv6 address     network-byte order
+
+         The corresponding InetAddressType value is ipv6(2).
+
+         This textual convention SHOULD NOT be used directly in object
+         definitions since it restricts addresses to a specific format.
+         However, if it is used, it MAY be used either on its own or in
+         conjunction with InetAddressType as a pair."
+    SYNTAX       OCTET STRING (SIZE (16))
+
+InetAddressIPv4z ::= TEXTUAL-CONVENTION
+    DISPLAY-HINT "1d.1d.1d.1d%4d"
+    STATUS       current
+    DESCRIPTION
+        "Represents a non-global IPv4 network address together
+         with its zone index:
+
+           octets   contents         encoding
+            1-4     IPv4 address     network-byte order
+            5-8     zone index       network-byte order
+
+         The corresponding InetAddressType value is ipv4z(3).
+
+         The zone index (bytes 5-8) is used to disambiguate identical
+         address values on nodes which have interfaces attached to
+         different zones of the same scope. The zone index may contain
+         the special value 0 which refers to the default zone for each
+         scope.
+
+         This textual convention SHOULD NOT be used directly in object
+         definitions since it restricts addresses to a specific format.
+         However, if it is used, it MAY be used either on its own or in
+         conjunction with InetAddressType as a pair."
+    SYNTAX OCTET STRING (SIZE (8))
+
+InetAddressIPv6z ::= TEXTUAL-CONVENTION
+    DISPLAY-HINT "2x:2x:2x:2x:2x:2x:2x:2x%4d"
+    STATUS       current
+    DESCRIPTION
+        "Represents a non-global IPv6 network address together
+         with its zone index:
+
+           octets   contents         encoding
+            1-16    IPv6 address     network-byte order
+           17-20    zone index       network-byte order
+
+         The corresponding InetAddressType value is ipv6z(4).
+
+         The zone index (bytes 17-20) is used to disambiguate
+         identical address values on nodes which have interfaces
+         attached to different zones of the same scope. The zone index
+         may contain the special value 0 which refers to the default
+         zone for each scope.
+
+         This textual convention SHOULD NOT be used directly in object
+         definitions since it restricts addresses to a specific format.
+         However, if it is used, it MAY be used either on its own or in
+         conjunction with InetAddressType as a pair."
+    SYNTAX OCTET STRING (SIZE (20))
+
+InetAddressDNS ::= TEXTUAL-CONVENTION
+    DISPLAY-HINT "255a"
+    STATUS       current
+    DESCRIPTION
+        "Represents a DNS domain name. The name SHOULD be fully
+         qualified whenever possible.
+
+         The corresponding InetAddressType is dns(16).
+
+         The DESCRIPTION clause of InetAddress objects that may have
+         InetAddressDNS values must fully describe how (and when) such
+         names are to be resolved to IP addresses.
+
+         This textual convention SHOULD NOT be used directly in object
+         definitions since it restricts addresses to a specific format.
+         However, if it is used, it MAY be used either on its own or in
+         conjunction with InetAddressType as a pair."
+    SYNTAX       OCTET STRING (SIZE (1..255))
+
+
+
+InetAddressPrefixLength ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+        "Denotes the length of a generic Internet network address
+         prefix. A value of n corresponds to an IP address mask
+         which has n contiguous 1-bits from the most significant
+         bit (MSB) and all other bits set to 0.
+
+         An InetAddressPrefixLength value is always interpreted within
+         the context of an InetAddressType value. Every usage of the
+         InetAddressPrefixLength textual convention is required to
+         specify the InetAddressType object which provides the
+         context.  It is suggested that the InetAddressType object is
+         logically registered before the object(s) which use the
+         InetAddressPrefixLength textual convention if they appear in
+         the same logical row.
+
+         InetAddressPrefixLength values that are larger than
+         the maximum length of an IP address for a specific
+         InetAddressType are treated as the maximum significant
+         value applicable for the InetAddressType. The maximum
+         significant value is 32 for the InetAddressType
+         'ipv4(1)' and 'ipv4z(3)' and 128 for the InetAddressType
+         'ipv6(2)' and 'ipv6z(4)'. The maximum significant value
+         for the InetAddressType 'dns(16)' is 0.
+
+         The value zero is object-specific and must be defined as
+         part of the description of any object which uses this
+         syntax. Examples of the usage of zero might include
+         situations where the Internet network address prefix
+         is unknown or does not apply."
+    SYNTAX      Unsigned32
+
+InetPortNumber ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+        "Represents a 16 bit port number of an Internet transport
+         layer protocol. Port numbers are assigned by IANA. A
+         current list of all assignments is available from
+         <http://www.iana.org/>.
+
+         The value zero is object-specific and must be defined as
+         part of the description of any object which uses this
+         syntax. Examples of the usage of zero might include
+         situations where a port number is unknown, or when the
+         value zero is used as a wildcard in a filter."
+    REFERENCE  "STD 6 (RFC 768), STD 7 (RFC 793) and RFC 2960"
+    SYNTAX      Unsigned32 (0..65535)
+
+
+
+InetAutonomousSystemNumber ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+        "Represents an autonomous system number which identifies an
+         Autonomous System (AS). An AS is a set of routers under a
+         single technical administration, using an interior gateway
+         protocol and common metrics to route packets within the AS,
+         and using an exterior gateway protocol to route packets to
+         other ASs'. IANA maintains the AS number space and has
+         delegated large parts to the regional registries.
+
+         Autonomous system numbers are currently limited to 16 bits
+         (0..65535). There is however work in progress to enlarge the
+         autonomous system number space to 32 bits. This textual
+         convention therefore uses an Unsigned32 value without a
+         range restriction in order to support a larger autonomous
+         system number space."
+    REFERENCE  "RFC 1771, RFC 1930"
+    SYNTAX      Unsigned32
+
+END
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/Makefile BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/Makefile
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/Makefile	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/Makefile	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,51 @@
+# 
+# Copyright (c) 2005 The FreeBSD Project 
+# All rights reserved.
+# Author: Victor Cruceru <soc-victor@freebsd.org>
+#
+# Redistribution of this software and documentation and use in source and
+# binary forms, with or without modification, are permitted provided that
+# the following conditions are met:
+#
+# 1. Redistributions of source code or documentation must retain the above
+#    copyright notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+CONTRIB=${.CURDIR}/../../../../contrib/bsnmp
+
+MOD=	tcp_udp46
+
+SRCS=	tcp_udp46_common.c \
+	tcp46_snmp.c \
+	udp46_snmp.c 
+	
+WARNS?=	6
+
+#Not having NDEBUG defined will enable assertions and a lot of output on stderr
+CFLAGS+=	-DNDEBUG
+
+XSYM=	tcpMIB udpMIB
+	
+DEFS=	${MOD}_tree.def
+
+#INET-ADDRESS-MIB.txt does not belong here
+BMIBS=	TCP-MIB.txt \
+	UDP-MIB.txt \
+	INET-ADDRESS-MIB.txt
+
+.include <bsd.lib.mk>
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/TCP-MIB.txt BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/TCP-MIB.txt
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/TCP-MIB.txt	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/TCP-MIB.txt	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,817 @@
+TCP-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY, OBJECT-TYPE, Integer32, Unsigned32,
+    Gauge32, Counter32, Counter64, IpAddress, mib-2
+                                       FROM SNMPv2-SMI
+    MODULE-COMPLIANCE, OBJECT-GROUP    FROM SNMPv2-CONF
+    InetAddress, InetAddressType,
+    InetPortNumber                     FROM INET-ADDRESS-MIB;
+
+tcpMIB MODULE-IDENTITY
+    LAST-UPDATED "200502180000Z"  -- 18 February 2005
+    ORGANIZATION
+           "IETF IPv6 MIB Revision Team
+            http://www.ietf.org/html.charters/ipv6-charter.html"
+    CONTACT-INFO
+           "Rajiv Raghunarayan (editor)
+
+            Cisco Systems Inc.
+            170 West Tasman Drive
+            San Jose, CA 95134
+
+            Phone: +1 408 853 9612
+            Email: <raraghun@cisco.com>
+
+            Send comments to <ipv6@ietf.org>"
+    DESCRIPTION
+           "The MIB module for managing TCP implementations.
+
+            Copyright (C) The Internet Society (2005). This version
+            of this MIB module is a part of RFC 4022; see the RFC
+            itself for full legal notices."
+    REVISION      "200502180000Z"  -- 18 February 2005
+    DESCRIPTION
+           "IP version neutral revision, published as RFC 4022."
+    REVISION      "9411010000Z"
+    DESCRIPTION
+           "Initial SMIv2 version, published as RFC 2012."
+    REVISION      "9103310000Z"
+    DESCRIPTION
+           "The initial revision of this MIB module was part of
+            MIB-II."
+    ::= { mib-2 49 }
+
+-- the TCP base variables group
+
+
+
+
+tcp      OBJECT IDENTIFIER ::= { mib-2 6 }
+
+-- Scalars
+
+tcpRtoAlgorithm OBJECT-TYPE
+    SYNTAX      INTEGER {
+                    other(1),    -- none of the following
+                    constant(2), -- a constant rto
+                    rsre(3),     -- MIL-STD-1778, Appendix B
+                    vanj(4),     -- Van Jacobson's algorithm
+                    rfc2988(5)   -- RFC 2988
+                }
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The algorithm used to determine the timeout value used for
+            retransmitting unacknowledged octets."
+    ::= { tcp 1 }
+
+tcpRtoMin OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    UNITS      "milliseconds"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The minimum value permitted by a TCP implementation for
+            the retransmission timeout, measured in milliseconds.
+            More refined semantics for objects of this type depend
+            on the algorithm used to determine the retransmission
+            timeout; in particular, the IETF standard algorithm
+            rfc2988(5) provides a minimum value."
+    ::= { tcp 2 }
+
+tcpRtoMax OBJECT-TYPE
+    SYNTAX     Integer32 (0..2147483647)
+    UNITS      "milliseconds"
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The maximum value permitted by a TCP implementation for
+            the retransmission timeout, measured in milliseconds.
+            More refined semantics for objects of this type depend
+            on the algorithm used to determine the retransmission
+            timeout; in particular, the IETF standard algorithm
+            rfc2988(5) provides an upper bound (as part of an
+            adaptive backoff algorithm)."
+    ::= { tcp 3 }
+
+
+
+
+tcpMaxConn OBJECT-TYPE
+    SYNTAX     Integer32 (-1 | 0..2147483647)
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The limit on the total number of TCP connections the entity
+            can support.  In entities where the maximum number of
+            connections is dynamic, this object should contain the
+            value -1."
+    ::= { tcp 4 }
+
+tcpActiveOpens OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of times that TCP connections have made a direct
+            transition to the SYN-SENT state from the CLOSED state.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 5 }
+
+tcpPassiveOpens OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of times TCP connections have made a direct
+            transition to the SYN-RCVD state from the LISTEN state.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 6 }
+
+tcpAttemptFails OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of times that TCP connections have made a direct
+            transition to the CLOSED state from either the SYN-SENT
+            state or the SYN-RCVD state, plus the number of times that
+            TCP connections have made a direct transition to the
+            LISTEN state from the SYN-RCVD state.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+
+
+
+    ::= { tcp 7 }
+
+tcpEstabResets OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of times that TCP connections have made a direct
+            transition to the CLOSED state from either the ESTABLISHED
+            state or the CLOSE-WAIT state.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 8 }
+
+tcpCurrEstab OBJECT-TYPE
+    SYNTAX     Gauge32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of TCP connections for which the current state
+            is either ESTABLISHED or CLOSE-WAIT."
+    ::= { tcp 9 }
+
+tcpInSegs OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments received, including those
+            received in error.  This count includes segments received
+            on currently established connections.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 10 }
+
+tcpOutSegs OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments sent, including those on
+            current connections but excluding those containing only
+            retransmitted octets.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+
+
+
+    ::= { tcp 11 }
+
+tcpRetransSegs OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments retransmitted; that is, the
+            number of TCP segments transmitted containing one or more
+            previously transmitted octets.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 12 }
+
+tcpInErrs OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments received in error (e.g., bad
+            TCP checksums).
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 14 }
+
+tcpOutRsts OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of TCP segments sent containing the RST flag.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 15 }
+
+-- { tcp 16 } was used to represent the ipv6TcpConnTable in RFC 2452,
+-- which has since been obsoleted.  It MUST not be used.
+
+tcpHCInSegs OBJECT-TYPE
+    SYNTAX     Counter64
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments received, including those
+            received in error.  This count includes segments received
+
+
+
+            on currently established connections.  This object is
+            the 64-bit equivalent of tcpInSegs.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 17 }
+
+tcpHCOutSegs OBJECT-TYPE
+    SYNTAX     Counter64
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of segments sent, including those on
+            current connections but excluding those containing only
+            retransmitted octets.  This object is the 64-bit
+            equivalent of tcpOutSegs.
+
+            Discontinuities in the value of this counter are
+            indicated via discontinuities in the value of sysUpTime."
+    ::= { tcp 18 }
+
+
+-- The TCP Connection table
+
+tcpConnectionTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF TcpConnectionEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "A table containing information about existing TCP
+            connections.  Note that unlike earlier TCP MIBs, there
+            is a separate table for connections in the LISTEN state."
+    ::= { tcp 19 }
+
+tcpConnectionEntry OBJECT-TYPE
+    SYNTAX     TcpConnectionEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "A conceptual row of the tcpConnectionTable containing
+            information about a particular current TCP connection.
+            Each row of this table is transient in that it ceases to
+            exist when (or soon after) the connection makes the
+            transition to the CLOSED state."
+    INDEX   { tcpConnectionLocalAddressType,
+              tcpConnectionLocalAddress,
+              tcpConnectionLocalPort,
+              tcpConnectionRemAddressType,
+              tcpConnectionRemAddress,
+              tcpConnectionRemPort }
+    ::= { tcpConnectionTable 1 }
+
+TcpConnectionEntry ::= SEQUENCE {
+        tcpConnectionLocalAddressType   InetAddressType,
+        tcpConnectionLocalAddress       InetAddress,
+        tcpConnectionLocalPort          InetPortNumber,
+        tcpConnectionRemAddressType     InetAddressType,
+        tcpConnectionRemAddress         InetAddress,
+        tcpConnectionRemPort            InetPortNumber,
+        tcpConnectionState              INTEGER,
+        tcpConnectionProcess            Unsigned32
+    }
+
+tcpConnectionLocalAddressType OBJECT-TYPE
+    SYNTAX     InetAddressType
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The address type of tcpConnectionLocalAddress."
+    ::= { tcpConnectionEntry 1 }
+
+tcpConnectionLocalAddress OBJECT-TYPE
+    SYNTAX     InetAddress
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local IP address for this TCP connection.  The type
+            of this address is determined by the value of
+            tcpConnectionLocalAddressType.
+
+            As this object is used in the index for the
+            tcpConnectionTable, implementors should be
+            careful not to create entries that would result in OIDs
+            with more than 128 subidentifiers; otherwise the information
+            cannot be accessed by using SNMPv1, SNMPv2c, or SNMPv3."
+    ::= { tcpConnectionEntry 2 }
+
+tcpConnectionLocalPort OBJECT-TYPE
+    SYNTAX     InetPortNumber
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local port number for this TCP connection."
+    ::= { tcpConnectionEntry 3 }
+
+tcpConnectionRemAddressType OBJECT-TYPE
+
+
+
+    SYNTAX     InetAddressType
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The address type of tcpConnectionRemAddress."
+    ::= { tcpConnectionEntry 4 }
+
+tcpConnectionRemAddress OBJECT-TYPE
+    SYNTAX     InetAddress
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The remote IP address for this TCP connection.  The type
+            of this address is determined by the value of
+            tcpConnectionRemAddressType.
+
+            As this object is used in the index for the
+            tcpConnectionTable, implementors should be
+            careful not to create entries that would result in OIDs
+            with more than 128 subidentifiers; otherwise the information
+            cannot be accessed by using SNMPv1, SNMPv2c, or SNMPv3."
+    ::= { tcpConnectionEntry 5 }
+
+tcpConnectionRemPort OBJECT-TYPE
+    SYNTAX     InetPortNumber
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The remote port number for this TCP connection."
+    ::= { tcpConnectionEntry 6 }
+
+tcpConnectionState OBJECT-TYPE
+    SYNTAX     INTEGER {
+                    closed(1),
+                    listen(2),
+                    synSent(3),
+                    synReceived(4),
+                    established(5),
+                    finWait1(6),
+                    finWait2(7),
+                    closeWait(8),
+                    lastAck(9),
+                    closing(10),
+                    timeWait(11),
+                    deleteTCB(12)
+                }
+    MAX-ACCESS read-write
+    STATUS     current
+
+
+
+    DESCRIPTION
+           "The state of this TCP connection.
+
+            The value listen(2) is included only for parallelism to the
+            old tcpConnTable and should not be used.  A connection in
+            LISTEN state should be present in the tcpListenerTable.
+
+            The only value that may be set by a management station is
+            deleteTCB(12).  Accordingly, it is appropriate for an agent
+            to return a `badValue' response if a management station
+            attempts to set this object to any other value.
+
+            If a management station sets this object to the value
+            deleteTCB(12), then the TCB (as defined in [RFC793]) of
+            the corresponding connection on the managed node is
+            deleted, resulting in immediate termination of the
+            connection.
+
+            As an implementation-specific option, a RST segment may be
+            sent from the managed node to the other TCP endpoint (note,
+            however, that RST segments are not sent reliably)."
+    ::= { tcpConnectionEntry 7 }
+
+tcpConnectionProcess OBJECT-TYPE
+    SYNTAX     Unsigned32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The system's process ID for the process associated with
+            this connection, or zero if there is no such process.  This
+            value is expected to be the same as HOST-RESOURCES-MIB::
+            hrSWRunIndex or SYSAPPL-MIB::sysApplElmtRunIndex for some
+            row in the appropriate tables."
+    ::= { tcpConnectionEntry 8 }
+
+-- The TCP Listener table
+
+tcpListenerTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF TcpListenerEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "A table containing information about TCP listeners.  A
+            listening application can be represented in three
+            possible ways:
+
+            1. An application that is willing to accept both IPv4 and
+               IPv6 datagrams is represented by
+               a tcpListenerLocalAddressType of unknown (0) and
+               a tcpListenerLocalAddress of ''h (a zero-length
+               octet-string).
+
+            2. An application that is willing to accept only IPv4 or
+               IPv6 datagrams is represented by a
+               tcpListenerLocalAddressType of the appropriate address
+               type and a tcpListenerLocalAddress of '0.0.0.0' or '::'
+               respectively.
+
+            3. An application that is listening for data destined
+               only to a specific IP address, but from any remote
+               system, is represented by a tcpListenerLocalAddressType
+               of an appropriate address type, with
+               tcpListenerLocalAddress as the specific local address.
+
+            NOTE: The address type in this table represents the
+            address type used for the communication, irrespective
+            of the higher-layer abstraction.  For example, an
+            application using IPv6 'sockets' to communicate via
+            IPv4 between ::ffff:10.0.0.1 and ::ffff:10.0.0.2 would
+            use InetAddressType ipv4(1))."
+    ::= { tcp 20 }
+
+tcpListenerEntry OBJECT-TYPE
+    SYNTAX     TcpListenerEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "A conceptual row of the tcpListenerTable containing
+            information about a particular TCP listener."
+    INDEX   { tcpListenerLocalAddressType,
+              tcpListenerLocalAddress,
+              tcpListenerLocalPort }
+    ::= { tcpListenerTable 1 }
+
+TcpListenerEntry ::= SEQUENCE {
+        tcpListenerLocalAddressType       InetAddressType,
+        tcpListenerLocalAddress           InetAddress,
+        tcpListenerLocalPort              InetPortNumber,
+        tcpListenerProcess                Unsigned32
+    }
+
+tcpListenerLocalAddressType OBJECT-TYPE
+    SYNTAX     InetAddressType
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+
+
+
+           "The address type of tcpListenerLocalAddress.  The value
+            should be unknown (0) if connection initiations to all
+            local IP addresses are accepted."
+    ::= { tcpListenerEntry 1 }
+
+tcpListenerLocalAddress OBJECT-TYPE
+    SYNTAX     InetAddress
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local IP address for this TCP connection.
+
+            The value of this object can be represented in three
+            possible ways, depending on the characteristics of the
+            listening application:
+
+            1. For an application willing to accept both IPv4 and
+               IPv6 datagrams, the value of this object must be
+               ''h (a zero-length octet-string), with the value
+               of the corresponding tcpListenerLocalAddressType
+               object being unknown (0).
+
+            2. For an application willing to accept only IPv4 or
+               IPv6 datagrams, the value of this object must be
+               '0.0.0.0' or '::' respectively, with
+               tcpListenerLocalAddressType representing the
+               appropriate address type.
+
+            3. For an application which is listening for data
+               destined only to a specific IP address, the value
+               of this object is the specific local address, with
+               tcpListenerLocalAddressType representing the
+               appropriate address type.
+
+            As this object is used in the index for the
+            tcpListenerTable, implementors should be
+            careful not to create entries that would result in OIDs
+            with more than 128 subidentifiers; otherwise the information
+            cannot be accessed, using SNMPv1, SNMPv2c, or SNMPv3."
+    ::= { tcpListenerEntry 2 }
+
+tcpListenerLocalPort OBJECT-TYPE
+    SYNTAX     InetPortNumber
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local port number for this TCP connection."
+    ::= { tcpListenerEntry 3 }
+
+
+
+tcpListenerProcess OBJECT-TYPE
+    SYNTAX     Unsigned32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The system's process ID for the process associated with
+            this listener, or zero if there is no such process.  This
+            value is expected to be the same as HOST-RESOURCES-MIB::
+            hrSWRunIndex or SYSAPPL-MIB::sysApplElmtRunIndex for some
+            row in the appropriate tables."
+    ::= { tcpListenerEntry 4 }
+
+
+-- The deprecated TCP Connection table
+
+tcpConnTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF TcpConnEntry
+    MAX-ACCESS not-accessible
+    STATUS     deprecated
+    DESCRIPTION
+           "A table containing information about existing IPv4-specific
+            TCP connections or listeners.  This table has been
+            deprecated in favor of the version neutral
+            tcpConnectionTable."
+    ::= { tcp 13 }
+
+tcpConnEntry OBJECT-TYPE
+    SYNTAX     TcpConnEntry
+    MAX-ACCESS not-accessible
+    STATUS     deprecated
+    DESCRIPTION
+           "A conceptual row of the tcpConnTable containing information
+            about a particular current IPv4 TCP connection.  Each row
+            of this table is transient in that it ceases to exist when
+            (or soon after) the connection makes the transition to the
+            CLOSED state."
+    INDEX   { tcpConnLocalAddress,
+              tcpConnLocalPort,
+              tcpConnRemAddress,
+              tcpConnRemPort }
+    ::= { tcpConnTable 1 }
+
+TcpConnEntry ::= SEQUENCE {
+        tcpConnState         INTEGER,
+        tcpConnLocalAddress  IpAddress,
+        tcpConnLocalPort     Integer32,
+        tcpConnRemAddress    IpAddress,
+        tcpConnRemPort       Integer32
+    }
+
+tcpConnState OBJECT-TYPE
+    SYNTAX     INTEGER {
+                    closed(1),
+                    listen(2),
+                    synSent(3),
+                    synReceived(4),
+                    established(5),
+                    finWait1(6),
+                    finWait2(7),
+                    closeWait(8),
+                    lastAck(9),
+                    closing(10),
+                    timeWait(11),
+                    deleteTCB(12)
+                }
+    MAX-ACCESS read-write
+    STATUS     deprecated
+    DESCRIPTION
+           "The state of this TCP connection.
+
+            The only value that may be set by a management station is
+            deleteTCB(12).  Accordingly, it is appropriate for an agent
+            to return a `badValue' response if a management station
+            attempts to set this object to any other value.
+
+            If a management station sets this object to the value
+            deleteTCB(12), then the TCB (as defined in [RFC793]) of
+            the corresponding connection on the managed node is
+            deleted, resulting in immediate termination of the
+            connection.
+
+            As an implementation-specific option, a RST segment may be
+            sent from the managed node to the other TCP endpoint (note,
+            however, that RST segments are not sent reliably)."
+    ::= { tcpConnEntry 1 }
+
+tcpConnLocalAddress OBJECT-TYPE
+    SYNTAX     IpAddress
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The local IP address for this TCP connection.  In the case
+            of a connection in the listen state willing to
+            accept connections for any IP interface associated with the
+            node, the value 0.0.0.0 is used."
+    ::= { tcpConnEntry 2 }
+
+
+
+tcpConnLocalPort OBJECT-TYPE
+    SYNTAX     Integer32 (0..65535)
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The local port number for this TCP connection."
+    ::= { tcpConnEntry 3 }
+
+tcpConnRemAddress OBJECT-TYPE
+    SYNTAX     IpAddress
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The remote IP address for this TCP connection."
+    ::= { tcpConnEntry 4 }
+
+tcpConnRemPort OBJECT-TYPE
+    SYNTAX     Integer32 (0..65535)
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The remote port number for this TCP connection."
+    ::= { tcpConnEntry 5 }
+
+-- conformance information
+
+tcpMIBConformance OBJECT IDENTIFIER ::= { tcpMIB 2 }
+
+tcpMIBCompliances OBJECT IDENTIFIER ::= { tcpMIBConformance 1 }
+tcpMIBGroups      OBJECT IDENTIFIER ::= { tcpMIBConformance 2 }
+
+-- compliance statements
+
+tcpMIBCompliance2 MODULE-COMPLIANCE
+    STATUS     current
+    DESCRIPTION
+           "The compliance statement for systems that implement TCP.
+
+            A number of INDEX objects cannot be
+            represented in the form of OBJECT clauses in SMIv2 but
+            have the following compliance requirements,
+            expressed in OBJECT clause form in this description
+            clause:
+
+            -- OBJECT      tcpConnectionLocalAddressType
+            -- SYNTAX      InetAddressType { ipv4(1), ipv6(2) }
+            -- DESCRIPTION
+            --     This MIB requires support for only global IPv4
+            --     and IPv6 address types.
+            --
+            -- OBJECT      tcpConnectionRemAddressType
+            -- SYNTAX      InetAddressType { ipv4(1), ipv6(2) }
+            -- DESCRIPTION
+            --     This MIB requires support for only global IPv4
+            --     and IPv6 address types.
+            --
+            -- OBJECT      tcpListenerLocalAddressType
+            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
+            --                               ipv6(2) }
+            -- DESCRIPTION
+            --     This MIB requires support for only global IPv4
+            --     and IPv6 address types.  The type unknown also
+            --     needs to be supported to identify a special
+            --     case in the listener table: a listen using
+            --     both IPv4 and IPv6 addresses on the device.
+            --
+           "
+    MODULE  -- this module
+        MANDATORY-GROUPS { tcpBaseGroup, tcpConnectionGroup,
+                           tcpListenerGroup }
+        GROUP       tcpHCGroup
+        DESCRIPTION
+           "This group is mandatory for systems that are capable
+            of receiving or transmitting more than 1 million TCP
+            segments per second.  1 million segments per second will
+            cause a Counter32 to wrap in just over an hour."
+        OBJECT      tcpConnectionState
+        SYNTAX      INTEGER { closed(1), listen(2), synSent(3),
+                              synReceived(4), established(5),
+                              finWait1(6), finWait2(7), closeWait(8),
+                              lastAck(9), closing(10), timeWait(11) }
+        MIN-ACCESS  read-only
+        DESCRIPTION
+           "Write access is not required, nor is support for the value
+            deleteTCB (12)."
+    ::= { tcpMIBCompliances 2 }
+
+tcpMIBCompliance MODULE-COMPLIANCE
+    STATUS     deprecated
+    DESCRIPTION
+           "The compliance statement for IPv4-only systems that
+            implement TCP.  In order to be IP version independent, this
+            compliance statement is deprecated in favor of
+            tcpMIBCompliance2.  However, agents are still encouraged
+            to implement these objects in order to interoperate with
+            the deployed base of managers."
+
+
+
+    MODULE  -- this module
+        MANDATORY-GROUPS { tcpGroup }
+        OBJECT      tcpConnState
+        MIN-ACCESS  read-only
+        DESCRIPTION
+           "Write access is not required."
+    ::= { tcpMIBCompliances 1 }
+
+
+-- units of conformance
+
+tcpGroup OBJECT-GROUP
+    OBJECTS   { tcpRtoAlgorithm, tcpRtoMin, tcpRtoMax,
+                tcpMaxConn, tcpActiveOpens,
+                tcpPassiveOpens, tcpAttemptFails,
+                tcpEstabResets, tcpCurrEstab, tcpInSegs,
+                tcpOutSegs, tcpRetransSegs, tcpConnState,
+                tcpConnLocalAddress, tcpConnLocalPort,
+                tcpConnRemAddress, tcpConnRemPort,
+                tcpInErrs, tcpOutRsts }
+    STATUS     deprecated
+    DESCRIPTION
+           "The tcp group of objects providing for management of TCP
+            entities."
+    ::= { tcpMIBGroups 1 }
+
+tcpBaseGroup OBJECT-GROUP
+    OBJECTS   { tcpRtoAlgorithm, tcpRtoMin, tcpRtoMax,
+                tcpMaxConn, tcpActiveOpens,
+                tcpPassiveOpens, tcpAttemptFails,
+                tcpEstabResets, tcpCurrEstab, tcpInSegs,
+                tcpOutSegs, tcpRetransSegs,
+                tcpInErrs, tcpOutRsts }
+    STATUS     current
+    DESCRIPTION
+           "The group of counters common to TCP entities."
+    ::= { tcpMIBGroups 2 }
+
+tcpConnectionGroup OBJECT-GROUP
+    OBJECTS    { tcpConnectionState, tcpConnectionProcess }
+    STATUS     current
+    DESCRIPTION
+           "The group provides general information about TCP
+            connections."
+    ::= { tcpMIBGroups 3 }
+
+tcpListenerGroup OBJECT-GROUP
+    OBJECTS    { tcpListenerProcess }
+
+
+
+    STATUS     current
+    DESCRIPTION
+           "This group has objects providing general information about
+            TCP listeners."
+    ::= { tcpMIBGroups 4 }
+
+tcpHCGroup OBJECT-GROUP
+    OBJECTS    { tcpHCInSegs, tcpHCOutSegs }
+    STATUS     current
+    DESCRIPTION
+           "The group of objects providing for counters of high speed
+            TCP implementations."
+    ::= { tcpMIBGroups 5 }
+
+END
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/UDP-MIB.txt BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/UDP-MIB.txt
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/UDP-MIB.txt	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/UDP-MIB.txt	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,571 @@
+UDP-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY, OBJECT-TYPE, Integer32, Counter32, Counter64,
+    Unsigned32, IpAddress, mib-2       FROM SNMPv2-SMI
+    MODULE-COMPLIANCE, OBJECT-GROUP    FROM SNMPv2-CONF
+    InetAddress, InetAddressType,
+    InetPortNumber                     FROM INET-ADDRESS-MIB;
+
+udpMIB MODULE-IDENTITY
+    LAST-UPDATED "200505200000Z"  -- May 20, 2005
+    ORGANIZATION
+           "IETF IPv6 Working Group
+            http://www.ietf.org/html.charters/ipv6-charter.html"
+    CONTACT-INFO
+           "Bill Fenner (editor)
+
+            AT&T Labs -- Research
+            75 Willow Rd.
+            Menlo Park, CA 94025
+
+            Phone: +1 650 330-7893
+            Email: <fenner@research.att.com>
+
+            John Flick (editor)
+
+            Hewlett-Packard Company
+            8000 Foothills Blvd. M/S 5557
+            Roseville, CA 95747
+
+            Phone: +1 916 785 4018
+            Email: <john.flick@hp.com>
+
+            Send comments to <ipv6@ietf.org>"
+
+
+
+    DESCRIPTION
+           "The MIB module for managing UDP implementations.
+            Copyright (C) The Internet Society (2005).  This
+            version of this MIB module is part of RFC 4113;
+            see the RFC itself for full legal notices."
+    REVISION      "200505200000Z"  -- May 20, 2005
+    DESCRIPTION
+           "IP version neutral revision, incorporating the
+            following revisions:
+
+            - Added udpHCInDatagrams and udpHCOutDatagrams in order
+              to provide high-capacity counters for fast networks.
+            - Added text to the descriptions of all counter objects
+              to indicate how discontinuities are detected.
+            - Deprecated the IPv4-specific udpTable and replaced it
+              with the version neutral udpEndpointTable.  This
+              table includes support for connected UDP endpoints
+              and support for identification of the operating
+              system process associated with a UDP endpoint.
+            - Deprecated the udpGroup and replaced it with object
+              groups representing the current set of objects.
+            - Deprecated udpMIBCompliance and replaced it with
+              udpMIBCompliance2, which includes the compliance
+              information for the new object groups.
+
+            This version published as RFC 4113."
+    REVISION      "199411010000Z"    -- November 1, 1994
+    DESCRIPTION
+           "Initial SMIv2 version, published as RFC 2013."
+    REVISION      "199103310000Z"    -- March 31, 1991
+    DESCRIPTION
+           "The initial revision of this MIB module was part of
+            MIB-II, published as RFC 1213."
+    ::= { mib-2 50 }
+
+-- the UDP group
+
+udp      OBJECT IDENTIFIER ::= { mib-2 7 }
+
+udpInDatagrams OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of UDP datagrams delivered to UDP
+            users.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 1 }
+
+udpNoPorts OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of received UDP datagrams for which
+            there was no application at the destination port.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 2 }
+
+udpInErrors OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The number of received UDP datagrams that could not be
+            delivered for reasons other than the lack of an
+            application at the destination port.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 3 }
+
+udpOutDatagrams OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of UDP datagrams sent from this
+            entity.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 4 }
+
+
+
+udpHCInDatagrams OBJECT-TYPE
+    SYNTAX     Counter64
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of UDP datagrams delivered to UDP
+            users, for devices that can receive more than 1
+            million UDP datagrams per second.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 8 }
+
+udpHCOutDatagrams OBJECT-TYPE
+    SYNTAX     Counter64
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The total number of UDP datagrams sent from this
+            entity, for devices that can transmit more than 1
+            million UDP datagrams per second.
+
+            Discontinuities in the value of this counter can occur
+            at re-initialization of the management system, and at
+            other times as indicated by discontinuities in the
+            value of sysUpTime."
+    ::= { udp 9 }
+
+--
+-- { udp 6 } was defined as the ipv6UdpTable in RFC2454's
+-- IPV6-UDP-MIB.  This RFC obsoletes RFC 2454, so { udp 6 } is
+-- obsoleted.
+--
+
+-- The UDP "Endpoint" table.
+
+udpEndpointTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF UdpEndpointEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "A table containing information about this entity's UDP
+            endpoints on which a local application is currently
+            accepting or sending datagrams.
+
+            The address type in this table represents the address
+            type used for the communication, irrespective of the
+            higher-layer abstraction.  For example, an application
+            using IPv6 'sockets' to communicate via IPv4 between
+            ::ffff:10.0.0.1 and ::ffff:10.0.0.2 would use
+            InetAddressType ipv4(1).
+
+            Unlike the udpTable in RFC 2013, this table also allows
+            the representation of an application that completely
+            specifies both local and remote addresses and ports.  A
+            listening application is represented in three possible
+            ways:
+
+            1) An application that is willing to accept both IPv4
+               and IPv6 datagrams is represented by a
+               udpEndpointLocalAddressType of unknown(0) and a
+               udpEndpointLocalAddress of ''h (a zero-length
+               octet-string).
+
+            2) An application that is willing to accept only IPv4
+               or only IPv6 datagrams is represented by a
+               udpEndpointLocalAddressType of the appropriate
+               address type and a udpEndpointLocalAddress of
+               '0.0.0.0' or '::' respectively.
+
+            3) An application that is listening for datagrams only
+               for a specific IP address but from any remote
+               system is represented by a
+               udpEndpointLocalAddressType of the appropriate
+               address type, with udpEndpointLocalAddress
+               specifying the local address.
+
+            In all cases where the remote is a wildcard, the
+            udpEndpointRemoteAddressType is unknown(0), the
+            udpEndpointRemoteAddress is ''h (a zero-length
+            octet-string), and the udpEndpointRemotePort is 0.
+
+            If the operating system is demultiplexing UDP packets
+            by remote address and port, or if the application has
+            'connected' the socket specifying a default remote
+            address and port, the udpEndpointRemote* values should
+            be used to reflect this."
+    ::= { udp 7 }
+
+udpEndpointEntry OBJECT-TYPE
+    SYNTAX     UdpEndpointEntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+
+
+
+    DESCRIPTION
+           "Information about a particular current UDP endpoint.
+
+            Implementers need to be aware that if the total number
+            of elements (octets or sub-identifiers) in
+            udpEndpointLocalAddress and udpEndpointRemoteAddress
+            exceeds 111, then OIDs of column instances in this table
+            will have more than 128 sub-identifiers and cannot be
+            accessed using SNMPv1, SNMPv2c, or SNMPv3."
+    INDEX   { udpEndpointLocalAddressType,
+              udpEndpointLocalAddress,
+              udpEndpointLocalPort,
+              udpEndpointRemoteAddressType,
+              udpEndpointRemoteAddress,
+              udpEndpointRemotePort,
+              udpEndpointInstance }
+    ::= { udpEndpointTable 1 }
+
+UdpEndpointEntry ::= SEQUENCE {
+        udpEndpointLocalAddressType   InetAddressType,
+        udpEndpointLocalAddress       InetAddress,
+        udpEndpointLocalPort          InetPortNumber,
+        udpEndpointRemoteAddressType  InetAddressType,
+        udpEndpointRemoteAddress      InetAddress,
+        udpEndpointRemotePort         InetPortNumber,
+        udpEndpointInstance           Unsigned32,
+        udpEndpointProcess            Unsigned32
+    }
+
+udpEndpointLocalAddressType OBJECT-TYPE
+    SYNTAX     InetAddressType
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The address type of udpEndpointLocalAddress.  Only
+            IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or
+            unknown(0) if datagrams for all local IP addresses are
+            accepted."
+    ::= { udpEndpointEntry 1 }
+
+udpEndpointLocalAddress OBJECT-TYPE
+    SYNTAX     InetAddress
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local IP address for this UDP endpoint.
+
+            The value of this object can be represented in three
+
+
+
+            possible ways, depending on the characteristics of the
+            listening application:
+
+            1. For an application that is willing to accept both
+               IPv4 and IPv6 datagrams, the value of this object
+               must be ''h (a zero-length octet-string), with
+               the value of the corresponding instance of the
+               udpEndpointLocalAddressType object being unknown(0).
+
+            2. For an application that is willing to accept only IPv4
+               or only IPv6 datagrams, the value of this object
+               must be '0.0.0.0' or '::', respectively, while the
+               corresponding instance of the
+               udpEndpointLocalAddressType object represents the
+               appropriate address type.
+
+            3. For an application that is listening for data
+               destined only to a specific IP address, the value
+               of this object is the specific IP address for which
+               this node is receiving packets, with the
+               corresponding instance of the
+               udpEndpointLocalAddressType object representing the
+               appropriate address type.
+
+            As this object is used in the index for the
+            udpEndpointTable, implementors of this table should be
+            careful not to create entries that would result in OIDs
+            with more than 128 subidentifiers; else the information
+            cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3."
+    ::= { udpEndpointEntry 2 }
+
+udpEndpointLocalPort OBJECT-TYPE
+    SYNTAX     InetPortNumber
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The local port number for this UDP endpoint."
+    ::= { udpEndpointEntry 3 }
+
+udpEndpointRemoteAddressType OBJECT-TYPE
+    SYNTAX     InetAddressType
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The address type of udpEndpointRemoteAddress.  Only
+            IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or
+            unknown(0) if datagrams for all remote IP addresses are
+            accepted.  Also, note that some combinations of
+
+
+
+            udpEndpointLocalAdressType and
+            udpEndpointRemoteAddressType are not supported.  In
+            particular, if the value of this object is not
+            unknown(0), it is expected to always refer to the
+            same IP version as udpEndpointLocalAddressType."
+    ::= { udpEndpointEntry 4 }
+
+udpEndpointRemoteAddress OBJECT-TYPE
+    SYNTAX     InetAddress
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The remote IP address for this UDP endpoint.  If
+            datagrams from any remote system are to be accepted,
+            this value is ''h (a zero-length octet-string).
+            Otherwise, it has the type described by
+            udpEndpointRemoteAddressType and is the address of the
+            remote system from which datagrams are to be accepted
+            (or to which all datagrams will be sent).
+
+            As this object is used in the index for the
+            udpEndpointTable, implementors of this table should be
+            careful not to create entries that would result in OIDs
+            with more than 128 subidentifiers; else the information
+            cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3."
+    ::= { udpEndpointEntry 5 }
+
+udpEndpointRemotePort OBJECT-TYPE
+    SYNTAX     InetPortNumber
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The remote port number for this UDP endpoint.  If
+            datagrams from any remote system are to be accepted,
+            this value is zero."
+    ::= { udpEndpointEntry 6 }
+
+udpEndpointInstance OBJECT-TYPE
+    SYNTAX     Unsigned32 (1..'ffffffff'h)
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+           "The instance of this tuple.  This object is used to
+            distinguish among multiple processes 'connected' to
+            the same UDP endpoint.  For example, on a system
+            implementing the BSD sockets interface, this would be
+            used to support the SO_REUSEADDR and SO_REUSEPORT
+            socket options."
+
+
+
+    ::= { udpEndpointEntry 7 }
+
+udpEndpointProcess OBJECT-TYPE
+    SYNTAX     Unsigned32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+           "The system's process ID for the process associated with
+            this endpoint, or zero if there is no such process.
+            This value is expected to be the same as
+            HOST-RESOURCES-MIB::hrSWRunIndex or SYSAPPL-MIB::
+            sysApplElmtRunIndex for some row in the appropriate
+            tables."
+    ::= { udpEndpointEntry 8 }
+
+-- The deprecated UDP Listener table
+
+-- The deprecated UDP listener table only contains information
+-- about this entity's IPv4 UDP end-points on which a local
+-- application is currently accepting datagrams.  It does not
+-- provide more detailed connection information, or information
+-- about IPv6 endpoints.
+
+udpTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF UdpEntry
+    MAX-ACCESS not-accessible
+    STATUS     deprecated
+    DESCRIPTION
+           "A table containing IPv4-specific UDP listener
+            information.  It contains information about all local
+            IPv4 UDP end-points on which an application is
+            currently accepting datagrams.  This table has been
+            deprecated in favor of the version neutral
+            udpEndpointTable."
+    ::= { udp 5 }
+
+udpEntry OBJECT-TYPE
+    SYNTAX     UdpEntry
+    MAX-ACCESS not-accessible
+    STATUS     deprecated
+    DESCRIPTION
+           "Information about a particular current UDP listener."
+    INDEX   { udpLocalAddress, udpLocalPort }
+    ::= { udpTable 1 }
+
+UdpEntry ::= SEQUENCE {
+    udpLocalAddress   IpAddress,
+    udpLocalPort      Integer32
+
+
+
+}
+
+udpLocalAddress OBJECT-TYPE
+    SYNTAX     IpAddress
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The local IP address for this UDP listener.  In the
+            case of a UDP listener that is willing to accept
+            datagrams for any IP interface associated with the
+            node, the value 0.0.0.0 is used."
+    ::= { udpEntry 1 }
+
+udpLocalPort OBJECT-TYPE
+    SYNTAX     Integer32 (0..65535)
+    MAX-ACCESS read-only
+    STATUS     deprecated
+    DESCRIPTION
+           "The local port number for this UDP listener."
+    ::= { udpEntry 2 }
+
+-- conformance information
+
+udpMIBConformance OBJECT IDENTIFIER ::= { udpMIB 2 }
+udpMIBCompliances OBJECT IDENTIFIER ::= { udpMIBConformance 1 }
+udpMIBGroups      OBJECT IDENTIFIER ::= { udpMIBConformance 2 }
+
+-- compliance statements
+
+udpMIBCompliance2 MODULE-COMPLIANCE
+    STATUS     current
+    DESCRIPTION
+           "The compliance statement for systems that implement
+            UDP.
+
+            There are a number of INDEX objects that cannot be
+            represented in the form of OBJECT clauses in SMIv2, but
+            for which we have the following compliance
+            requirements, expressed in OBJECT clause form in this
+            description clause:
+
+            -- OBJECT      udpEndpointLocalAddressType
+            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
+            --                               ipv6(2), ipv4z(3),
+            --                               ipv6z(4) }
+            -- DESCRIPTION
+            --     Support for dns(5) is not required.
+            -- OBJECT      udpEndpointLocalAddress
+
+
+
+            -- SYNTAX      InetAddress (SIZE(0|4|8|16|20))
+            -- DESCRIPTION
+            --     Support is only required for zero-length
+            --     octet-strings, and for scoped and unscoped
+            --     IPv4 and IPv6 addresses.
+            -- OBJECT      udpEndpointRemoteAddressType
+            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
+            --                               ipv6(2), ipv4z(3),
+            --                               ipv6z(4) }
+            -- DESCRIPTION
+            --     Support for dns(5) is not required.
+            -- OBJECT      udpEndpointRemoteAddress
+            -- SYNTAX      InetAddress (SIZE(0|4|8|16|20))
+            -- DESCRIPTION
+            --     Support is only required for zero-length
+            --     octet-strings, and for scoped and unscoped
+            --     IPv4 and IPv6 addresses.
+           "
+    MODULE  -- this module
+         MANDATORY-GROUPS { udpBaseGroup, udpEndpointGroup }
+         GROUP       udpHCGroup
+         DESCRIPTION
+                "This group is mandatory for systems that
+                 are capable of receiving or transmitting more than
+                 1 million UDP datagrams per second.  1 million
+                 datagrams per second will cause a Counter32 to
+                 wrap in just over an hour."
+    ::= { udpMIBCompliances 2 }
+
+udpMIBCompliance MODULE-COMPLIANCE
+    STATUS     deprecated
+    DESCRIPTION
+           "The compliance statement for IPv4-only systems that
+            implement UDP.  For IP version independence, this
+            compliance statement is deprecated in favor of
+            udpMIBCompliance2.  However, agents are still
+            encouraged to implement these objects in order to
+            interoperate with the deployed base of managers."
+    MODULE  -- this module
+        MANDATORY-GROUPS { udpGroup }
+    ::= { udpMIBCompliances 1 }
+
+-- units of conformance
+
+udpGroup OBJECT-GROUP
+    OBJECTS   { udpInDatagrams, udpNoPorts,
+                udpInErrors, udpOutDatagrams,
+                udpLocalAddress, udpLocalPort }
+
+
+
+    STATUS     deprecated
+    DESCRIPTION
+           "The deprecated group of objects providing for
+            management of UDP over IPv4."
+    ::= { udpMIBGroups 1 }
+
+udpBaseGroup OBJECT-GROUP
+    OBJECTS   { udpInDatagrams, udpNoPorts, udpInErrors,
+                udpOutDatagrams }
+    STATUS     current
+    DESCRIPTION
+           "The group of objects providing for counters of UDP
+            statistics."
+    ::= { udpMIBGroups 2 }
+
+udpHCGroup OBJECT-GROUP
+    OBJECTS   { udpHCInDatagrams, udpHCOutDatagrams }
+    STATUS     current
+    DESCRIPTION
+           "The group of objects providing for counters of high
+            speed UDP implementations."
+    ::= { udpMIBGroups 3 }
+
+udpEndpointGroup OBJECT-GROUP
+    OBJECTS    { udpEndpointProcess }
+    STATUS     current
+    DESCRIPTION
+           "The group of objects providing for the IP version
+            independent management of UDP 'endpoints'."
+    ::= { udpMIBGroups 4 }
+
+END
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp46_snmp.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp46_snmp.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp46_snmp.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp46_snmp.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,1362 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * TCP-MIB implementation for SNMPd: instrumentation for RFC 4022 covering 
+ * both IPv4 and IPv6 objects
+ */
+ /* 
+  * The code for this module is based on and inspired by code developed
+  * by Harti Brandt <harti@freebsd.org> under the following copyright:
+  */
+/*
+ * Copyright (c) 2001-2003
+ *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).
+ *	All rights reserved.
+ *
+ * Author: Harti Brandt <harti@freebsd.org>
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Begemot: bsnmp/snmp_mibII/mibII_tcp.c,v 1.7 2005/05/23 09:03:42 brandt_h Exp $
+ *
+ * tcp
+ */
+ /*
+  * The code for tcp delete operation was inspired by the code developed by 
+  * Markus Friedl under the following copyright:
+  */
+ /*-
+ * Copyright (c) 2004 Markus Friedl <markus@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */ 
+
+#include "tcp_udp46.h"
+#include "tcp_udp46_oid.h"
+#include "tcp_udp46_tree.h"
+#include <syslog.h>
+#include <netinet/tcp_timer.h>
+#include <netinet/tcp_fsm.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <sys/sysctl.h>
+
+
+
+
+
+
+enum TCP_ConnState {
+	TCPS_closed =		1,
+	TCPS_listen =		2,
+	TCPS_synSent =		3,
+	TCPS_synReceived =	4,
+	TCPS_established =	5,
+	TCPS_finWait1 =		6,
+	TCPS_finWait2 =		7,
+	TCPS_closeWait =	8,
+	TCPS_lastAck =		9,
+	TCPS_closing =		10,
+	TCPS_timeWait =		11,
+	TCPS_deleteTCB =	12
+};		    
+
+
+
+
+static int
+tcp_compare(const void *p1, const void *p2)
+{
+	int result = 0;
+	const struct tcp_index *t1 = p1;
+	const struct tcp_index *t2 = p2;
+	assert(t1 != NULL);
+	assert(t2 != NULL);
+	if (t1 == NULL || t2 == NULL) {
+		return 0;
+	}
+	result = asn_compare_oid(&t1->index, &t2->index);
+	if ( result == 0 ) {
+		syslog(LOG_ERR, "tcp46 malfunction: two equal oids.");
+		assert(0);
+	}
+	return result;
+}
+
+
+static
+pid_t 
+get_socket_pid(struct xtcpcb *tp) {
+	struct xfile *xf = NULL;
+	u_int n = 0;
+	assert(tp != NULL);
+	
+	for (xf =  tcp_udp46_state_g.xfiles, n = 0; n < tcp_udp46_state_g.xfiles_total; ++n, ++xf) {
+		if (xf->xf_data == NULL) {
+			continue;
+		}	
+		if (xf->xf_data == (void *)tp->xt_socket.xso_so) {
+			return (xf->xf_pid);
+		}	
+	}
+	return ((pid_t)0);		
+}
+
+
+/*
+ * Add an entry into the list associated with the old/ deprecated
+ * tcpConnTable
+ */
+static
+void handle_old_tcp4_entry (struct tcp_index *oid, struct xtcpcb *tp) {
+	in_addr_t inaddr;
+	
+	assert(oid != NULL);
+	assert(tp != NULL);
+	/*next is the encoding for the SNMP table index*/
+	oid->index.len = 10;
+	inaddr = ntohl(tp->xt_inp.inp_laddr.s_addr);
+	oid->index.subs[0] = (inaddr >> 24) & 0xff;
+	oid->index.subs[1] = (inaddr >> 16) & 0xff;
+	oid->index.subs[2] = (inaddr >>  8) & 0xff;
+	oid->index.subs[3] = (inaddr >>  0) & 0xff;
+	oid->index.subs[4] = ntohs(tp->xt_inp.inp_lport);
+	inaddr = ntohl(tp->xt_inp.inp_faddr.s_addr);
+	oid->index.subs[5] = (inaddr >> 24) & 0xff;
+	oid->index.subs[6] = (inaddr >> 16) & 0xff;
+	oid->index.subs[7] = (inaddr >>  8) & 0xff;
+	oid->index.subs[8] = (inaddr >>  0) & 0xff;
+	oid->index.subs[9] = ntohs(tp->xt_inp.inp_fport);
+	
+}
+
+/*
+ * Add a __v4__ entry into the list associated with the new (combined v4 & v6)
+ * tcpConnectionTable
+ */
+static
+void handle_new_tcp4_entry (struct tcp_index *all_oid, struct xtcpcb *tp) {
+	in_addr_t inaddr;
+	assert(all_oid != NULL);
+	assert(tp != NULL);
+	/*next is the encoding for the SNMP table index*/
+	
+	all_oid->index.len = 14;
+	all_oid->index.subs[0] = (uint32_t)IAT_ipv4;
+	all_oid->index.subs[1] = 4;
+	inaddr = ntohl(tp->xt_inp.inp_laddr.s_addr);
+	all_oid->index.subs[2] = (inaddr >> 24) & 0xff;
+	all_oid->index.subs[3] = (inaddr >> 16) & 0xff;
+	all_oid->index.subs[4] = (inaddr >>  8) & 0xff;
+	all_oid->index.subs[5] = (inaddr >>  0) & 0xff;
+	all_oid->index.subs[6] = ntohs(tp->xt_inp.inp_lport);
+	all_oid->index.subs[7] = (uint32_t)IAT_ipv4;
+	all_oid->index.subs[8] = 4;
+	inaddr = ntohl(tp->xt_inp.inp_faddr.s_addr);
+	all_oid->index.subs[9] = (inaddr >> 24) & 0xff;
+	all_oid->index.subs[10] = (inaddr >> 16) & 0xff;
+	all_oid->index.subs[11] = (inaddr >>  8) & 0xff;
+	all_oid->index.subs[12] = (inaddr >>  0) & 0xff;
+	all_oid->index.subs[13] = ntohs(tp->xt_inp.inp_fport);
+	
+
+	all_oid->so_pgid = get_socket_pid(tp);
+
+}
+
+/*
+ * Add a __v6__ entry into the list associated with the new (combined v4 & v6)
+ * tcpConnectionTable
+ */
+static
+void handle_new_tcp6_entry (struct tcp_index *all_oid, struct xtcpcb *tp) {
+	int i = 0;
+	assert(all_oid != NULL);
+	assert(tp != NULL);
+	/*next is the encoding for the SNMP table index*/
+	all_oid->index.len = 38;
+	all_oid->index.subs[0] = (uint32_t)IAT_ipv6;
+	all_oid->index.subs[1] = 16;
+	for (i=0; i<16; i++) {
+		all_oid->index.subs[2+i] = tp->xt_inp.in6p_laddr.s6_addr[i];
+		all_oid->index.subs[21+i] = tp->xt_inp.in6p_faddr.s6_addr[i];
+	}
+	all_oid->index.subs[18] = ntohs(tp->xt_inp.in6p_lport);
+	all_oid->index.subs[19] = (uint32_t)IAT_ipv6;
+	all_oid->index.subs[20] = 16;
+	all_oid->index.subs[37] = ntohs(tp->xt_inp.in6p_fport);
+	
+
+	all_oid->so_pgid = get_socket_pid(tp);
+
+}
+
+
+/*
+ * returns 1 if one duplicate listener found
+ * and 0 otherways
+ */
+static
+int
+check_duplicate6_listner(struct tcp_index *listener_oid, struct xtcpcb *tp){
+	struct tcp_index *_oid = NULL;
+	u_int i = 0;
+	static 
+	uint32_t zero_ip6[] ={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	
+	if (tcp_udp46_state_g.listen_tcpoids_len == 0) {
+		/*empty list, no duplicates*/
+		return 0;
+	}
+	if ( tp->xt_inp.inp_laddr.s_addr != INADDR_ANY ) {
+		L4_DPRINTF((stderr, "V4 [%s] Skipped one listener (not an INADDR_ANY v4).\n ", 
+		__func__)); 		
+		return 0;
+	}
+	L4_DPRINTF((stderr, "V4: [%s] Adding INADDR_ANY v4 listener with port %d.\n ", 
+			__func__,
+			ntohs(tp->xt_inp.inp_lport))); 	
+			
+	
+	for (_oid = tcp_udp46_state_g.listen_tcpoids; 
+		_oid != listener_oid && i < tcp_udp46_state_g.listen_tcpoids_len;
+		i++, _oid++ )
+	{
+		if ( _oid->index.subs[0] == (uint32_t)IAT_ipv6 ) {
+			if ( _oid->index.subs[18] == ntohs(tp->xt_inp.inp_lport) && 
+				listener_oid->so_pgid == _oid->so_pgid) {
+				L4_DPRINTF((stderr, "V4: [%s] Got listener with port %d.\n ", 
+					__func__,
+					_oid->index.subs[18])); 		
+				
+				if (memcmp(&zero_ip6[0], 
+					&_oid->index.subs[2], 
+					sizeof(zero_ip6)) == 0) {
+					/*got it*/
+					_oid->index.len = 3;	
+					_oid->index.subs[0] = (uint32_t)IAT_unknown;
+					_oid->index.subs[1] = 0; /*zero/ empty octet sting*/
+					_oid->index.subs[2] = ntohs(tp->xt_inp.inp_lport);
+					return 1;
+				}
+			}
+		}	
+	}
+	return 0;
+}
+
+/*
+ * returns 1 if one duplicate listener found
+ * and 0 otherways
+ */
+static
+int
+check_duplicate4_listner(struct tcp_index *listener_oid, struct xtcpcb *tp){
+	struct tcp_index *_oid = NULL;
+	u_int i = 0;
+	static 
+	uint32_t zero_ip4[] = { 0, 0, 0, 0 };
+	
+	if (tcp_udp46_state_g.listen_tcpoids_len == 0) {
+		/*empty list, no duplicates*/
+		return 0;
+	}
+	if ( !IN6_IS_ADDR_UNSPECIFIED(&tp->xt_inp.in6p_laddr) ) {
+		L4_DPRINTF((stderr, "[%s] Skipped one listener (not an UNSPECIFIED v6).\n ", 
+		__func__)); 		
+		return 0;
+	}
+	L4_DPRINTF((stderr, "[%s] Adding UNSPECIFIED v6 listener with port %d.\n ", 
+			__func__,
+			ntohs(tp->xt_inp.in6p_lport))); 	
+			
+	for (_oid = tcp_udp46_state_g.listen_tcpoids; 
+		_oid != listener_oid && i < tcp_udp46_state_g.listen_tcpoids_len;
+		i++, _oid++ )
+	{
+	  if ( _oid->index.subs[0] == (uint32_t)IAT_ipv4 ) {
+	    if ( _oid->index.subs[6] == ntohs(tp->xt_inp.in6p_lport) && 
+	     listener_oid->so_pgid == _oid->so_pgid ) {
+		L4_DPRINTF((stderr, "[%s] Got listener with port %d.\n ", 
+			__func__,
+			_oid->index.subs[6])); 		
+				
+		if (memcmp(&zero_ip4[0], 
+			&_oid->index.subs[2], 
+			sizeof(zero_ip4)) == 0) {
+			/*got it*/	
+			_oid->index.len = 3;
+			_oid->index.subs[0] = (uint32_t)IAT_unknown;
+			_oid->index.subs[1] = 0; /*zero/ empty octet sting*/
+			_oid->index.subs[2] = ntohs(tp->xt_inp.in6p_lport);
+			return 1;
+		}
+	    }
+	  }	
+	}
+	return 0;
+}
+
+/*
+ * Add a __v4__ entry into the list associated with the combined v4 & v6
+ * tcpListenerTable
+ * Check for duplicates as described in the MIB:
+ *            1. For an application willing to accept both IPv4 and
+ *              IPv6 datagrams, the value of this object must be
+ *              ''h (a zero-length octet-string), with the value
+ *              of the corresponding tcpListenerLocalAddressType
+ *              object being unknown (0).
+ * Returns 1 if the duplicate was found and processed.
+ * Returns 0 if the entry was new 
+ */
+static
+int handle_tcp4_listener_entry (struct tcp_index *listener_oid, struct xtcpcb *tp) {
+	in_addr_t inaddr;
+	assert(listener_oid != NULL);
+	assert(tp != NULL);
+	
+	listener_oid->so_pgid = get_socket_pid(tp);
+	
+	if ( check_duplicate6_listner( listener_oid, tp ) == 1 ) {
+		return 1;
+	}
+	/*next is the encoding for the SNMP table index*/
+	listener_oid->index.len = 7;
+	listener_oid->index.subs[0] = (uint32_t)IAT_ipv4;
+	listener_oid->index.subs[1] = 4;
+	
+	inaddr = ntohl(tp->xt_inp.inp_laddr.s_addr);
+	listener_oid->index.subs[2] = (inaddr >> 24) & 0xff;
+	listener_oid->index.subs[3] = (inaddr >> 16) & 0xff;
+	listener_oid->index.subs[4] = (inaddr >>  8) & 0xff;
+	listener_oid->index.subs[5] = (inaddr >>  0) & 0xff;
+	listener_oid->index.subs[6] = ntohs(tp->xt_inp.inp_lport);
+	
+	
+	return 0;
+
+}
+
+/*
+ * Add a __v6__ entry into the list associated with the combined v4 & v6
+ * tcpListenerTable
+ * Check for duplicates as described in the MIB:
+ *            1. For an application willing to accept both IPv4 and
+ *              IPv6 datagrams, the value of this object must be
+ *              ''h (a zero-length octet-string), with the value
+ *              of the corresponding tcpListenerLocalAddressType
+ *              object being unknown (0).
+ * Returns 1 if the duplicate was found and processed.
+ * Returns 0 if the entry was new 
+ */
+static
+int handle_tcp6_listener_entry (struct tcp_index *listener_oid, struct xtcpcb *tp) {
+	int i = 0;
+	assert(listener_oid != NULL);
+	assert(tp != NULL);
+	
+	listener_oid->so_pgid = get_socket_pid(tp);
+	
+	if ( check_duplicate4_listner( listener_oid, tp ) == 1 ) {
+		return 1;
+	}
+	
+	/*next is the encoding for the SNMP table index*/
+	listener_oid->index.len = 19;
+	listener_oid->index.subs[0] = (uint32_t)IAT_ipv6;
+	listener_oid->index.subs[1] = 16;
+	
+	for (i=0; i<16; i++) {
+		listener_oid->index.subs[2+i] = tp->xt_inp.in6p_laddr.s6_addr[i];
+	}
+	listener_oid->index.subs[18] = ntohs(tp->xt_inp.in6p_lport);
+	
+	
+	
+	return 0;
+
+}
+
+int
+fetch_xfiles(void) {
+	size_t xfilesize = 0;
+	struct xfile *ptr = NULL;
+	
+	tcp_udp46_state_g.xfiles_total = 0;
+	
+	/* Get the xfiles */
+	if (sysctlbyname("kern.file", NULL, &xfilesize, NULL, 0)) {
+		syslog(LOG_ERR, "sysctlbyname(kern.file) failed: %m");
+		return (-1);
+	}	
+	if (xfilesize > tcp_udp46_state_g.xfiles_len) {
+		if ((ptr = realloc(tcp_udp46_state_g.xfiles, xfilesize)) == NULL) {
+			syslog(LOG_ERR, "%zu: %m", xfilesize);
+			return (-1);
+		}
+		tcp_udp46_state_g.xfiles = ptr;
+		tcp_udp46_state_g.xfiles_len = xfilesize;
+	}
+
+
+	if (sysctlbyname("kern.file", tcp_udp46_state_g.xfiles, &xfilesize, NULL, 0) < 0) {
+		syslog(LOG_ERR, "sysctlbyname(kern.file) failed: %m");
+		return (-1);
+	}
+	tcp_udp46_state_g.xfiles_total = xfilesize / sizeof(struct xfile);
+	return 0;
+}
+
+
+
+int
+fetch_tcp(void)
+{
+	size_t len;
+	struct xinpgen *ptr = NULL;
+	struct xtcpcb *tp = NULL;
+	struct tcp_index *oid = NULL, *all_oid = NULL, *listen_oid = NULL;
+
+
+	len = sizeof(tcp_udp46_state_g.tcpstat);
+	if (sysctlbyname("net.inet.tcp.stats", &tcp_udp46_state_g.tcpstat, &len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "sysctlbyname(net.inet.tcp.stats) failed: %m");
+		return (-1);
+	}
+	if (len != sizeof(tcp_udp46_state_g.tcpstat)) {
+		syslog(LOG_ERR, "sysctlbyname(net.inet.tcp.stats) error: wrong size");
+		return (-1);
+	}
+
+	len = 0;
+	if (sysctlbyname("net.inet.tcp.pcblist", NULL, &len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "sysctlbyname(net.inet.tcp.pcblist) failed: %m");
+		return (-1);
+	}
+	if (len > tcp_udp46_state_g.tcp_xinpgen_len) {
+		if ((ptr = realloc(tcp_udp46_state_g.tcp_xinpgen, len)) == NULL) {
+			syslog(LOG_ERR, "%zu: %m", len);
+			return (-1);
+		}
+		tcp_udp46_state_g.tcp_xinpgen = ptr;
+		tcp_udp46_state_g.tcp_xinpgen_len = len;
+	}
+	if (sysctlbyname("net.inet.tcp.pcblist", tcp_udp46_state_g.tcp_xinpgen, &len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "sysctlbyname(net.inet.tcp.pcblist) failed: %m");
+		return (-1);
+	}
+
+	tcp_udp46_state_g.tcp_tick = get_ticks();
+
+	tcp_udp46_state_g.tcp_estab_count = 0;
+	tcp_udp46_state_g.tcp4_total = 0;
+	tcp_udp46_state_g.all_tcp_total = 0;
+	tcp_udp46_state_g.listen_tcp_total = 0;
+	
+	if (fetch_xfiles() != 0) {
+		L4_DPRINTF((stderr, "[%s] Failed to fetch the xfiles\n ", __func__ ));
+	}
+	
+	/*First count the endpoints*/
+	for (ptr = (struct xinpgen *)(void *)((char *)tcp_udp46_state_g.tcp_xinpgen + tcp_udp46_state_g.tcp_xinpgen->xig_len);
+	     ptr->xig_len > sizeof(struct xinpgen);
+             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
+		tp = (struct xtcpcb *)ptr;
+		assert(ptr != NULL);
+				
+		/* Ignore sockets for protocols other than the desired one. */
+		if ((( struct xtcpcb *)ptr)->xt_socket.xso_protocol != IPPROTO_TCP) {
+			L4_DPRINTF((stderr, "[%s] One tcp4 conn. ignored (protocol missmatch: %d)\n ", 
+			__func__,
+			((struct xinpcb *)ptr)->xi_socket.xso_protocol
+			)); 
+
+			continue;
+		}
+		
+		/* Ignore PCBs which were freed during copyout. */
+		if (tp->xt_inp.inp_gencnt > tcp_udp46_state_g.tcp_xinpgen->xig_gen ) {
+			L4_DPRINTF((stderr, "[%s] One tcp4 conn. ignored (freed during copyout)\n ", 
+			__func__ 
+			)); 
+
+			continue;
+		}
+		
+		
+		if ( (tp->xt_inp.inp_vflag & INP_IPV4) == INP_IPV4) {
+			tcp_udp46_state_g.tcp4_total++;
+		}
+		
+		if ((tp->xt_inp.inp_vflag & (INP_IPV6 | INP_IPV6PROTO | INP_IPV4)) != 0 ) {
+			/*for connection in listen state we have a separate table*/
+			if ( tp->xt_tp.t_state != TCPS_LISTEN ) {
+				tcp_udp46_state_g.all_tcp_total++;
+			} else {
+				tcp_udp46_state_g.listen_tcp_total++;	
+			}
+		}
+		if (tp->xt_tp.t_state == TCPS_ESTABLISHED ||
+		    tp->xt_tp.t_state == TCPS_CLOSE_WAIT) {
+			tcp_udp46_state_g.tcp_estab_count++;
+		}	
+	}
+
+	L4_DPRINTF((stderr, "[%s] Got %d tcp4 connections, %d tcp{4,6} connections, %d tcp{4,6} listeners.\n ", 
+		__func__, 
+		tcp_udp46_state_g.tcp4_total,
+		tcp_udp46_state_g.all_tcp_total,
+		tcp_udp46_state_g.listen_tcp_total)); 
+
+	/*Then reallocate the SNMP holder for v4 if needed*/
+	if (tcp_udp46_state_g.tcp4oids_len < tcp_udp46_state_g.tcp4_total) {
+		oid = realloc(tcp_udp46_state_g.tcp4oids, 
+			tcp_udp46_state_g.tcp4_total * sizeof(tcp_udp46_state_g.tcp4oids[0]));
+		if (oid == NULL) {
+			free(tcp_udp46_state_g.tcp4oids);
+			tcp_udp46_state_g.tcp4oids_len = 0;
+			return (0);
+		}
+		tcp_udp46_state_g.tcp4oids = oid;
+		tcp_udp46_state_g.tcp4oids_len = tcp_udp46_state_g.tcp4_total;
+	}
+
+	/*Then reallocate the SNMP holder for v4 & v6 if needed*/
+	if (tcp_udp46_state_g.all_tcpoids_len < tcp_udp46_state_g.all_tcp_total) {
+		all_oid = realloc(tcp_udp46_state_g.all_tcpoids, 
+			tcp_udp46_state_g.all_tcp_total * sizeof(tcp_udp46_state_g.all_tcpoids[0]));
+		if (all_oid == NULL) {
+			free(tcp_udp46_state_g.all_tcpoids);
+			tcp_udp46_state_g.all_tcpoids_len = 0;
+			return (0);
+		}
+		tcp_udp46_state_g.all_tcpoids = all_oid;
+		tcp_udp46_state_g.all_tcpoids_len = tcp_udp46_state_g.all_tcp_total;
+	}
+	
+	/*Then reallocate the SNMP holder for v4 & v6 listeners if needed*/
+	if (tcp_udp46_state_g.listen_tcpoids_len < tcp_udp46_state_g.listen_tcp_total) {
+		listen_oid = realloc(tcp_udp46_state_g.listen_tcpoids, 
+			tcp_udp46_state_g.listen_tcp_total * sizeof(tcp_udp46_state_g.listen_tcpoids[0]));
+		if (listen_oid == NULL) {
+			free(tcp_udp46_state_g.listen_tcpoids);
+			tcp_udp46_state_g.listen_tcpoids_len = 0;
+			return (0);
+		}
+		tcp_udp46_state_g.listen_tcpoids = listen_oid;
+		tcp_udp46_state_g.listen_tcpoids_len = tcp_udp46_state_g.listen_tcp_total;
+	}
+
+
+	/*Finally fill in the SNMP indexes*/
+        memset(tcp_udp46_state_g.tcp4oids, 0, 
+		tcp_udp46_state_g.tcp4_total * sizeof(tcp_udp46_state_g.tcp4oids[0]) );
+
+        memset(tcp_udp46_state_g.all_tcpoids, 0, 
+		tcp_udp46_state_g.all_tcp_total * sizeof(tcp_udp46_state_g.all_tcpoids[0]) );
+
+        memset(tcp_udp46_state_g.listen_tcpoids, 0, 
+		tcp_udp46_state_g.listen_tcp_total * sizeof(tcp_udp46_state_g.listen_tcpoids[0]) );
+								
+	oid = tcp_udp46_state_g.tcp4oids;
+	all_oid = tcp_udp46_state_g.all_tcpoids;
+	listen_oid = tcp_udp46_state_g.listen_tcpoids;
+	
+	for (ptr = (struct xinpgen *)(void *)((char *)tcp_udp46_state_g.tcp_xinpgen + tcp_udp46_state_g.tcp_xinpgen->xig_len);
+	     ptr->xig_len > sizeof(struct xinpgen);
+             ptr = (struct xinpgen *)(void *)((char *)ptr + ptr->xig_len)) {
+		tp = (struct xtcpcb *)ptr;
+		assert(ptr != NULL);
+		/* Ignore sockets for protocols other than the desired one. */
+		if (((struct  xtcpcb *)ptr)->xt_socket.xso_protocol != IPPROTO_TCP) {
+			continue;
+		}
+		
+		/* Ignore PCBs which were freed during copyout. */
+		if (tp->xt_inp.inp_gencnt > tcp_udp46_state_g.tcp_xinpgen->xig_gen ) {
+			continue;
+		}		
+		if ( (tp->xt_inp.inp_vflag & INP_IPV4) == INP_IPV4) {
+			/*START processing for the old/ deprecated v4 only table*/
+			oid->tp = tp;
+			handle_old_tcp4_entry(oid, tp);
+			oid++;
+			/*END processing for the old/ deprecated v4 only table*/
+			
+			/*for connection in listen state we have a separate table*/
+			if ( tp->xt_tp.t_state != TCPS_LISTEN ) {
+				/*START processing for the new v4/v6 table*/
+				all_oid->tp = tp;
+				handle_new_tcp4_entry(all_oid, tp);
+				all_oid++;
+				/*END processing for the new v4/v6 table*/
+			} else {
+				if (handle_tcp4_listener_entry(listen_oid, tp) == 0 ){
+					listen_oid->tp = tp;
+					listen_oid++;
+				} else {
+					/*this was a duplicate one*/
+					assert(tcp_udp46_state_g.listen_tcp_total > 1);
+					tcp_udp46_state_g.listen_tcp_total--;
+				}
+			}
+
+			
+		} else if ((tp->xt_inp.inp_vflag & (INP_IPV6 | INP_IPV6PROTO)) != 0 ) {
+			if ( tp->xt_tp.t_state != TCPS_LISTEN ) {
+
+				/*START processing for the new v4/v6 table*/
+				all_oid->tp = tp;
+				handle_new_tcp6_entry(all_oid, tp);
+				all_oid++;
+				/*END processing for the new v4/v6 table*/
+			}else {
+				if (handle_tcp6_listener_entry(listen_oid, tp) == 0 ){
+					listen_oid->tp = tp;
+					listen_oid++;
+				} else {
+					/*this was a duplicate one*/
+					assert(tcp_udp46_state_g.listen_tcp_total > 1);
+					tcp_udp46_state_g.listen_tcp_total--;
+				}
+			}
+
+
+		}
+	}
+
+	L4_DPRINTF((stderr, "[%s] Got %d tcp{4,6} DISTINCT listeners.\n ", 
+		__func__, 
+		tcp_udp46_state_g.listen_tcp_total)); 
+		
+	
+	/*Keep the lists sorted ins SNMP index ordering*/
+	qsort( tcp_udp46_state_g.tcp4oids, 
+		tcp_udp46_state_g.tcp4_total, 
+		sizeof(tcp_udp46_state_g.tcp4oids[0]), 
+		tcp_compare);
+
+	qsort( tcp_udp46_state_g.all_tcpoids, 
+		tcp_udp46_state_g.all_tcp_total, 
+		sizeof(tcp_udp46_state_g.all_tcpoids[0]), 
+		tcp_compare);
+
+	qsort( tcp_udp46_state_g.listen_tcpoids, 
+		tcp_udp46_state_g.listen_tcp_total, 
+		sizeof(tcp_udp46_state_g.listen_tcpoids[0]), 
+		tcp_compare);
+
+
+	return (0);
+}
+
+/*
+ * Delete a tcp connection identified by the conn parameter (snmp 
+ * index encoded format). If the _deprecated parameter is 1, then 
+ * the encoding is specified as in the index of the deprecated 
+ * tcpConnTable (v4 only)
+ * Returns 0 for success, <0 if the deletion failed
+ */
+static
+int drop_tcp_conn(struct asn_oid *conn, int _deprecated){
+
+	struct sockaddr_storage addrs[2];
+	int mib[] = { CTL_NET, PF_INET, IPPROTO_TCP, TCPCTL_DROP };
+	char local[64] = "", remote[64] = "";
+	
+	assert(conn != NULL);	
+	memset (&addrs[0], 0, sizeof(addrs));
+
+	if (_deprecated == 0 ){
+
+		if (conn->subs[0] == (uint32_t)IAT_ipv4) {
+			struct sockaddr_in *sinl, *sinr;
+		
+			assert(conn->len == 14);
+			if (conn->len != 14) {
+			  syslog(LOG_ERR, 
+			    "%s: malformed SNMP index (wrong length) when deleting a connection", 
+			    __func__);
+			    return -1;
+			}
+		
+			if (conn->subs[7] != (uint32_t)IAT_ipv4 ) {
+			  syslog(LOG_ERR, 
+			  "%s: malformed SNMP index (remote not a v4) when deleting a connection", 
+			  __func__);
+			  return -1;
+			}
+		
+
+		
+			memset(&addrs[1], 0, sizeof(addrs[1]));
+			sinl = (struct sockaddr_in *)&addrs[1];
+			sinl->sin_len = sizeof(struct sockaddr_in); 
+			sinl->sin_addr.s_addr = htonl(
+				(conn->subs[2] << 24) | 
+				(conn->subs[3] << 16) |
+				(conn->subs[4] << 8)  |	
+				(conn->subs[5] << 0)
+			);
+			sinl->sin_port = htons(conn->subs[6]);
+			addrs[1].ss_family = AF_INET;		
+		
+			(void)inet_ntop(AF_INET, &sinl->sin_addr, local, 64);
+			 
+				 	 
+				
+			memset(&addrs[0], 0, sizeof(addrs[0]));
+			sinr = (struct sockaddr_in *)&addrs[0];
+			sinr->sin_len = sizeof(struct sockaddr_in); 
+		
+			sinr->sin_addr.s_addr = htonl(
+				(conn->subs[9] << 24) | 
+				(conn->subs[10] << 16) |
+				(conn->subs[11] << 8)  |	
+				(conn->subs[12] << 0)
+			);
+			sinr->sin_port = htons(conn->subs[13]);
+			addrs[0].ss_family = AF_INET;
+		
+			(void)inet_ntop(AF_INET, &sinr->sin_addr, remote, 64);
+			syslog(LOG_INFO, 
+			  "[%s] attempt to delete a tcp4 connection : local: %s:%d - remote: %s:%d \n ", 
+			  __func__,
+			  local,
+			  conn->subs[6],
+			  remote,
+			  conn->subs[13]);
+		
+		
+		} else if (conn->subs[0] == (uint32_t)IAT_ipv6) {
+			struct sockaddr_in6 *sin6l, *sin6r;
+			int i = 0;
+			assert(conn->len == 38);
+			if (conn->len != 38) {
+			  syslog(LOG_ERR, 
+			  "%s: malformed SNMP index (wrong length) when deleting a connection", 
+			  __func__);
+			  return -1;
+			}
+		
+			if (conn->subs[19] != (uint32_t)IAT_ipv6 ) {
+			  syslog(LOG_ERR, 
+			  "%s: malformed SNMP index (remote not a v6) when deleting a connection", 
+			  __func__);
+			  return -1;
+			}
+		
+		
+			memset(&addrs[1], 0, sizeof(addrs[1]));
+			sin6l = (struct sockaddr_in6 *)&addrs[1];
+
+			for (i=0; i<16; i++) {
+				sin6l->sin6_addr.s6_addr[i] = conn->subs[2+i];
+			}	
+		
+			sin6l->sin6_port = htons(conn->subs[18]);
+#ifdef SIN6_LEN
+			sin6l->sin6_len = sizeof(struct sockaddr_in6);
+#endif /* SIN6_LEN */		
+			addrs[1].ss_family = AF_INET6;		
+			(void)inet_ntop(AF_INET6, &sin6l->sin6_addr, local, 64);
+		
+			memset(&addrs[0], 0, sizeof(addrs[0]));
+			sin6r = (struct sockaddr_in6 *)&addrs[0];
+
+			for (i=0; i<16; i++) {
+				sin6r->sin6_addr.s6_addr[i] = conn->subs[21+i];
+			}	
+		
+			sin6r->sin6_port = htons(conn->subs[37]);
+#ifdef SIN6_LEN
+			sin6r->sin6_len = sizeof(struct sockaddr_in6);
+#endif /* SIN6_LEN */		
+			addrs[0].ss_family = AF_INET6;		
+		
+			(void)inet_ntop(AF_INET6, &sin6r->sin6_addr, remote, 64);
+		
+			syslog(LOG_INFO, 
+				"[%s] attempt to delete a tcp6 connection: local: %s:%d - remote: %s:%d \n ", 
+				__func__,
+				local,
+				conn->subs[18],
+				remote,
+				conn->subs[37]);
+
+		
+		} else {
+			assert(0);
+			syslog(LOG_ERR, "%s: malformed SNMP index (not v4, not v6) when deleting a connection", 
+				__func__);
+			return -1;
+		
+		}
+	} else {
+		/*This the code for the old/ deprecated tcpConnTable*/
+		struct sockaddr_in *sinl, *sinr;
+	
+		assert(conn->len == 10);
+		if (conn->len != 10) {
+		  syslog(LOG_ERR, 
+		    "%s: malformed SNMP index (wrong length) when deleting a connection", 
+		    __func__);
+		    return -1;
+		}
+	
+	
+
+	
+		memset(&addrs[1], 0, sizeof(addrs[1]));
+		sinl = (struct sockaddr_in *)&addrs[1];
+		sinl->sin_len = sizeof(struct sockaddr_in); 
+		sinl->sin_addr.s_addr = htonl(
+			(conn->subs[0] << 24) | 
+			(conn->subs[1] << 16) |
+			(conn->subs[2] << 8)  |	
+			(conn->subs[3] << 0)
+		);
+		sinl->sin_port = htons(conn->subs[4]);
+		addrs[1].ss_family = AF_INET;		
+	
+		(void)inet_ntop(AF_INET, &sinl->sin_addr, local, 64);
+		 
+				 
+			
+		memset(&addrs[0], 0, sizeof(addrs[0]));
+		sinr = (struct sockaddr_in *)&addrs[0];
+		sinr->sin_len = sizeof(struct sockaddr_in); 
+	
+		sinr->sin_addr.s_addr = htonl(
+			(conn->subs[5] << 24) | 
+			(conn->subs[6] << 16) |
+			(conn->subs[7] << 8)  |	
+			(conn->subs[8] << 0)
+		);
+		sinr->sin_port = htons(conn->subs[9]);
+		addrs[0].ss_family = AF_INET;
+	
+		(void)inet_ntop(AF_INET, &sinr->sin_addr, remote, 64);
+		syslog(LOG_INFO, 
+		 "[%s] attempt to delete a tcp4 connection : local: %s:%d - remote: %s:%d \n ", 
+		 __func__,
+		 local,
+		 conn->subs[4],
+		 remote,
+		 conn->subs[9]);
+	
+		
+	}
+	
+	if (sysctl(mib, sizeof (mib) / sizeof (int), NULL,
+	    NULL, &addrs[0], sizeof(addrs)) == -1) {
+		syslog(LOG_ERR, "%s: failed to delete the specified tcp connection: %m", __func__);
+		return -1;
+	} else {
+		L4_DPRINTF((stderr, "[%s] one tcp connection deleted\n ", 
+			__func__));
+
+		syslog(LOG_INFO, "%s: one tcp connection deleted.", __func__);
+		return 0;
+	
+	}	    
+	/*Unreachable*/
+}
+
+
+/*
+ * Scalars
+ */
+int
+op_tcp(struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:{
+	  	assert(0);
+		return (SNMP_ERR_GENERR);
+	  }	
+
+	  case SNMP_OP_GET:
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT: {
+	  	assert(0);
+		return (SNMP_ERR_NOERROR);
+		
+	  }
+	}
+
+	if (tcp_udp46_state_g.tcp_tick < this_tick)
+		if (fetch_tcp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_tcpRtoAlgorithm:
+		value->v.integer = 4;	/* Van Jacobson */
+		break;
+
+#define hz (tcp_udp46_state_g.clock_info.hz)
+
+	  case LEAF_tcpRtoMin:
+		value->v.integer = 1000 * TCPTV_MIN / hz;
+		break;
+
+	  case LEAF_tcpRtoMax:
+		value->v.integer = 1000 * TCPTV_REXMTMAX / hz;
+		break;
+#undef hz
+	  case LEAF_tcpMaxConn:
+		value->v.integer = -1;
+		break;
+
+	  case LEAF_tcpActiveOpens:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_connattempt;
+		break;
+
+	  case LEAF_tcpPassiveOpens:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_accepts;
+		break;
+
+	  case LEAF_tcpAttemptFails:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_conndrops;
+		break;
+
+	  case LEAF_tcpEstabResets:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_drops;
+		break;
+
+	  case LEAF_tcpCurrEstab:
+		value->v.uint32 = tcp_udp46_state_g.tcp_estab_count;
+		break;
+
+	  case LEAF_tcpInSegs:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_rcvtotal;
+		break;
+
+	  case LEAF_tcpOutSegs:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_sndtotal -
+		    tcp_udp46_state_g.tcpstat.tcps_sndrexmitpack;
+		break;
+
+	  case LEAF_tcpRetransSegs:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_sndrexmitpack;
+		break;
+
+	  case LEAF_tcpInErrs:
+		value->v.uint32 = tcp_udp46_state_g.tcpstat.tcps_rcvbadsum +
+		    tcp_udp46_state_g.tcpstat.tcps_rcvbadoff +
+		    tcp_udp46_state_g.tcpstat.tcps_rcvshort;
+		break;
+		
+	  case LEAF_tcpOutRsts:
+	  	value->v.uint32 = 0;
+	  	break;
+		
+	  case LEAF_tcpHCInSegs:
+	  	value->v.counter64 = tcp_udp46_state_g.tcpstat.tcps_rcvtotal;
+	  	break;
+		
+	  case LEAF_tcpHCOutSegs:
+	  	value->v.counter64 = tcp_udp46_state_g.tcpstat.tcps_sndtotal -
+		    tcp_udp46_state_g.tcpstat.tcps_sndrexmitpack;
+	  	break;
+		
+	  default :
+	  	assert(0);
+		return (SNMP_ERR_NOSUCHNAME);	
+	}
+	return (SNMP_ERR_NOERROR);
+}
+
+
+/*
+ * This is the SNMP handler for the deprecated TCP Connection table
+ * tcpConnTable
+ */
+int	
+op_tcpConnTable( struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	u_int i;
+
+	if (tcp_udp46_state_g.tcp_tick < this_tick)
+		if (fetch_tcp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		for (i = 0; i < tcp_udp46_state_g.tcp4_total; i++)
+			if (index_compare(&value->var, sub, &tcp_udp46_state_g.tcp4oids[i].index) < 0)
+				break;
+		if (i == tcp_udp46_state_g.tcp4_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		index_append(&value->var, sub, &tcp_udp46_state_g.tcp4oids[i].index);
+		break;
+
+	  case SNMP_OP_GET:
+		for (i = 0; i < tcp_udp46_state_g.tcp4_total; i++)
+			if (index_compare(&value->var, sub, &tcp_udp46_state_g.tcp4oids[i].index) == 0)
+				break;
+		if (i == tcp_udp46_state_g.tcp4_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		break;
+
+	  case SNMP_OP_SET: {
+	  	if (value->var.subs[sub - 1] != LEAF_tcpConnState) {
+			return (SNMP_ERR_NOT_WRITEABLE);
+		}
+		if (value->v.integer != (int)TCPS_deleteTCB) {
+			return (SNMP_ERR_WRONG_VALUE);
+		}
+		
+		for (i = 0; i < tcp_udp46_state_g.tcp4_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.tcp4oids[i].index) == 0)
+				break;
+				
+		if (i == tcp_udp46_state_g.tcp4_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		
+		if (drop_tcp_conn(&tcp_udp46_state_g.tcp4oids[i].index, 1) != 0) {		
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		return (SNMP_ERR_NOERROR);
+	  }	
+
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT: {
+	  	return (SNMP_ERR_NOERROR);
+	  }
+	  default:
+		abort();
+	}
+	
+
+		
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_tcpConnState:
+		switch (tcp_udp46_state_g.tcp4oids[i].tp->xt_tp.t_state) {
+
+		  case TCPS_CLOSED:
+			value->v.integer = (int32_t)TCPS_closed;
+			break;
+		  case TCPS_LISTEN:
+			value->v.integer = (int32_t)TCPS_listen;
+			break;
+		  case TCPS_SYN_SENT:
+			value->v.integer = (int32_t)TCPS_synSent;
+			break;
+		  case TCPS_SYN_RECEIVED:
+			value->v.integer = (int32_t)TCPS_synReceived;
+			break;
+		  case TCPS_ESTABLISHED:
+			value->v.integer = (int32_t)TCPS_established;
+			break;
+		  case TCPS_CLOSE_WAIT:
+			value->v.integer = (int32_t)TCPS_closeWait;
+			break;
+		  case TCPS_FIN_WAIT_1:
+			value->v.integer = (int32_t)TCPS_finWait1;
+			break;
+		  case TCPS_CLOSING:
+			value->v.integer = (int32_t)TCPS_closing;
+			break;
+		  case TCPS_LAST_ACK:
+			value->v.integer = (int32_t)TCPS_lastAck;
+			break;
+		  case TCPS_FIN_WAIT_2:
+			value->v.integer = (int32_t)TCPS_finWait2;
+			break;
+		  case TCPS_TIME_WAIT:
+			value->v.integer = (int32_t)TCPS_timeWait;
+			break;
+		  default:
+			value->v.integer = 0;
+			break;
+		}
+		break;
+		
+	  
+	  case LEAF_tcpConnLocalAddress:
+		value->v.ipaddress[0] = tcp_udp46_state_g.tcp4oids[i].index.subs[0];
+		value->v.ipaddress[1] = tcp_udp46_state_g.tcp4oids[i].index.subs[1];
+		value->v.ipaddress[2] = tcp_udp46_state_g.tcp4oids[i].index.subs[2];
+		value->v.ipaddress[3] = tcp_udp46_state_g.tcp4oids[i].index.subs[3];
+		break;
+
+	  case LEAF_tcpConnLocalPort:
+		value->v.integer = tcp_udp46_state_g.tcp4oids[i].index.subs[4];
+		break;
+
+	  case LEAF_tcpConnRemAddress:
+		value->v.ipaddress[0] = tcp_udp46_state_g.tcp4oids[i].index.subs[5];
+		value->v.ipaddress[1] = tcp_udp46_state_g.tcp4oids[i].index.subs[6];
+		value->v.ipaddress[2] = tcp_udp46_state_g.tcp4oids[i].index.subs[7];
+		value->v.ipaddress[3] = tcp_udp46_state_g.tcp4oids[i].index.subs[8];
+		break;
+
+	  case LEAF_tcpConnRemPort:
+		value->v.uint32 = tcp_udp46_state_g.tcp4oids[i].index.subs[9];
+		break;
+	}
+	return (SNMP_ERR_NOERROR);
+}
+
+/*
+ * This is the SNMP handler for the new (v4 & v6) TCP Connection table
+ * tcpConnectionTable
+ */
+int	
+op_tcpConnectionTable( struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	u_int i;
+
+	if (tcp_udp46_state_g.tcp_tick < this_tick)
+		if (fetch_tcp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		for (i = 0; i < tcp_udp46_state_g.all_tcp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.all_tcpoids[i].index) < 0)
+				break;
+		if (i == tcp_udp46_state_g.all_tcp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+			
+		index_append(&value->var, sub, 
+			&tcp_udp46_state_g.all_tcpoids[i].index);
+		break;
+
+	  case SNMP_OP_GET:
+		for (i = 0; i < tcp_udp46_state_g.all_tcp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.all_tcpoids[i].index) == 0)
+				break;
+				
+		if (i == tcp_udp46_state_g.all_tcp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		break;
+
+	  case SNMP_OP_SET: {
+	  	if (value->var.subs[sub - 1] != LEAF_tcpConnectionState) {
+			return (SNMP_ERR_NOT_WRITEABLE);
+		}
+		if (value->v.integer != (int32_t)TCPS_deleteTCB) {
+			return (SNMP_ERR_WRONG_VALUE);
+		}
+		
+		for (i = 0; i < tcp_udp46_state_g.all_tcp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.all_tcpoids[i].index) == 0)
+				break;
+				
+		if (i == tcp_udp46_state_g.all_tcp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		
+		if (drop_tcp_conn(&tcp_udp46_state_g.all_tcpoids[i].index, 0) != 0) {		
+			return (SNMP_ERR_NOSUCHNAME);
+		}
+		return (SNMP_ERR_NOERROR);
+		
+	  }
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT: {
+	  	return (SNMP_ERR_NOERROR);
+	  }
+	  
+	  default:
+		abort();
+	}
+	
+		
+	
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_tcpConnectionState:
+		switch (tcp_udp46_state_g.all_tcpoids[i].tp->xt_tp.t_state) {
+
+		  case TCPS_CLOSED:
+			value->v.integer = (int32_t)TCPS_closed;
+			break;
+		  case TCPS_LISTEN:
+			value->v.integer = (int32_t)TCPS_listen;
+			assert(0);
+			break;
+		  case TCPS_SYN_SENT:
+			value->v.integer = (int32_t)TCPS_synSent;
+			break;
+		  case TCPS_SYN_RECEIVED:
+			value->v.integer = (int32_t)TCPS_synReceived;
+			break;
+		  case TCPS_ESTABLISHED:
+			value->v.integer = (int32_t)TCPS_established;
+			break;
+		  case TCPS_CLOSE_WAIT:
+			value->v.integer = (int32_t)TCPS_closeWait;
+			break;
+		  case TCPS_FIN_WAIT_1:
+			value->v.integer = (int32_t)TCPS_finWait1;
+			break;
+		  case TCPS_CLOSING:
+			value->v.integer = (int32_t)TCPS_closing;
+			break;
+		  case TCPS_LAST_ACK:
+			value->v.integer = (int32_t)TCPS_lastAck;
+			break;
+		  case TCPS_FIN_WAIT_2:
+			value->v.integer = (int32_t)TCPS_finWait2;
+			break;
+		  case TCPS_TIME_WAIT:
+			value->v.integer = (int32_t)TCPS_timeWait;
+			break;
+		  default:
+			value->v.integer = 0;
+			break;
+		}
+		break;
+		
+
+	  
+	  case LEAF_tcpConnectionProcess:
+	  	/*this is from hrSWRunTable, where the index is pid + 1 */
+		value->v.integer = ( tcp_udp46_state_g.all_tcpoids[i].so_pgid == 0 ? 0 : 
+					tcp_udp46_state_g.all_tcpoids[i].so_pgid + 1 ); 
+		break;
+	  default:
+	  	assert(0);	
+		return (SNMP_ERR_NOSUCHNAME);
+	}
+	return (SNMP_ERR_NOERROR);
+
+}
+
+int	
+op_tcpListenerTable(  struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	u_int i;
+
+	if (tcp_udp46_state_g.tcp_tick < this_tick)
+		if (fetch_tcp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		for (i = 0; i < tcp_udp46_state_g.listen_tcp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.listen_tcpoids[i].index) < 0)
+				break;
+		if (i == tcp_udp46_state_g.listen_tcp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+			
+		index_append(&value->var, sub, 
+			&tcp_udp46_state_g.listen_tcpoids[i].index);
+		break;
+
+	  case SNMP_OP_GET:
+		for (i = 0; i < tcp_udp46_state_g.listen_tcp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.listen_tcpoids[i].index) == 0)
+				break;
+				
+		if (i == tcp_udp46_state_g.listen_tcp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  default:
+		abort();
+	}
+	
+		
+	
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_tcpListenerProcess:
+	  	/*this is from hrSWRunTable, where the index is pid + 1 */
+		value->v.uint32 = ( tcp_udp46_state_g.listen_tcpoids[i].so_pgid == 0 ? 0 : 
+					tcp_udp46_state_g.listen_tcpoids[i].so_pgid + 1 ); 
+		break;
+	  default:
+	  	assert(0);	
+		return (SNMP_ERR_NOSUCHNAME);
+	}
+	return (SNMP_ERR_NOERROR);
+
+}
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46.h BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46.h
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46.h	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46.h	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * TCP-MIB and UDP-MIB for SNMPd.
+ */
+#ifndef __TCP_UDP46_H_INCLUDED__
+#define __TCP_UDP46_H_INCLUDED__
+
+#include "asn1.h"
+#include "snmp.h"
+#include "snmpmod.h"
+#include <sys/socketvar.h>
+#include <netinet/in_pcb.h>	/*for struct xinpgen*/
+#include <netinet/tcp.h>
+#include <netinet/tcp_var.h>	/*for struct tcpstat*/
+#include <sys/file.h>		/*for struct xfile*/
+#include <stdio.h>		/*for fprintf*/
+#include <netinet/udp.h>
+#include <netinet/ip_var.h>
+#include <netinet/udp_var.h>
+
+
+/*a debug macro*/
+#ifndef NDEBUG
+#define	L4_DPRINTF(ARGS) do {			\
+	fprintf(stderr, "L4_DEBUG: ");		\
+	fprintf ARGS;				\
+   } while (0)
+#else
+#define L4_DPRINTF(ARGS)
+#endif /*NDEBUG*/
+
+enum InetAddressType {
+	IAT_unknown	=	0,
+	IAT_ipv4	=	1,
+	IAT_ipv6	=	2,
+	IAT_ipv4z	=	3,
+	IAT_ipv6z	=	4,
+	IAT_dns		=	16
+};		    
+
+
+
+/*
+ * Structure used to hold info about one tcp{4,6} connection
+ * for both active and passive entries
+ */
+struct tcp_index {
+	struct asn_oid	index;		/* SNMP index; ecoded from tcp_index::tp*/
+	struct xtcpcb	*tp;		/* pointer to the TCP control block */
+	pid_t		so_pgid;	/* the PID of owner for this TCP endpoint*/
+};
+
+/*
+ * Structure used to hold info about one udp{4,6} 
+ * endpoint
+ */
+struct udp_index {
+	struct asn_oid	index;		/* SNMP index; ecoded from tcp_index::inp*/
+	struct xinpcb	*inp;		/* pointer to the IN(udp) control block */
+	pid_t		so_pgid;	/* the PID of owner for this UDP endpoint*/
+};
+
+
+struct tcp_udp46_state {
+	struct clockinfo clock_info;
+	uint64_t	tcp_tick;		/*agent tick when TCP data was 
+							last updated*/
+	struct tcpstat	tcpstat;		/*holder for UDP stats (v4 & v6)*/
+	struct xinpgen	*tcp_xinpgen;		/*holder for TCP data obtained via sysctl; 
+							malloc'd*/
+	size_t		tcp_xinpgen_len;	/*the allocated len of the above vector */
+	u_int		tcp_estab_count;	/*value for the scalar named tcpCurrEstab*/
+	u_int		tcp4_total;		/*the number of tcp4 entries*/
+	u_int		all_tcp_total;		/*the number of tcp4 and tcp6 
+							entries (without listeners)*/
+	u_int		listen_tcp_total;	/*the number of tcp4 and tcp6 entries
+							 in listen state*/
+	
+	struct tcp_index *tcp4oids;		/*snmp vector for the tcp4 table; malloc'd*/
+	size_t		tcp4oids_len;		/*the allocated len of the above vector */
+
+	struct tcp_index *all_tcpoids;		/*snmp vector for the unified v4 and v6 
+							tcp table; malloc'd*/
+	size_t		all_tcpoids_len;	/*the allocated len of the above vector */
+
+	struct tcp_index *listen_tcpoids;	/*snmp vector for the unified v4 and v6 listners 
+							tcp table; malloc'd*/
+	size_t		listen_tcpoids_len;	/*the allocated len of the above vector */
+	
+	uint64_t	udp_tick;		/*agent tick when UDP data was updated*/	
+	struct udpstat	udpstat;		/*holder to UDP stats (v4 & v6)*/
+	struct xinpgen	*udp_xinpgen;		/*holder for UDP data obtained via sysctl; 
+							malloc'd*/
+	size_t		udp_xinpgen_len;	/*the allocated len of the above vector */
+	u_int		udp4_total;		/*the number of UDP v4 entries*/
+	u_int		all_udp_total;		/*the number of UDP v4 & v6 entries*/
+
+	struct udp_index *udp4oids;		/*snmp vector for the udp4 table; malloc'd*/
+	size_t		udp4oids_len;		/*the allocated len of the above vector */
+
+	struct udp_index *all_udpoids;		/*snmp vector for the unified v4 and v6 
+							udp table; malloc'd*/
+	size_t		  all_udpoids_len;      /*the allocated len of the above vector */
+	
+	
+	struct xfile 	*xfiles;		/*holder for xfiles; malloc'd*/
+	size_t 		xfiles_len;
+	u_int		xfiles_total;
+
+				
+};
+
+/*
+ * Global variable used to hold all the data
+ * internal to this SNMP module
+ */
+extern
+struct tcp_udp46_state tcp_udp46_state_g;
+
+/*
+ * Get all the TCP{4,6} info from the O/S
+ */
+int
+fetch_tcp(void);
+
+/*
+ * Fetch all xfile info from the 0/S
+ * This info are used to identify TCP/UPD endpoints owners
+ */
+int
+fetch_xfiles(void); 
+
+/*
+ * Get all the UDP{4,6} info from the O/S
+ */
+int
+fetch_udp(void);
+
+#endif /*__TCP_UDP46_H_INCLUDED__*/
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_common.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_common.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_common.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_common.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * TCP-MIB and UDP-MIB for SNMPd: BSNMP's module related stuff
+ */
+#include "tcp_udp46.h"
+#include "tcp_udp46_oid.h"
+#include "tcp_udp46_tree.h"
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <stdlib.h>
+
+
+
+/*internal id got after we'll register the TCP-MIB with the agent */
+static 
+u_int tcp46_registration_id = 0;
+
+/*internal id got after we'll register the UDP-MIB with the agent */
+static 
+u_int udp46_registration_id = 0;
+
+
+/* this our tcp46 module */
+static 
+struct lmodule *tcp_udp46_module;
+
+static 
+const struct asn_oid oid_tcp46 = OIDX_tcpMIB; /*see the generated file tcp_udp46_oid.h*/
+
+static 
+const struct asn_oid oid_udp46 = OIDX_udpMIB; /*see the generated file tcp_udp46_oid.h*/
+
+
+struct tcp_udp46_state tcp_udp46_state_g;
+
+/*
+ * TCP mib module initialization hook.
+ * Returns 0 on success, < 0 on error
+ */
+static
+int tcp_udp46_init(struct lmodule * mod, int argc __unused, char *argv[] __unused) {
+
+	size_t len  = 0;
+	
+	tcp_udp46_module = mod;
+	
+	memset(&tcp_udp46_state_g, 0, sizeof(struct tcp_udp46_state));
+	
+	len = sizeof(tcp_udp46_state_g.clock_info);
+	if (sysctlbyname("kern.clockrate", &tcp_udp46_state_g.clock_info, &len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "kern.clockrate: %m");
+		return (-1);
+	}
+	if (len != sizeof(tcp_udp46_state_g.clock_info)) {
+		syslog(LOG_ERR, "kern.clockrate: wrong size");
+		return (-1);
+	}	
+	L4_DPRINTF((stderr, "[%s] done.\n", __func__));			
+	return (0);    
+}
+
+/*
+ * TCP mib module finalization hook.
+ * Returns 0 on success, < 0 on error
+ */
+static 
+int tcp_udp46_fini(void) {
+	/*TCP zone*/
+	if (tcp_udp46_state_g.tcp4oids != NULL && tcp_udp46_state_g.tcp4oids_len > 0) {
+		free(tcp_udp46_state_g.tcp4oids);
+		tcp_udp46_state_g.tcp4oids = NULL;
+		tcp_udp46_state_g.tcp4oids_len = 0;
+	}
+
+	if (tcp_udp46_state_g.all_tcpoids != NULL && tcp_udp46_state_g.all_tcpoids_len > 0) {
+		free(tcp_udp46_state_g.all_tcpoids);
+		tcp_udp46_state_g.all_tcpoids = NULL;
+		tcp_udp46_state_g.all_tcpoids_len = 0;
+	}
+
+	if (tcp_udp46_state_g.listen_tcpoids != NULL && tcp_udp46_state_g.listen_tcpoids_len > 0) {
+		free(tcp_udp46_state_g.listen_tcpoids);
+		tcp_udp46_state_g.listen_tcpoids = NULL;
+		tcp_udp46_state_g.listen_tcpoids_len = 0;
+	}
+
+	if (tcp_udp46_state_g.tcp_xinpgen != NULL && tcp_udp46_state_g.tcp_xinpgen_len > 0) {
+		free(tcp_udp46_state_g.tcp_xinpgen);
+		tcp_udp46_state_g.tcp_xinpgen = NULL;
+		tcp_udp46_state_g.tcp_xinpgen_len = 0;
+	}
+
+	/*UDP zone*/
+	if (tcp_udp46_state_g.udp_xinpgen != NULL && tcp_udp46_state_g.udp_xinpgen_len > 0) {
+		free(tcp_udp46_state_g.udp_xinpgen);
+		tcp_udp46_state_g.udp_xinpgen = NULL;
+		tcp_udp46_state_g.udp_xinpgen_len = 0;
+	}
+
+
+	if (tcp_udp46_state_g.udp4oids != NULL && tcp_udp46_state_g.udp4oids_len > 0) {
+		free(tcp_udp46_state_g.udp4oids);
+		tcp_udp46_state_g.udp4oids = NULL;
+		tcp_udp46_state_g.udp4oids_len = 0;
+	}
+
+	if (tcp_udp46_state_g.all_udpoids != NULL && tcp_udp46_state_g.all_udpoids_len > 0) {
+		free(tcp_udp46_state_g.all_udpoids);
+		tcp_udp46_state_g.all_udpoids = NULL;
+		tcp_udp46_state_g.all_udpoids_len = 0;
+	}
+
+
+	/*XFILES zone*/
+	if (tcp_udp46_state_g.xfiles != NULL && tcp_udp46_state_g.xfiles_len > 0 ) {
+		free(tcp_udp46_state_g.xfiles);
+		tcp_udp46_state_g.xfiles = NULL;
+		tcp_udp46_state_g.xfiles_len = 0;
+	}
+		
+	if (tcp46_registration_id > 0) {
+		or_unregister(tcp46_registration_id);
+	}	
+	
+	if (udp46_registration_id > 0) {
+		or_unregister(udp46_registration_id);
+	}	
+
+		
+	L4_DPRINTF((stderr, "[%s] done.\n", __func__));
+	return (0);
+
+}
+
+/*
+ * TCP mib module dump function
+ * returns nothing
+ */
+static
+void tcp_udp46_dump_v(void) {
+	/*nothing iteresting here for the time being*/
+        L4_DPRINTF((stderr, "[%s] done.\n ", __func__));		
+}
+
+/*
+ * TCP mib module reconfiguration function
+ * returns nothing
+*/
+static
+void tcp_udp46_config_v(void) {
+	/*nothing iteresting here for the time being*/
+        L4_DPRINTF((stderr, "[%s] done.\n ", __func__));		
+}
+
+
+
+static 
+void tcp_udp46_loading_v(const struct lmodule *mod __unused, int loaded)
+{
+	/*nothing iteresting here for the time being*/
+	if ( loaded == 1 ) {
+		goto LABEL_RETURN;
+        }
+LABEL_RETURN:;	
+        L4_DPRINTF((stderr,"[%s] done.\n ", __func__));       	
+
+}
+
+/*
+ * TCP mib module start operation
+ * returns nothing
+ */
+static
+void tcp_udp46_start_v(void) {
+	tcp46_registration_id = or_register(&oid_tcp46, 
+	   "The MIB module for TCP (rfc 4022).", 
+	   tcp_udp46_module);
+	if (tcp46_registration_id == 0) {
+		syslog(LOG_ERR, "Failed to register the TCP-MIB." );
+		return;
+	}
+	udp46_registration_id = or_register(&oid_udp46, 
+	   "The MIB module for UDP (rfc 4113).", 
+	   tcp_udp46_module);
+	if (udp46_registration_id == 0) {
+		syslog(LOG_ERR, "Failed to register the UDP-MIB." );
+		return;
+	}
+	
+	if (fetch_tcp() == -1) {
+		syslog(LOG_ERR, "Failed to fetch the TCP data in tcp_udp46 module." );
+	}
+			
+
+	if (fetch_udp() == -1) {
+		syslog(LOG_ERR, "Failed to fetch the UDP data in tcp_udp46 module." );
+	}		
+
+        L4_DPRINTF((stderr, "[%s] done.\n ", __func__));       
+}
+
+/*
+ * This identifies the TCP mib module
+ * inside the agent
+ */
+const struct snmp_module config = {
+	"This module implements the TCP-MIB (rfc 4022) and UDP-MIB (rfc 4113)",
+	tcp_udp46_init,
+	tcp_udp46_fini,
+	NULL,			/*idle function, do not use it*/
+	tcp_udp46_dump_v,		
+	tcp_udp46_config_v,		
+	tcp_udp46_start_v,
+	NULL,                   /* proxy a PDU */
+	tcp_udp46_ctree,        /* see the generated tcp_udp46_tree.h */
+	tcp_udp46_CTREE_SIZE,   /* see the generated tcp_udp46_tree.h */ 
+	tcp_udp46_loading_v
+};
+
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_tree.def BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_tree.def
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_tree.def	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/tcp_udp46_tree.def	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,128 @@
+#
+# Copyright (c) 2005 The FreeBSD Project
+# All rights reserved
+# Author: Victor Cruceru <soc-victor@freebsd.org>
+#
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+#
+# This is the .def file for both TCP-MIB and UDP-MIB
+# generated by the gensnmpdef tool from each MIB file
+# and collated manually
+#
+
+(1 internet
+  (2 mgmt
+    (1 mib_2
+      (6 tcp
+        (1 tcpRtoAlgorithm INTEGER op_tcp GET)
+        (2 tcpRtoMin INTEGER op_tcp GET)
+        (3 tcpRtoMax INTEGER op_tcp GET)
+        (4 tcpMaxConn INTEGER op_tcp GET)
+        (5 tcpActiveOpens COUNTER op_tcp GET)
+        (6 tcpPassiveOpens COUNTER op_tcp GET)
+        (7 tcpAttemptFails COUNTER op_tcp GET)
+        (8 tcpEstabResets COUNTER op_tcp GET)
+        (9 tcpCurrEstab GAUGE op_tcp GET)
+        (10 tcpInSegs COUNTER op_tcp GET)
+        (11 tcpOutSegs COUNTER op_tcp GET)
+        (12 tcpRetransSegs COUNTER op_tcp GET)
+        (13 tcpConnTable
+          (1 tcpConnEntry : IPADDRESS INTEGER IPADDRESS INTEGER op_tcpConnTable
+            (1 tcpConnState INTEGER GET SET)
+            (2 tcpConnLocalAddress IPADDRESS GET)
+            (3 tcpConnLocalPort INTEGER GET)
+            (4 tcpConnRemAddress IPADDRESS GET)
+            (5 tcpConnRemPort INTEGER GET)
+          )
+        )
+        (14 tcpInErrs COUNTER op_tcp GET)
+        (15 tcpOutRsts COUNTER op_tcp GET)
+        (17 tcpHCInSegs COUNTER64 op_tcp GET)
+        (18 tcpHCOutSegs COUNTER64 op_tcp GET)
+        (19 tcpConnectionTable
+          (1 tcpConnectionEntry : INTEGER OCTETSTRING UNSIGNED32 INTEGER OCTETSTRING UNSIGNED32 op_tcpConnectionTable
+            (1 tcpConnectionLocalAddressType INTEGER)
+            (2 tcpConnectionLocalAddress OCTETSTRING)
+            (3 tcpConnectionLocalPort UNSIGNED32)
+            (4 tcpConnectionRemAddressType INTEGER)
+            (5 tcpConnectionRemAddress OCTETSTRING)
+            (6 tcpConnectionRemPort UNSIGNED32)
+            (7 tcpConnectionState INTEGER GET SET)
+            (8 tcpConnectionProcess UNSIGNED32 GET)
+          )
+        )
+        (20 tcpListenerTable
+          (1 tcpListenerEntry : INTEGER OCTETSTRING UNSIGNED32 op_tcpListenerTable
+            (1 tcpListenerLocalAddressType INTEGER)
+            (2 tcpListenerLocalAddress OCTETSTRING)
+            (3 tcpListenerLocalPort UNSIGNED32)
+            (4 tcpListenerProcess UNSIGNED32 GET)
+          )
+        )
+      )
+      (7 udp
+        (1 udpInDatagrams COUNTER op_udp GET)
+        (2 udpNoPorts COUNTER op_udp GET)
+        (3 udpInErrors COUNTER op_udp GET)
+        (4 udpOutDatagrams COUNTER op_udp GET)
+        (5 udpTable
+          (1 udpEntry : IPADDRESS INTEGER op_udpTable
+            (1 udpLocalAddress IPADDRESS GET)
+            (2 udpLocalPort INTEGER GET)
+          )
+        )
+        (7 udpEndpointTable
+          (1 udpEndpointEntry : INTEGER OCTETSTRING UNSIGNED32 INTEGER OCTETSTRING UNSIGNED32 UNSIGNED32 op_udpEndpointTable
+            (1 udpEndpointLocalAddressType INTEGER)
+            (2 udpEndpointLocalAddress OCTETSTRING)
+            (3 udpEndpointLocalPort UNSIGNED32)
+            (4 udpEndpointRemoteAddressType INTEGER)
+            (5 udpEndpointRemoteAddress OCTETSTRING)
+            (6 udpEndpointRemotePort UNSIGNED32)
+            (7 udpEndpointInstance UNSIGNED32)
+            (8 udpEndpointProcess UNSIGNED32 GET)
+          )
+        )
+        (8 udpHCInDatagrams COUNTER64 op_udp GET)
+        (9 udpHCOutDatagrams COUNTER64 op_udp GET)
+      )
+      (49 tcpMIB
+        (2 tcpMIBConformance
+          (1 tcpMIBCompliances
+          )
+          (2 tcpMIBGroups
+          )
+        )
+      )
+      (50 udpMIB
+        (2 udpMIBConformance
+          (1 udpMIBCompliances
+          )
+          (2 udpMIBGroups
+          )
+        )
+      )
+    )
+  )
+)
diff -uNpPr BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/udp46_snmp.c BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/udp46_snmp.c
--- BSNMP_CVS/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/udp46_snmp.c	Thu Jan  1 02:00:00 1970
+++ BSNMP_NEW/src/usr.sbin/bsnmpd/modules/snmp_tcp_udp46/udp46_snmp.c	Tue Sep 13 11:21:29 2005
@@ -0,0 +1,733 @@
+/*
+ * Copyright (c) 2005 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Author: Victor Cruceru <soc-victor@freebsd.org>
+ *
+ * Redistribution of this software and documentation and use in source and
+ * binary forms, with or without modification, are permitted provided that
+ * the following conditions are met:
+ *
+ * 1. Redistributions of source code or documentation must retain the above
+ *    copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * UDP-MIB implementation for SNMPd: instrumentation for RFC 4113 covering 
+ * both IPv4 and IPv6 objects
+ */
+/*
+ * Copyright (c) 2001-2003
+ *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).
+ *	All rights reserved.
+ *
+ * Author: Harti Brandt <harti@freebsd.org>
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Begemot: bsnmp/snmp_mibII/mibII_udp.c,v 1.7 2005/05/23 09:03:42 brandt_h Exp $
+ *
+ * udp
+ */
+ 
+#include "tcp_udp46.h"
+#include "tcp_udp46_oid.h"
+#include "tcp_udp46_tree.h"
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/sysctl.h>
+#include <syslog.h>
+
+static int
+udp_compare(const void *p1, const void *p2)
+{
+	int result = 0;
+	const struct udp_index *t1 = p1;
+	const struct udp_index *t2 = p2;
+	assert(t1 != NULL);
+	assert(t2 != NULL);
+	if (t1 == NULL || t2 == NULL) {
+		return 0;
+	}
+	result = asn_compare_oid(&t1->index, &t2->index);
+	if ( result == 0 ) {
+		syslog(LOG_ERR, "udp malfunction: two equal oids.");
+		assert(0);
+	}
+	return result;
+}
+
+static
+pid_t 
+get_endpoint_pid(const struct xinpcb *inp) {
+	struct xfile *xf = NULL;
+	u_int n = 0;
+	assert(inp != NULL);
+	
+	for (xf =  tcp_udp46_state_g.xfiles, n = 0; 
+		n < tcp_udp46_state_g.xfiles_total; ++n, ++xf) {
+		if (xf->xf_data == NULL) {
+			continue;
+		}	
+		if (xf->xf_data == (void *)inp->xi_socket.xso_so) {
+			return (xf->xf_pid);
+		}	
+	}
+	return ((pid_t)0);		
+}
+
+/*
+ * Used to check if the enpoint is already in the oid list
+ * (for the deprecated table - it doesn't have the capability
+ * to handle duplicate endpoints)
+ * Returns 1 if the new endpoint is alreadsy in the table,
+ * 0 if it is not 
+ */
+static
+int check_duplicate_endpoint4(const struct xinpcb *inp) {
+	struct udp_index *_oid = NULL;
+	u_int i = 0;
+	
+
+	assert(inp != NULL);
+	
+
+	
+	for (i = 0, _oid = tcp_udp46_state_g.udp4oids; 
+		i < tcp_udp46_state_g.udp4_total; 
+		i++, _oid++) {
+		if ( _oid->inp == NULL) {
+			continue;
+		}
+		if ( inp->xi_inp.inp_laddr.s_addr == _oid->inp->xi_inp.inp_laddr.s_addr 
+			&& inp->xi_inp.inp_lport == _oid->inp->xi_inp.inp_lport) {
+				return (1); /*duplicate endpoint found*/
+		} 
+	}
+	return (0);
+		
+}
+
+static
+int 
+handle_new_endpoint4(struct udp_index *all_oid, const struct xinpcb *inp) {
+	struct udp_index *_oid = NULL;
+	u_int i = 0;
+	pid_t  pid_owner = 0;
+	in_addr_t inaddr;
+	u_int instance = 1;
+	static 
+	uint32_t 
+	zero_ip6[] ={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+	assert(inp != NULL);
+	
+	pid_owner = get_endpoint_pid(inp); 
+	
+	for (i = 0, _oid = tcp_udp46_state_g.all_udpoids; 
+	  i < tcp_udp46_state_g.all_udp_total; 
+	  i++, _oid++) {
+	  if ( _oid->inp == NULL) {
+		continue;
+	  }
+	  if ( 	_oid->index.subs[0] == (uint32_t)IAT_ipv4 
+		&& 
+		inp->xi_inp.inp_laddr.s_addr == _oid->inp->xi_inp.inp_laddr.s_addr 
+		&& 
+		inp->xi_inp.inp_lport == _oid->inp->xi_inp.inp_lport
+		&& 
+		inp->xi_inp.inp_faddr.s_addr == _oid->inp->xi_inp.inp_faddr.s_addr
+		&& 
+		inp->xi_inp.inp_fport == _oid->inp->xi_inp.inp_fport) {
+			
+			if ( pid_owner	!= _oid->so_pgid ) {
+				instance++;
+			} else {
+				/*duplicate endpoint found*/
+				return (1); 	
+			}
+		} 
+		/*check for an existent IPv6 endpoint bound to 0::0/128  */
+		if ( inp->xi_inp.inp_laddr.s_addr == INADDR_ANY 
+			&& inp->xi_inp.inp_faddr.s_addr == INADDR_ANY ) {
+			if( _oid->index.subs[0] == (uint32_t)IAT_ipv6 &&
+			    _oid->inp->xi_inp.in6p_lport  == inp->xi_inp.inp_lport && 
+				pid_owner == _oid->so_pgid) {
+				if (memcmp(&zero_ip6[0], 
+					&_oid->inp->xi_inp.in6p_laddr, 
+					sizeof(zero_ip6)) == 0
+				   && memcmp(&zero_ip6[0], 
+					&_oid->inp->xi_inp.in6p_faddr, 
+					sizeof(zero_ip6) ) == 0 ) {
+					/*got it*/
+					instance = 
+				  	 (IN6_IS_ADDR_UNSPECIFIED(&_oid->inp->xi_inp.in6p_faddr) ? 
+					  _oid->index.subs[22] : _oid->index.subs[38] );
+
+					_oid->index.len = 7;
+					_oid->index.subs[0] = (uint32_t)IAT_unknown;
+					_oid->index.subs[1] = 0; /*zero/ empty octet sting*/
+					_oid->index.subs[2] = ntohs(inp->xi_inp.inp_lport);
+					_oid->index.subs[3] = (uint32_t)IAT_unknown;
+					_oid->index.subs[4] = 0; /*zero/ empty octet sting*/
+					_oid->index.subs[5] = ntohs(_oid->inp->xi_inp.in6p_fport);
+					/*copy instance number*/
+					_oid->index.subs[6] = instance;
+					return 1;
+				}
+			}	
+
+		}
+		/*end check for the same application bound to zero 
+		v4 & v6 address*/
+		
+	}
+	
+	all_oid->index.subs[0] = (uint32_t)IAT_ipv4;
+	all_oid->index.subs[1] = 4;
+	inaddr = ntohl(inp->xi_inp.inp_laddr.s_addr);
+	all_oid->index.subs[2] = (inaddr >> 24) & 0xff;
+	all_oid->index.subs[3] = (inaddr >> 16) & 0xff;
+	all_oid->index.subs[4] = (inaddr >>  8) & 0xff;
+	all_oid->index.subs[5] = (inaddr >>  0) & 0xff;
+	all_oid->index.subs[6] = ntohs(inp->xi_inp.inp_lport);
+	
+	if(inp->xi_inp.inp_faddr.s_addr == INADDR_ANY && 
+		inp->xi_inp.inp_fport == 0 ){
+		all_oid->index.len = 11;
+		all_oid->index.subs[7] = (uint32_t)IAT_unknown;
+		all_oid->index.subs[8] = 0; /*zero/ empty octet sting*/
+		all_oid->index.subs[9] = 0; /*remote port*/
+		all_oid->index.subs[10] = instance;
+			
+	} else {	
+		all_oid->index.len = 15;
+		all_oid->index.subs[7] = (uint32_t)IAT_ipv4;
+		all_oid->index.subs[8] = 4;
+		inaddr = ntohl(inp->xi_inp.inp_faddr.s_addr);
+		all_oid->index.subs[9] = (inaddr >> 24) & 0xff;
+		all_oid->index.subs[10] = (inaddr >> 16) & 0xff;
+		all_oid->index.subs[11] = (inaddr >>  8) & 0xff;
+		all_oid->index.subs[12] = (inaddr >>  0) & 0xff;
+		all_oid->index.subs[13] = ntohs(inp->xi_inp.inp_fport);
+		all_oid->index.subs[14] = instance;
+	}
+	all_oid->so_pgid = pid_owner;
+	
+		
+	return (0);
+	
+}
+
+
+static
+int 
+handle_new_endpoint6(struct udp_index *all_oid, const struct xinpcb *inp) {
+	struct udp_index *_oid = NULL;
+	u_int i = 0;
+	pid_t  pid_owner = 0;
+	u_int instance = 1;
+
+	assert(inp != NULL);
+	
+	pid_owner = get_endpoint_pid(inp); 
+	
+	for (i = 0, _oid = tcp_udp46_state_g.all_udpoids; 
+		i < tcp_udp46_state_g.all_udp_total; 
+		i++, _oid++) {
+		if ( _oid->inp == NULL) {
+			continue;
+		}
+		if ( _oid->index.subs[0] == (uint32_t)IAT_ipv6 
+		  && IN6_ARE_ADDR_EQUAL(&inp->xi_inp.in6p_laddr,  
+		  	&_oid->inp->xi_inp.in6p_laddr) == 0 
+		  && inp->xi_inp.in6p_lport == _oid->inp->xi_inp.in6p_lport
+		  && IN6_ARE_ADDR_EQUAL(&inp->xi_inp.in6p_faddr,  
+		  	&_oid->inp->xi_inp.in6p_faddr) == 0
+		  && inp->xi_inp.inp_fport == _oid->inp->xi_inp.inp_fport) {
+			
+		  if ( pid_owner != _oid->so_pgid ) {
+			instance++;
+		  } else {
+			return (1); /*duplicate endpoint found*/	
+		  }
+		} 
+		/*check for an existent IPv4 endpoint bound to 0.0.0.0  */
+		if ( IN6_IS_ADDR_UNSPECIFIED(&inp->xi_inp.in6p_laddr)
+			&& IN6_IS_ADDR_UNSPECIFIED(&inp->xi_inp.in6p_faddr)) {
+			if( _oid->index.subs[0] == (uint32_t)IAT_ipv4 &&
+			    _oid->inp->xi_inp.inp_lport  == inp->xi_inp.in6p_lport && 
+				pid_owner == _oid->so_pgid) {
+				if ( inp->xi_inp.inp_faddr.s_addr == INADDR_ANY && 
+					inp->xi_inp.inp_laddr.s_addr == INADDR_ANY) {
+					/*got it*/
+					instance = 
+					  (_oid->inp->xi_inp.inp_faddr.s_addr == INADDR_ANY ? 
+					  _oid->index.subs[10] : _oid->index.subs[14] );
+					  
+					_oid->index.len = 7;
+					_oid->index.subs[0] = (uint32_t)IAT_unknown;
+					_oid->index.subs[1] = 0; /*zero/ empty octet sting*/
+					_oid->index.subs[2] = ntohs(inp->xi_inp.inp_lport);
+					_oid->index.subs[3] = (uint32_t)IAT_unknown;
+					_oid->index.subs[4] = 0; /*zero/ empty octet sting*/
+					_oid->index.subs[5] = ntohs(_oid->inp->xi_inp.in6p_fport);
+					/*copy instance number*/
+					_oid->index.subs[6] = instance;
+					return 1;
+				}
+			}	
+
+		}/*end check for the same application bound to zero v4 & v6 address*/
+		
+		
+	}
+	
+	if ( IN6_IS_ADDR_UNSPECIFIED(&inp->xi_inp.in6p_faddr) && 
+		inp->xi_inp.in6p_fport == 0 ) {
+		all_oid->index.len = 23;
+
+		all_oid->index.subs[0] = (uint32_t)IAT_ipv6;
+		all_oid->index.subs[1] = 16;
+		for (i=0; i<16; i++) {
+			all_oid->index.subs[2+i] = inp->xi_inp.in6p_laddr.s6_addr[i];
+		}
+		all_oid->index.subs[18] = ntohs(inp->xi_inp.in6p_lport);
+		all_oid->index.subs[19] = (uint32_t)IAT_unknown;
+		all_oid->index.subs[20] = 0;	/*remote addess, zero octet string*/
+		all_oid->index.subs[21] = 0;	/*remote port*/
+		all_oid->index.subs[22] = instance;
+			
+	} else {	
+		all_oid->index.len = 39;
+
+		all_oid->index.subs[0] = (uint32_t)IAT_ipv6;
+		all_oid->index.subs[0] = 16;
+		for (i=0; i<16; i++) {
+			all_oid->index.subs[2+i] = inp->xi_inp.in6p_laddr.s6_addr[i];
+			all_oid->index.subs[21+i] = inp->xi_inp.in6p_faddr.s6_addr[i];
+		}
+		all_oid->index.subs[18] = ntohs(inp->xi_inp.in6p_lport);
+		all_oid->index.subs[19] = (uint32_t)IAT_ipv6;
+		all_oid->index.subs[20] = 16;
+		all_oid->index.subs[37] = ntohs(inp->xi_inp.in6p_fport);
+		all_oid->index.subs[38] = instance;
+	}	
+	
+	all_oid->so_pgid = pid_owner;
+	
+		
+	return (0);
+	
+}
+
+
+
+int
+fetch_udp(void)
+{
+	size_t len = 0;
+	struct xinpgen *ptr = NULL;
+	struct xinpcb *inp = NULL;
+	struct udp_index *oid = NULL;
+	struct udp_index *all_oid = NULL;
+	in_addr_t inaddr;
+
+	len = sizeof(tcp_udp46_state_g.udpstat);
+	if (sysctlbyname("net.inet.udp.stats", &tcp_udp46_state_g.udpstat, 
+		&len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "net.inet.udp.stats: %m");
+		return (-1);
+	}
+	if (len != sizeof(tcp_udp46_state_g.udpstat)) {
+		syslog(LOG_ERR, "net.inet.udp.stats: wrong size");
+		return (-1);
+	}
+
+	tcp_udp46_state_g.udp_tick = get_ticks();
+
+	len = 0;
+	if (sysctlbyname("net.inet.udp.pcblist", NULL, &len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "net.inet.udp.pcblist: %m");
+		return (-1);
+	}
+	
+	L4_DPRINTF((stderr, "[%s] Got %d len at net.inet.udp.pcblist .\n", __func__, len));
+	
+	if (len > tcp_udp46_state_g.udp_xinpgen_len) {
+		if ((ptr = realloc(tcp_udp46_state_g.udp_xinpgen, len)) == NULL) {
+			syslog(LOG_ERR, "%zu: %m", len);
+			return (-1);
+		}
+		tcp_udp46_state_g.udp_xinpgen = ptr;
+		tcp_udp46_state_g.udp_xinpgen_len = len;
+		memset(tcp_udp46_state_g.udp_xinpgen, 0, len);
+	}
+	if (sysctlbyname("net.inet.udp.pcblist", tcp_udp46_state_g.udp_xinpgen, 
+		&len, NULL, 0) == -1) {
+		syslog(LOG_ERR, "net.inet.udp.pcblist: %m");
+		return (-1);
+	}
+
+	tcp_udp46_state_g.udp4_total = 0;
+	
+	tcp_udp46_state_g.all_udp_total = 0;
+	
+	if (fetch_xfiles() != 0) {
+		L4_DPRINTF((stderr, "[%s] Failed to fetch the xfiles\n ", __func__ ));
+	}
+
+		
+	ptr = (struct xinpgen *)tcp_udp46_state_g.udp_xinpgen;
+	for (ptr = (struct xinpgen *)((char *)ptr + ptr->xig_len);
+	     ptr->xig_len > sizeof(struct xinpgen);
+             ptr = (struct xinpgen *)((char *)ptr + ptr->xig_len)) {
+		inp = (struct xinpcb *)ptr;
+		
+		/* Ignore sockets for protocols other than the desired one. */
+		if (inp->xi_socket.xso_protocol != IPPROTO_UDP) {
+			continue;
+		}
+		
+		if (inp->xi_inp.inp_gencnt > tcp_udp46_state_g.udp_xinpgen->xig_gen) {
+			continue;
+		}
+
+		if ( inp->xi_inp.inp_lport == 0 ) {
+			continue;
+		}
+				
+		if ((inp->xi_inp.inp_vflag & INP_IPV4) == INP_IPV4 ) {
+			tcp_udp46_state_g.udp4_total++;
+		}
+		
+		if ((inp->xi_inp.inp_vflag & (INP_IPV6 | INP_IPV6PROTO | INP_IPV4)) != 0) {
+			tcp_udp46_state_g.all_udp_total++;
+		}
+		
+	}
+
+	if (tcp_udp46_state_g.udp4oids_len < tcp_udp46_state_g.udp4_total) {
+		oid = realloc(tcp_udp46_state_g.udp4oids, 
+			tcp_udp46_state_g.udp4_total * sizeof(struct udp_index));
+		if (oid == NULL) {
+			free(tcp_udp46_state_g.udp4oids);
+			tcp_udp46_state_g.udp4oids_len = 0;
+			return (0);
+		}
+		tcp_udp46_state_g.udp4oids = oid;
+		tcp_udp46_state_g.udp4oids_len = tcp_udp46_state_g.udp4_total;
+	}
+
+	if (tcp_udp46_state_g.all_udpoids_len < tcp_udp46_state_g.all_udp_total) {
+		all_oid = realloc(tcp_udp46_state_g.all_udpoids, 
+			tcp_udp46_state_g.all_udp_total * sizeof(struct udp_index));
+		if (all_oid == NULL) {
+			free(tcp_udp46_state_g.all_udpoids);
+			tcp_udp46_state_g.all_udpoids_len = 0;
+			return (0);
+		}
+		tcp_udp46_state_g.all_udpoids = all_oid;
+		tcp_udp46_state_g.all_udpoids_len = tcp_udp46_state_g.all_udp_total;
+	}
+
+
+	L4_DPRINTF((stderr, 
+		"[%s] Got %d udp4 endpoints, %d udp{4,6} endpoints.\n", 
+		__func__, 
+		tcp_udp46_state_g.udp4_total,
+		tcp_udp46_state_g.all_udp_total)); 
+
+	/*Finally fill in the SNMP indexes*/
+        memset(tcp_udp46_state_g.udp4oids, 0, 
+		tcp_udp46_state_g.udp4_total * sizeof(struct udp_index) );
+
+        memset(tcp_udp46_state_g.all_udpoids, 0, 
+		tcp_udp46_state_g.all_udp_total * sizeof(struct udp_index) );
+
+
+	oid = tcp_udp46_state_g.udp4oids;
+	all_oid  = tcp_udp46_state_g.all_udpoids;
+	
+	ptr = (struct xinpgen *)tcp_udp46_state_g.udp_xinpgen;
+	for (ptr = (struct xinpgen *)((char *)ptr + ptr->xig_len);
+	     ptr->xig_len > sizeof(struct xinpgen);
+             ptr = (struct xinpgen *)((char *)ptr + ptr->xig_len)) {
+		inp = (struct xinpcb *)ptr;
+
+		/* Ignore sockets for protocols other than the desired one. */
+		if (inp->xi_socket.xso_protocol != IPPROTO_UDP) {
+			continue;
+		}
+
+		
+		if (inp->xi_inp.inp_gencnt > tcp_udp46_state_g.udp_xinpgen->xig_gen) {
+			continue;
+		} 
+		
+		if ( inp->xi_inp.inp_lport == 0 ) {
+			continue;
+		}
+		
+		if ((inp->xi_inp.inp_vflag & INP_IPV4) == INP_IPV4 ) {
+			if (check_duplicate_endpoint4(inp) == 1) {
+				assert(tcp_udp46_state_g.udp4_total > 1);
+				tcp_udp46_state_g.udp4_total--;
+			} else {
+				oid->inp = inp;
+				oid->index.len = 5;
+				inaddr = ntohl(inp->xi_inp.inp_laddr.s_addr);
+				oid->index.subs[0] = (inaddr >> 24) & 0xff;
+				oid->index.subs[1] = (inaddr >> 16) & 0xff;
+				oid->index.subs[2] = (inaddr >>  8) & 0xff;
+				oid->index.subs[3] = (inaddr >>  0) & 0xff;
+				oid->index.subs[4] = ntohs(inp->xi_inp.inp_lport);
+				oid++;
+			}
+			
+			if (handle_new_endpoint4(all_oid, inp) == 0){
+				all_oid->inp = inp;
+				all_oid++;
+			} else {
+				assert(tcp_udp46_state_g.all_udp_total > 1);
+				tcp_udp46_state_g.all_udp_total--;
+			}
+			
+		}
+		
+		if ((inp->xi_inp.inp_vflag & (INP_IPV6 | INP_IPV6PROTO )) != 0 )	{
+			if (handle_new_endpoint6(all_oid, inp) == 0){
+				all_oid->inp = inp;
+				all_oid++;
+			} else {
+				assert(tcp_udp46_state_g.all_udp_total > 1);
+				tcp_udp46_state_g.all_udp_total--;
+			}
+			
+		}
+		
+
+		
+	}
+
+	qsort(tcp_udp46_state_g.udp4oids, 
+		tcp_udp46_state_g.udp4_total, 
+		sizeof(struct udp_index), udp_compare);
+
+	qsort(tcp_udp46_state_g.all_udpoids, 
+		tcp_udp46_state_g.all_udp_total, 
+		sizeof(struct udp_index), udp_compare);
+
+
+	return (0);
+}
+
+
+int	
+op_udp(struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		abort();
+
+	  case SNMP_OP_GET:
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+		assert(0);
+		return (SNMP_ERR_GENERR);
+	}
+
+	if (tcp_udp46_state_g.udp_tick < this_tick)
+		if (fetch_udp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_udpInDatagrams:
+		value->v.uint32 = tcp_udp46_state_g.udpstat.udps_ipackets;
+		break;
+
+	  case LEAF_udpNoPorts:
+		value->v.uint32 = tcp_udp46_state_g.udpstat.udps_noport +
+		    tcp_udp46_state_g.udpstat.udps_noportbcast +
+		    tcp_udp46_state_g.udpstat.udps_noportmcast;
+		break;
+
+	  case LEAF_udpInErrors:
+		value->v.uint32 = tcp_udp46_state_g.udpstat.udps_hdrops +
+		    tcp_udp46_state_g.udpstat.udps_badsum +
+		    tcp_udp46_state_g.udpstat.udps_badlen +
+		    tcp_udp46_state_g.udpstat.udps_fullsock;
+		break;
+
+	  case LEAF_udpOutDatagrams:
+		value->v.uint32 = tcp_udp46_state_g.udpstat.udps_opackets;
+		break;
+	  case LEAF_udpHCInDatagrams:
+	  	/*FIX ME: need 64-bit stats*/
+	  	value->v.counter64 = tcp_udp46_state_g.udpstat.udps_ipackets; 
+	  	break;
+	  case LEAF_udpHCOutDatagrams:
+	  	/*FIX ME: need 64-bit stats*/
+	  	value->v.counter64 = tcp_udp46_state_g.udpstat.udps_opackets; 
+	  	break;
+	  		
+	}
+	return (SNMP_ERR_NOERROR);
+
+}
+
+int	
+op_udpTable(struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	u_int i;
+
+	if (tcp_udp46_state_g.udp_tick < this_tick)
+		if (fetch_udp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		for (i = 0; i < tcp_udp46_state_g.udp4_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.udp4oids[i].index) < 0)
+				break;
+		if (i == tcp_udp46_state_g.udp4_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		index_append(&value->var, sub, &tcp_udp46_state_g.udp4oids[i].index);
+		break;
+
+	  case SNMP_OP_GET:
+		for (i = 0; i < tcp_udp46_state_g.udp4_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.udp4oids[i].index) == 0)
+				break;
+		if (i == tcp_udp46_state_g.udp4_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  default:
+		abort();
+	}
+
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_udpLocalAddress:
+		value->v.ipaddress[0] = tcp_udp46_state_g.udp4oids[i].index.subs[0];
+		value->v.ipaddress[1] = tcp_udp46_state_g.udp4oids[i].index.subs[1];
+		value->v.ipaddress[2] = tcp_udp46_state_g.udp4oids[i].index.subs[2];
+		value->v.ipaddress[3] = tcp_udp46_state_g.udp4oids[i].index.subs[3];
+		break;
+
+	  case LEAF_udpLocalPort:
+		value->v.integer = tcp_udp46_state_g.udp4oids[i].index.subs[4];
+		break;
+
+	}
+	return (SNMP_ERR_NOERROR);
+}
+
+int	
+op_udpEndpointTable(struct snmp_context *ctx __unused, struct snmp_value *value,
+    u_int sub, u_int iidx __unused, enum snmp_op op)
+{
+	u_int i;
+
+	if (tcp_udp46_state_g.udp_tick < this_tick)
+		if (fetch_udp() == -1)
+			return (SNMP_ERR_GENERR);
+
+	switch (op) {
+
+	  case SNMP_OP_GETNEXT:
+		for (i = 0; i < tcp_udp46_state_g.all_udp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.all_udpoids[i].index) < 0)
+				break;
+		if (i == tcp_udp46_state_g.all_udp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		index_append(&value->var, sub, &tcp_udp46_state_g.all_udpoids[i].index);
+		break;
+
+	  case SNMP_OP_GET:
+		for (i = 0; i < tcp_udp46_state_g.all_udp_total; i++)
+			if (index_compare(&value->var, sub, 
+				&tcp_udp46_state_g.all_udpoids[i].index) == 0)
+				break;
+		if (i == tcp_udp46_state_g.all_udp_total)
+			return (SNMP_ERR_NOSUCHNAME);
+		break;
+
+	  case SNMP_OP_SET:
+		return (SNMP_ERR_NOT_WRITEABLE);
+
+	  case SNMP_OP_ROLLBACK:
+	  case SNMP_OP_COMMIT:
+	  default:
+		abort();
+	}
+
+	switch (value->var.subs[sub - 1]) {
+
+	  case LEAF_udpEndpointProcess:
+  	  	/*this is from hrSWRunTable, where the index is pid + 1 */
+		value->v.uint32 = (tcp_udp46_state_g.all_udpoids[i].so_pgid == 0 ? 0 : 
+				tcp_udp46_state_g.all_udpoids[i].so_pgid + 1);
+		break;
+
+	  default:
+		return (SNMP_ERR_NOSUCHNAME);
+		
+
+	}
+	return (SNMP_ERR_NOERROR);
+
+}
+
